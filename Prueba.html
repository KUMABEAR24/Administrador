<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta http-equiv="Content-Security-Policy"
          content="default-src 'self' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://unpkg.com https://esm.sh;
                   script-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://unpkg.com https://esm.sh;
                   style-src 'self' 'unsafe-inline';
                   connect-src 'self' https://script.google.com;">

    <title>GESTION NEGACIONES EJE CAFETERO</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'primary': '#4e9fef',
              'background': '#1e1e1e',
              'surface': '#2d2d2d',
              'text-primary': '#d4d4d4',
              'text-secondary': '#a0a0a0',
              'border-color': '#444',
              'header': '#3a3a3a',
              'highlight': '#252526',
              'warning': '#6e550c',
              'archive': '#3a3a3a',
              'success': '#28a745',
              'danger': '#a02d2d',
              'danger-hover': '#c0392b',
              'btn-primary': '#0e639c',
              'btn-primary-hover': '#1a73e8',
            },
            animation: {
              'flash-success': 'flash-success 1s ease-out',
               // Optional: Add fade-in animation for notifications
               'fade-in-down': 'fade-in-down 0.5s ease-out forwards',
            },
            keyframes: {
              'flash-success': {
                'from': { backgroundColor: '#28a745' },
                'to': { backgroundColor: 'transparent' },
              },
               // Keyframes for fade-in
               'fade-in-down': {
                 '0%': { opacity: '0', transform: 'translateY(-10px)' },
                 '100%': { opacity: '1', transform: 'translateY(0)' },
               },
            }
          }
        }
      }
    </script>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client"
      }
    }
    </script>
</head>

<body class="bg-background text-text-primary">
    <div id="root"></div>

    <script type="text/babel" data-presets="react" data-type="module">
        import React, { useState, useEffect, useCallback, useMemo } from 'react';
        import ReactDOM from 'react-dom/client';

        // =================================================================================
        // INLINED: constants.ts
        // =================================================================================
        const PORTAL_HEADERS = [
            "Fecha_Neg", "Sucursal", "No_Orden", "No_Cedula", "Nombre", "Entidad_Ejecutora",
            "Motivo_Negacion", "Usuario_Emitio", "Auditor", "Observacion_Auditor", "Observacion_Ejecutivo",
            "Programa", "Plan", "Antiguedad", "EPS", "Telefono", "Celular", "Direccion", "Email", "Edad",
            "Tipo_Usuario", "Llamada", "Complementariedad", "Notificacion", "Gestion_Negacion", "Alternativa",
            "Observacion_Alternativa", "Monto", "Nit_Prestador", "Fecha_Complementariedad", "Tiempo_de_Gestion", "Regional"
        ];

        const PDF_HEADERS = [
          "Archivo (No. Orden)", "Descripción", "Justificación", "Fundamento Legal", "Código"
        ];

        const TRACKING_STATUSES = ['Pendiente', 'En Gestión', 'Finalizado'];

        const COMMON_EMAIL_BODY = `<br><br><b>Si tiene alguna duda puede contactarse por medio de los canales que tenemos disponibles para usted:</b><br>· Nuestra línea nacional 018000931666. O con nuestras líneas locales: Cali (602) 489 0073, Bogotá (601) 743 5485, Medellín (604) 604 4507, Barranquilla (605) 385 3165, Bucaramanga (607) 697 3350, Cartagena (605) 693 9853, Tuluá (602) 235 9483, Valledupar (605)588 5699, Pereira (606) 340 2635.<br>· WhatsApp: 317-224-07-94<br><br>Gracias por su Atención.`;
        const SIGNATURE = `<br><br>Cordialmente,<br><br><b>Juan Ricardo Morales Agudelo</b><br>Ejecutivo De Atención Integral<br>Coomeva Medicina Prepagada<br>Cra. 13 No.11-12 Centro Médico Circunvalar<br>Coomeva Medicina Prepagada Pereira, Risaralda<br><br><i>Este correo es generado automáticamente, por favor no responda este mensaje.</i>`;

        const defaultTemplates = [
            { id: 'tpl_neg_gen', name: 'PLANTILLA NEGACION GENERAL', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar información acerca del servicio {{Motivo_Negacion}} que en esta oportunidad no está aprobado debido a que corresponde a EXCLUSIÓN ({{Descripcion_PDF}}), ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>El servicio negado anteriormente; debe tramitarlo a través su EPS asignada. Adjuntamos soporte de la carta de negación.` },
            { id: 'tpl_neg_pert', name: 'PLANTILLA NO PERTINENCIA Y TEMAS ESTETICOS', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar información acerca del servicio {{Motivo_Negacion}} que en esta oportunidad No está aprobado debido a que corresponde a NO PERTINENCIA ({{Descripcion_PDF}}), ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>` },
            { id: 'tpl_comp_coinc', name: 'COMPLEMENTARIEDAD RED COINCIDENTE', body: `Apreciado Usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y el de su familia. Por medio de este correo queremos brindar información acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no fue aprobado, debido a que ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>Sin embargo, está en gestión a través de su EPS ({{EPS}}) con el número de radicado ({{Radicado_Comp}}), puede realizar seguimiento mediante la oficina virtual de la EPS ({{Oficina_Virtual_EPS}}).<br><br>Adicional estaremos haciendo seguimiento al radicado y una vez se encuentre gestionado por la EPS, le notificaremos por medio de correo electrónico.` },
            { id: 'tpl_comp_no_coinc', name: 'COMPLEMENTARIEDAD RED NO COINCIDENTE', body: `Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar información acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no está aprobado, debido a que corresponde a ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>El prestador actual solicitado, no tiene convenio con la EPS, por lo que los costos adicionales del servicio o insumo estarán a cargo del paciente. Sin embargo; se radica la solicitud ante su EPS con el número ({{Radicado_Comp}}) por favor realizar seguimiento mediante la oficina virtual de la EPS ({{Oficina_Virtual_EPS}}).` },
            { id: 'tpl_comp_ayudas', name: 'COMPLEMENTARIEDAD AYUDAS DIAGNOSTICAS', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar información acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no está aprobado debido a que corresponde a ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>Sin embargo, se encuentra en gestión a través de su EPS con el número de radicado ({{Radicado_Comp}}), por favor realizar seguimiento mediante la oficina virtual. ({{Oficina_Virtual_EPS}}).` },
        ];


        // =================================================================================
        // INLINED: services/utilityService.ts
        // =================================================================================
        const capitalizeWords = (str) => {
          if (!str) return '';
          return str.toLowerCase().replace(/\b\w/g, char => char.toUpperCase());
        };

        const processPastedData = (pastedText, headers) => {
          return pastedText
            .trim()
            .split(/\r?\n/)
            .map(rowText => {
              const cells = rowText.split('\t');
              const rowObject = {};
              headers.forEach((header, index) => {
                 // Assign cell value if it exists, otherwise assign empty string
                 rowObject[header] = cells[index] ? cells[index].trim() : '';
              });
              return rowObject;
            });
        };


        const replacePlaceholders = (templateBody, data) => {
          const getOficinaVirtual = (eps) => {
            const e = (eps || "").toUpperCase();
            if (e.includes("NUEVA EPS")) return `<a href='https://portal.nuevaeps.com.co/Portal/home.jspx' target='_blank' rel='noopener noreferrer' style='color: #1a73e8; text-decoration: underline;'>NUEVA EPS</a>`; // Added style
            if (e.includes("SALUD TOTAL")) return `<a href='https://saludtotal.com.co/' target='_blank' rel='noopener noreferrer' style='color: #1a73e8; text-decoration: underline;'>SALUD TOTAL</a>`; // Added style
            return eps || ''; // Return empty string if eps is null/undefined
          };

          // Ensure data is an object, default to empty object if not
          const safeData = (typeof data === 'object' && data !== null) ? data : {};
          const fullData = { ...safeData, Oficina_Virtual_EPS: getOficinaVirtual(safeData.EPS) };

          // Ensure templateBody is a string
          const safeTemplateBody = typeof templateBody === 'string' ? templateBody : '';

          return safeTemplateBody.replace(/\{\{(\w+)\}\}/g, (match, key) => {
             // Access data safely, default to empty string if key doesn't exist or value is null/undefined
             const value = fullData[key];
             return value !== null && value !== undefined ? String(value) : '';
          });
        };


        const exportDetailedReport = (finalData, trackingData, archivedData) => {
          try {
            const masterDataMap = new Map();

            // Ensure all inputs are arrays before spreading
            const safeFinalData = Array.isArray(finalData) ? finalData : [];
            const safeTrackingData = Array.isArray(trackingData) ? trackingData : [];
            const safeArchivedData = Array.isArray(archivedData) ? archivedData : [];

            [...safeFinalData, ...safeTrackingData, ...safeArchivedData].forEach(row => {
              if (row && row.No_Orden) {
                const key = String(row.No_Orden).trim();
                if (key) {
                  const existing = masterDataMap.get(key) || {};
                  // Deep merge might be too complex, simple override is usually sufficient here
                  const mergedRow = { ...existing, ...row };
                  masterDataMap.set(key, mergedRow);
                }
              }
            });

            const masterData = Array.from(masterDataMap.values());

            if (masterData.length === 0) {
              alert("No hay datos consolidados para exportar.");
              return;
            }

            const wb = XLSX.utils.book_new();

            // Create sheets ensuring headers match PORTAL_HEADERS + Tracking specific ones if needed
             const allHeaders = [ ...new Set([
                 ...PORTAL_HEADERS,
                 // Add headers specific to tracking/archived if they exist and aren't in PORTAL_HEADERS
                 'Fecha_Ing', 'Radicado', 'Estado', 'Notas'
             ])];


            // Add sheets only if data exists, using allHeaders for consistency
            if (safeFinalData.length > 0) {
              const ws1 = XLSX.utils.json_to_sheet(safeFinalData, { header: allHeaders });
              XLSX.utils.book_append_sheet(wb, ws1, "Casos en Revisión");
            }

            if (safeTrackingData.length > 0) {
              const ws2 = XLSX.utils.json_to_sheet(safeTrackingData, { header: allHeaders });
              XLSX.utils.book_append_sheet(wb, ws2, "Seguimiento Activo");
            }

            if (safeArchivedData.length > 0) {
              const ws3 = XLSX.utils.json_to_sheet(safeArchivedData, { header: allHeaders });
              XLSX.utils.book_append_sheet(wb, ws3, "Seguimiento Archivado");
            }

            // Always add Maestro Consolidado if masterData exists, using allHeaders
            const ws4 = XLSX.utils.json_to_sheet(masterData, { header: allHeaders });
            XLSX.utils.book_append_sheet(wb, ws4, "Maestro Consolidado");

            XLSX.writeFile(wb, `Sigweb_Reporte_Detallado_${new Date().toISOString().slice(0, 10)}.xlsx`);
          } catch (error) {
            console.error("Falló la exportación del reporte Excel:", error);
            alert("Ocurrió un error al generar el reporte detallado.");
          }
        };


        // =================================================================================
        // INLINED: services/templateService.ts
        // =================================================================================
        const TEMPLATE_STORAGE_KEY = 'sigweb_emailTemplates';

        const loadTemplates = () => {
          let loadedTemplates = [...defaultTemplates]; // Start with defaults
          try {
            const storedTemplates = localStorage.getItem(TEMPLATE_STORAGE_KEY);
            if (storedTemplates) {
              const parsed = JSON.parse(storedTemplates);
              // Robust validation
              if (Array.isArray(parsed) && parsed.every(t => t && typeof t.id === 'string' && typeof t.name === 'string' && typeof t.body === 'string')) {
                 loadedTemplates = parsed; // Use stored if valid
                 console.log("Loaded templates from localStorage.");
              } else {
                 console.warn("Stored templates data is invalid. Using defaults and removing invalid data.");
                 localStorage.removeItem(TEMPLATE_STORAGE_KEY); // Remove invalid data
              }
            } else {
                 console.log("No templates found in localStorage. Using defaults.");
            }
          } catch (error) {
            console.error("Error loading templates from localStorage. Using defaults.", error);
            localStorage.removeItem(TEMPLATE_STORAGE_KEY); // Remove potentially corrupted data
          }

           // Ensure all default templates are present (add if missing)
           const loadedIds = new Set(loadedTemplates.map(t => t.id));
           const missingDefaults = defaultTemplates.filter(dt => !loadedIds.has(dt.id));
           if (missingDefaults.length > 0) {
               console.log("Adding missing default templates.");
               loadedTemplates = [...loadedTemplates, ...missingDefaults];
               saveTemplates(loadedTemplates); // Save the combined list back immediately
           }

           return loadedTemplates;
        };


        const saveTemplates = (templates) => {
          try {
            if (!Array.isArray(templates)) {
              console.error("Attempted to save non-array templates data.");
              alert("Error: No se pudieron guardar las plantillas (datos inválidos).");
              return;
            }
            if (!templates.every(t => t && typeof t.id === 'string' && typeof t.name === 'string' && typeof t.body === 'string')) {
               console.error("Attempted to save templates with invalid structure.");
               alert("Error: No se pudieron guardar las plantillas (estructura inválida).");
               return;
            }
            localStorage.setItem(TEMPLATE_STORAGE_KEY, JSON.stringify(templates));
             console.log("Templates saved to localStorage.");
          } catch (error) {
            console.error("Falló el guardado de plantillas en localStorage", error);
             alert("Error: No se pudieron guardar las plantillas localmente. El almacenamiento podría estar lleno o deshabilitado.");
          }
        };


        // =================================================================================
        // INLINED: services/googleSheetService.ts
        // =================================================================================
        const fetchData = async (url) => {
            console.log("Fetching data from:", url);
            if (!url || typeof url !== 'string' || !url.startsWith('https://script.google.com/macros/s/')) {
               throw new Error("URL de Google Apps Script inválida proporcionada para fetchData.");
            }
            try {
                // Add a timestamp to try and prevent caching issues
                const fetchUrl = `${url}?action=getData&t=${Date.now()}`;
                const response = await fetch(fetchUrl);
                console.log("Fetch response status:", response.status, response.statusText);
                if (!response.ok) {
                    let errorText = `HTTP error ${response.status} ${response.statusText}`;
                    try {
                       // Try to get more details from the response body if possible
                       const bodyText = await response.text();
                       if (bodyText) errorText += ` - ${bodyText}`;
                    } catch (e) { console.warn("Could not read error response body:", e); }
                    console.error("Network response was not ok:", errorText);
                    // Provide specific advice for common errors
                    if (response.status === 401 || response.status === 403) {
                       errorText += "\n\n**Sugerencia:** Verifica que el script esté implementado para ejecutarse como 'Yo' y que el acceso a la app web esté configurado como 'Cualquier usuario, incluso anónimo'.";
                    } else if (response.status === 404) {
                        errorText += "\n\n**Sugerencia:** Verifica que la URL del script sea correcta y que la implementación esté activa.";
                    }
                    throw new Error(`La respuesta de la red no fue correcta: ${errorText}`);
                }

                // Check content type before parsing JSON
                const contentType = response.headers.get("content-type");
                if (!contentType || !contentType.includes("application/json")) {
                     console.error("Received non-JSON response:", await response.text());
                     throw new Error(`Respuesta inesperada del servidor (no es JSON). Verifica la implementación del script. Content-Type: ${contentType}`);
                }

                const data = await response.json();
                console.log("Fetched data:", data);

                 // Ensure returned data fields are arrays, default to empty if not present or wrong type
                 const finalData = Array.isArray(data.finalData) ? data.finalData : [];
                 const trackingData = Array.isArray(data.trackingData) ? data.trackingData : [];
                 const archivedData = Array.isArray(data.archivedData) ? data.archivedData : [];
                 const masterTrackingOrders = Array.isArray(data.masterTrackingOrders) ? data.masterTrackingOrders : [];

                return { finalData, trackingData, archivedData, masterTrackingOrders };
            } catch (error) {
                 console.error("Fetch data failed:", error);
                 if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                    throw new Error("Error de red: No se pudo conectar al servidor del script. Verifica la URL y tu conexión a internet.");
                 }
                 // Re-throw errors that already have specific messages
                 if (error.message.startsWith("La respuesta de la red no fue correcta") || error.message.startsWith("Respuesta inesperada del servidor")) {
                    throw error;
                 }
                 // Throw a generic error for other issues
                 throw new Error(`Error al obtener datos: ${error.message}`);
            }
        };


        const saveData = async (url, requestBody) => {
            console.log("Saving data to:", url);
            if (!url || typeof url !== 'string' || !url.startsWith('https://script.google.com/macros/s/')) {
               throw new Error("URL de Google Apps Script inválida proporcionada para saveData.");
            }
            if (!requestBody || typeof requestBody !== 'object' || requestBody.action !== 'saveData' || !requestBody.payload) {
                console.error("Invalid request body for saveData:", requestBody);
                throw new Error("Formato de datos inválido para guardar.");
             }
            const bodyString = JSON.stringify(requestBody);
            console.log(`Save request body size: ~${(bodyString.length / 1024).toFixed(2)} KB`); // Log size

            try {
                // IMPORTANT: POST requests to Apps Script Web Apps often require proper handling of redirects (302)
                // Fetch might not follow automatically in all contexts, especially with 'no-cors'.
                // The 'no-cors' mode is a significant limitation here.
                const response = await fetch(url, {
                    method: 'POST',
                    mode: 'no-cors', // Cannot see response, assume success if no network error
                    cache: 'no-cache', // Prevent caching POST
                    headers: {
                        'Content-Type': 'text/plain;charset=utf-8', // Be explicit with charset
                    },
                    body: bodyString,
                    // redirect: 'follow' // Note: 'redirect' has no effect in 'no-cors' mode
                });

                // Since mode is 'no-cors', response object is opaque. We can't check status.
                console.log("Save request sent via fetch (no-cors). Assuming success if no error was thrown.");
                return { status: 'success', message: 'Datos enviados al servidor (no se pudo verificar respuesta).' };

            } catch (error) {
                console.error("Error during save fetch:", error);
                if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                   throw new Error("Error de red: No se pudo conectar al servidor para guardar. Verifica la URL y tu conexión a internet.");
                }
                 // Check for potential size limits (though hard to detect with no-cors)
                 if (bodyString.length > 100 * 1024) { // Warn if payload is large (e.g., > 100KB)
                    console.warn("Payload size is large, which might exceed Google Apps Script limits.");
                 }
                throw new Error(`Error al guardar datos: ${error.message}`);
            }
        };


        // =================================================================================
        // INLINED: components/Spinner.tsx - No changes needed
        // =================================================================================
        const Spinner = React.memo(() => { // Memoize simple component
          return (
            <div
              className="inline-block h-6 w-6 animate-spin rounded-full border-4 border-solid border-primary border-r-transparent align-[-0.125em] motion-reduce:animate-[spin_1.5s_linear_infinite]" // Slightly smaller spinner
              role="status"
            >
              <span className="!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]">
                Cargando...
              </span>
            </div>
          );
        });

        // =================================================================================
        // INLINED: components/Notification.tsx - Already adjusted
        // =================================================================================
        const Notification = React.memo(({ message, type = 'info', onClose }) => { // Memoize Notification
            const typeClasses = {
                success: 'bg-green-600',
                error: 'bg-red-600',
                warning: 'bg-yellow-500 text-black', // Adjusted warning color
                info: 'bg-blue-600',
            };
            const [isVisible, setIsVisible] = useState(true);
            const timeoutIdRef = useRef(null); // Use ref to store timeout ID

            const handleClose = useCallback(() => {
                setIsVisible(false);
                if (timeoutIdRef.current) {
                    clearTimeout(timeoutIdRef.current); // Clear timeout on manual close
                }
                if (onClose) {
                    onClose();
                }
            }, [onClose]);

            useEffect(() => {
                if (onClose) { // Only auto-close if onClose prop is provided (implies auto-close behavior)
                    timeoutIdRef.current = setTimeout(handleClose, 5000);
                    return () => {
                        if (timeoutIdRef.current) {
                            clearTimeout(timeoutIdRef.current);
                        }
                    };
                }
            }, [handleClose, onClose]); // Rerun effect if handleClose or onClose changes

            if (!isVisible) return null;

            return (
                <div className={`fixed top-5 right-5 z-[250] p-4 rounded-lg shadow-lg text-white ${typeClasses[type] || typeClasses.info} flex items-center gap-4 animate-fade-in-down`}>
                    <span>{message}</span>
                    <button onClick={handleClose} className="text-xl font-bold leading-none ml-2 flex-shrink-0">&times;</button>
                </div>
            );
        });


        // =================================================================================
        // INLINED: components/Header.tsx - Already memoized
        // =================================================================================
        const Header = React.memo(({ onSave, onManageTemplates, onReconfigure }) => {
          console.log("Rendering Header");
          return (
            <header className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 pb-4 border-b border-border-color">
              <div>
                <h1 className="text-2xl lg:text-3xl font-bold text-white">
                  GESTION NEGACIONES EJE CAFETERO
                </h1>
                <p className="text-text-secondary text-sm">Sistema Integrado de Gestión de Flujos de Trabajo</p>
              </div>
              <div className="flex flex-wrap gap-2">
                <button onClick={onManageTemplates} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-3 rounded-lg transition-colors text-xs sm:text-sm">
                  Plantillas
                </button>
                <button onClick={onReconfigure} className="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-3 rounded-lg transition-colors flex items-center gap-1 text-xs sm:text-sm">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0L8.21 5.15a1.5 1.5 0 01-1.25.82l-2.09.28c-1.68.23-2.34 2.26-1.09 3.42l1.52 1.48a1.5 1.5 0 01-.42 2.1l-1.83 1.25c-1.38.94-.92 3.01.7 3.42l2.05.51a1.5 1.5 0 011.1.98l.8 2.07c.43 1.12 2.29 1.12 2.72 0l.8-2.07a1.5 1.5 0 011.1-.98l2.05-.51c1.62-.4 2.08-2.48.7-3.42l-1.83-1.25a1.5 1.5 0 01-.42-2.1l1.52-1.48c1.25-1.16.59-3.19-1.09-3.42L13 5.97a1.5 1.5 0 01-1.25-.82l-.3-1.98zM10 13a3 3 0 100-6 3 3 0 000 6z" clipRule="evenodd" />
                  </svg>
                  Config
                </button>
                <button onClick={onSave} className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-lg transition-colors flex items-center gap-1 text-xs sm:text-sm">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M5.5 16.5a2.5 2.5 0 01-5 0V4.414a1.5 1.5 0 01.44-1.06L4.354.439A1.5 1.5 0 015.414 0H12.5a2.5 2.5 0 012.5 2.5v2" />
                    <path d="M5.5 16.5h8a2.5 2.5 0 002.5-2.5V8.5h-13v5.5a2.5 2.5 0 002.5 2.5z" />
                    <path d="M10.5 10a.5.5 0 01.5-.5h2a.5.5 0 010 1h-2a.5.5 0 01-.5-.5z" />
                  </svg>
                  Guardar
                </button>
              </div>
            </header>
          );
        });

        // =================================================================================
        // INLINED: components/Dashboard.tsx - Already memoized
        // =================================================================================
        const DashboardCard = React.memo(({ title, value, icon }) => (
          <div className="bg-surface p-3 rounded-lg border border-border-color flex items-center">
            <div className="text-2xl text-primary mr-3">{icon}</div>
            <div>
              <h4 className="text-xs font-semibold text-text-secondary uppercase tracking-wider">{title}</h4>
              <p className="text-xl font-bold text-text-primary">{value}</p>
            </div>
          </div>
        ));

        const Dashboard = React.memo(({ reviewCount, trackingCount, archivedCount, editsCount }) => (
          <section id="dashboard" className="grid grid-cols-2 sm:grid-cols-4 gap-3 sm:gap-4">
            <DashboardCard title="En Revisión" value={reviewCount} icon={'📋'} />
            <DashboardCard title="Seguimiento" value={trackingCount} icon={'⏳'} />
            <DashboardCard title="Archivados" value={archivedCount} icon={'🗄️'} />
            <DashboardCard title="Edits Pendientes" value={editsCount} icon={'✏️'} />
          </section>
        ));

        // =================================================================================
        // INLINED: components/DataInputArea.tsx - Already memoized
        // =================================================================================
        // ... (DataInputArea code remains the same as previous correct version) ...
        // Ensure the useCallback dependencies are correct if modified
          function DataInputArea({
            id,
            title,
            headers,
            data,
            onDataChange,
            onProcess,
            processButtonText = "Procesar Datos",
            inputType = "paste", // "paste" or "file"
          }) {
            console.log(`Rendering DataInputArea: ${id}`); // Debug log

            const handlePaste = useCallback((e) => {
              e.preventDefault();
              const pastedText = e.clipboardData.getData('text/plain');
              const newRows = processPastedData(pastedText, headers);

              // Ensure data is always an array before filtering
              const currentData = Array.isArray(data) ? data : [];
              // Filter out fully empty objects before adding new rows
              const filteredCurrent = currentData.filter(row => row && Object.values(row).some(val => String(val).trim() !== ''));
              const updatedData = [...filteredCurrent, ...newRows];

              // Add empty rows only if it's the paste input type
              if (inputType === 'paste') {
                const emptyRowCount = updatedData.filter(row => !row || !Object.values(row).some(val => String(val).trim() !== '')).length;
                const targetEmptyRows = 5; // Maintain 5 empty rows for pasting
                if (emptyRowCount < targetEmptyRows) {
                  for (let i = 0; i < (targetEmptyRows - emptyRowCount); i++) {
                    updatedData.push({}); // Add empty object placeholders
                  }
                }
              }

              onDataChange(updatedData);
            }, [data, headers, onDataChange, inputType]);

            const handleCellChange = useCallback((rowIndex, header, value) => {
               // Ensure data is always an array
              const currentData = Array.isArray(data) ? data : [];
              const newData = [...currentData];
              // Ensure the row exists before trying to update it
              if(newData[rowIndex]){
                  // Create a new object for the updated row to ensure immutability
                  newData[rowIndex] = { ...newData[rowIndex], [header]: value };
              } else {
                   console.warn(`Attempted to edit non-existent row at index ${rowIndex}`);
                   return; // Prevent further processing if row doesn't exist
              }

              // Add/remove empty rows only if it's the paste input type
               if (inputType === 'paste') {
                 const targetEmptyRows = 5;
                 // Filter out rows that are completely empty or just whitespace
                 const nonEmptyRows = newData.filter(row => row && Object.values(row).some(val => String(val).trim() !== ''));
                 const currentEmptyRowCount = newData.length - nonEmptyRows.length;

                 // Add empty rows if needed
                 if (currentEmptyRowCount < targetEmptyRows) {
                     for (let i = 0; i < (targetEmptyRows - currentEmptyRowCount); i++) {
                         nonEmptyRows.push({});
                     }
                 }
                 // Trim excess empty rows (leave exactly targetEmptyRows)
                 const finalData = [...nonEmptyRows];
                 while (finalData.filter(row => !row || !Object.values(row).some(val => String(val).trim() !== '')).length > targetEmptyRows && finalData.length > targetEmptyRows) {
                    const lastEmptyIndex = finalData.findLastIndex(row => !row || !Object.values(row).some(val => String(val).trim() !== ''));
                    if (lastEmptyIndex !== -1) {
                        finalData.splice(lastEmptyIndex, 1);
                    } else {
                        break; // Should not happen if logic is correct
                    }
                 }
                 onDataChange(finalData);
              } else {
                   onDataChange(newData); // For file input, just update the data
              }
            }, [data, onDataChange, inputType]);


            const handleFileChange = useCallback((e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const fileData = new Uint8Array(event.target.result);
                        const workbook = XLSX.read(fileData, { type: 'array', cellDates: true, dateNF: 'yyyy-mm-dd' }); // Specify date format hint
                        const sheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];

                        // Get headers separately
                        const headerRow = XLSX.utils.sheet_to_json(worksheet, { header: 1, range: 0, raw: false, defval: '' })[0] || [];
                        const excelHeaders = headerRow.map(h => String(h).trim());

                         // Convert data rows, ensuring dates are parsed correctly
                         // Use raw: false initially to get formatted strings
                        const jsonDataObjects = XLSX.utils.sheet_to_json(worksheet, { raw: false, defval: '' });


                        if (jsonDataObjects.length === 0) {
                            alert("El archivo Excel no contiene filas de datos.");
                            onDataChange([]); // Clear data on empty file
                            e.target.value = null; // Reset file input
                            return;
                        }

                        const normalizeHeadersAndData = (d, excelHeaderList) => {
                            const keyMap = { // Use lowercase keys for matching
                              'fecha neg.': 'Fecha_Neg', 'no. orden': 'No_Orden', 'no. cédula': 'No_Cedula',
                              'entidad ejecutora': 'Entidad_Ejecutora', 'motivo negación': 'Motivo_Negacion',
                              'usuario emitió': 'Usuario_Emitio', 'observación auditor': 'Observacion_Auditor',
                              'observación ejecutivo': 'Observacion_Ejecutivo', 'antigüedad': 'Antiguedad',
                              'teléfono': 'Telefono', 'dirección': 'Direccion', 'tipo usuario': 'Tipo_Usuario',
                              'notificación': 'Notificacion', 'gestión': 'Gestion_Negacion',
                              'observación alternativa': 'Observacion_Alternativa', 'nit prestador': 'Nit_Prestador',
                              'fecha complementariedad': 'Fecha_Complementariedad', 'tiempo de gestion': 'Tiempo_de_Gestion',
                              'sucursal': 'Sucursal', 'nombre': 'Nombre', 'programa': 'Programa', 'plan': 'Plan',
                              'eps': 'EPS', 'celular': 'Celular', 'email': 'Email', 'edad': 'Edad', 'llamada': 'Llamada',
                              'complementariedad': 'Complementariedad', 'alternativa': 'Alternativa', 'monto': 'Monto',
                              'regional': 'Regional'
                             };
                             const dateKeysInternal = new Set(['Fecha_Neg', 'Fecha_Complementariedad']);

                            const parseDateValue = (value) => {
                               if (value === null || value === undefined || String(value).trim() === '') return '';
                               if (typeof value === 'number') {
                                  try {
                                     const jsDate = XLSX.SSF.parse_date_code(value);
                                     if (jsDate && jsDate.y >= 1900) { // Basic year validation
                                        const month = String(jsDate.m).padStart(2, '0');
                                        const day = String(jsDate.d).padStart(2, '0');
                                        return `${jsDate.y}-${month}-${day}`;
                                     }
                                  } catch (dateError) { console.warn("Error parsing Excel date number:", value, dateError); }
                               } else if (typeof value === 'string') {
                                   if (/^\d{4}-\d{2}-\d{2}(T.*)?$/.test(value)) return value.substring(0, 10); // Handle YYYY-MM-DD and ISO strings
                                   try {
                                       const partsDMY = value.match(/(\d{1,2})[/-](\d{1,2})[/-](\d{4})/); // DD/MM/YYYY or DD-MM-YYYY
                                       if (partsDMY) {
                                           const year = parseInt(partsDMY[3], 10);
                                           const month = parseInt(partsDMY[2], 10);
                                           const day = parseInt(partsDMY[1], 10);
                                           if (year >= 1900 && month >= 1 && month <= 12 && day >= 1 && day <= 31) {
                                              return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                                           }
                                       }
                                       // Add MM/DD/YYYY parsing if needed
                                       // const partsMDY = value.match(/(\d{1,2})[/-](\d{1,2})[/-](\d{4})/); ...

                                       // Generic fallback (less reliable)
                                       const parsed = new Date(value);
                                       if (!isNaN(parsed) && parsed.getFullYear() >= 1900) {
                                           return parsed.toISOString().slice(0, 10);
                                       }
                                   } catch (parseError) { console.warn("Could not parse date string:", value, parseError); }
                               }
                               console.warn(`Returning original value for date column as string:`, value);
                               return String(value); // Fallback to string
                             };


                            return d.map(row => {
                                const newRow = {};
                                PORTAL_HEADERS.forEach(header => { newRow[header] = ''; }); // Initialize

                                for (const key in row) {
                                    const trimmedKeyLower = String(key).trim().toLowerCase();
                                    const internalKey = keyMap[trimmedKeyLower];
                                    if (internalKey) {
                                       const rawValue = row[key];
                                       newRow[internalKey] = dateKeysInternal.has(internalKey)
                                           ? parseDateValue(rawValue)
                                           : (rawValue !== null && rawValue !== undefined ? String(rawValue) : '');
                                    }
                                }
                                return newRow;
                            });
                        };

                        const normalizedData = normalizeHeadersAndData(jsonDataObjects, excelHeaders);
                        onDataChange(normalizedData);

                    } catch (error) {
                        console.error("Error processing Excel file:", error);
                        alert("Hubo un error al procesar el archivo Excel. Asegúrate de que el formato y las columnas son correctos.\nDetalle: " + error.message);
                        onDataChange([]); // Clear data on error
                    } finally {
                         if(e.target) e.target.value = null; // Reset file input regardless of outcome
                    }
                };
                reader.onerror = (error) => {
                     console.error("Error reading file:", error);
                     alert("Hubo un error al leer el archivo.");
                     onDataChange([]); // Clear data on error
                      if(e.target) e.target.value = null; // Reset file input
                };
                reader.readAsArrayBuffer(file);
            }, [onDataChange, headers]); // Include headers in dependencies

            const clearTable = useCallback(() => {
              // Ask for confirmation for file input type as it clears potentially loaded data
              if (inputType === 'file' && data.length > 0 && !data.every(row => !Object.values(row).some(v=>v))) {
                  if (!window.confirm("¿Estás seguro de que quieres limpiar los datos cargados del archivo?")) {
                      return;
                  }
              }
              onDataChange(inputType === 'paste' ? Array(5).fill({}) : []);
            }, [inputType, onDataChange, data]);

            // Ensure 'data' is always an array for rendering
            const renderData = useMemo(() => Array.isArray(data) ? data : (inputType === 'paste' ? Array(5).fill({}) : []), [data, inputType]);


            return (
              <section id={id} className="space-y-4">
                <h2 className="text-xl font-bold text-primary border-b border-border-color pb-2">{title}</h2>

                {inputType === 'file' && (
                   <div className="flex items-center gap-4">
                     <label htmlFor={`${id}-file-upload`} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-3 rounded-lg transition-colors cursor-pointer text-sm">
                         Subir Excel
                     </label>
                     <input
                         id={`${id}-file-upload`}
                         type="file"
                         className="hidden"
                         accept=".xlsx, .xls, .csv"
                         onChange={handleFileChange}
                     />
                     <span className="text-text-secondary text-sm">
                        {renderData.length > 0 && renderData.some(row => Object.values(row).some(v=>String(v).trim() !== ''))
                            ? `${renderData.filter(row => Object.values(row).some(v=>String(v).trim() !== '')).length} fila(s) cargada(s)`
                            : 'Ningún archivo seleccionado'}
                     </span>
                   </div>
                )}

                <div className="table-container max-h-60 overflow-auto border border-border-color rounded-lg bg-background/20"> {/* Adjusted max-h */}
                  <table className="w-full text-xs text-left text-text-secondary table-fixed"> {/* Smaller text, fixed layout */}
                    <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                      <tr>
                        {headers.map(header => (
                          <th key={header} scope="col" className="px-3 py-2 whitespace-nowrap overflow-hidden text-ellipsis w-32 font-semibold">{header.replace(/_/g, ' ')}</th> {/* Adjusted padding/width */}
                        ))}
                      </tr>
                    </thead>
                    <tbody onPaste={inputType === 'paste' ? handlePaste : undefined}>
                      {renderData.map((row, rowIndex) => (
                        <tr key={rowIndex} className="border-b border-border-color/50 hover:bg-highlight group">
                          {headers.map(header => (
                            <td
                              key={`${rowIndex}-${header}`}
                              className="px-3 py-1 border-r border-border-color/50 outline-none whitespace-nowrap overflow-hidden text-ellipsis w-32 focus-within:bg-primary/20 focus-within:text-white group-focus-within:whitespace-normal group-hover:whitespace-normal" // Adjusted styles
                              contentEditable={inputType === 'paste'}
                              onBlur={inputType === 'paste' ? (e) => handleCellChange(rowIndex, header, e.currentTarget.innerText) : undefined}
                              suppressContentEditableWarning={true}
                              // Use textContent directly for safety
                            >{(typeof row === 'object' && row !== null && row[header] !== undefined) ? String(row[header]) : ''}</td>
                          ))}
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
                <div className="flex gap-3">
                  <button
                      onClick={onProcess}
                      disabled={renderData.length === 0 || renderData.every(row => !row || !Object.values(row).some(val => String(val).trim() !== ''))}
                      className="bg-primary hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                   >
                    {processButtonText}
                  </button>
                  <button onClick={clearTable} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-3 rounded-lg transition-colors text-sm">
                    Limpiar Tabla
                  </button>
                </div>
              </section>
            );
        } // End of Memoized DataInputArea


        // =================================================================================
        // INLINED: components/ReviewArea.tsx - Already memoized
        // =================================================================================
        // ... (ReviewArea code remains the same as previous correct version) ...
        // Ensure the useMemo/useCallback dependencies are correct if modified
        const ReviewArea = React.memo(({
            data, templates, updateRow, incrementEdits, onSendToTracking, onPreview, onExportForMailMerge, onClearReviewData, sortConfig, setSortConfig,
           }) => {
            console.log("Rendering ReviewArea");
            const [selectedRows, setSelectedRows] = useState(new Set());
            const [filter, setFilter] = useState('');

            const REVIEW_HEADERS = useMemo(() => [
                { key: 'Fecha_Neg', label: 'Fecha Neg.', width: 'w-28' }, // Added width classes
                { key: 'No_Orden', label: 'No. Orden', width: 'w-28' },
                { key: 'No_Cedula', label: 'No. Cédula', width: 'w-32' },
                { key: 'Nombre', label: 'Nombre', width: 'w-48 flex-1 min-w-[12rem]' }, // Flexible Name
                { key: 'EPS', label: 'EPS', width: 'w-36' },
                { key: 'Programa', label: 'Programa', width: 'w-32', compact: true },
                { key: 'Motivo_Negacion', label: 'Motivo Neg.', width: 'w-48', compact: true },
                { key: 'Descripcion_PDF', label: 'Descripción', width: 'w-48', compact: true },
                { key: 'Justificacion_PDF', label: 'Justificación', width: 'w-48', compact: true },
                { key: 'Fundamento_Legal_PDF', label: 'Fund. Legal', width: 'w-40', compact: true },
            ], []);

            const currentData = useMemo(() => Array.isArray(data) ? data : [], [data]); // Memoize currentData

            const filteredData = useMemo(() => {
                if (!filter) return currentData;
                const lowercasedFilter = filter.toLowerCase();
                try {
                    // Basic filtering across all string values
                    return currentData.filter(row =>
                        row && typeof row === 'object' &&
                        Object.values(row).some(value =>
                            String(value).toLowerCase().includes(lowercasedFilter)
                        )
                    );
                } catch (e) {
                    console.error("Filtering error:", e);
                    return currentData; // Fallback on error
                }
            }, [currentData, filter]);

            useEffect(() => {
                const currentKeys = new Set(filteredData.map(r => r ? String(r.No_Orden) : null).filter(Boolean));
                setSelectedRows(prevSelected => {
                    const newSelection = new Set();
                    for (const key of prevSelected) {
                        if (currentKeys.has(key)) {
                            newSelection.add(key);
                        }
                    }
                    // Only update state if the selection actually changes
                    if (newSelection.size !== prevSelected.size || ![...newSelection].every(key => prevSelected.has(key))) {
                        return newSelection;
                    }
                    return prevSelected;
                });
            }, [filteredData]);


            const handleSelectRow = useCallback((noOrden) => {
              const key = String(noOrden);
              setSelectedRows(prevSelection => {
                 const newSelection = new Set(prevSelection);
                 if (newSelection.has(key)) newSelection.delete(key);
                 else newSelection.add(key);
                 return newSelection;
              });
            }, []);

            const handleSelectAll = useCallback((e) => {
              if (e.target.checked) {
                const allOrderNumbers = filteredData.map(row => row ? String(row.No_Orden) : null).filter(Boolean);
                setSelectedRows(new Set(allOrderNumbers));
              } else {
                setSelectedRows(new Set());
              }
            }, [filteredData]);

            const handleCellBlur = useCallback((noOrden, key, rawValue) => {
               // Trim whitespace from edited value
               const value = String(rawValue || '').trim();
               const originalRow = currentData.find(r => r && String(r.No_Orden) === String(noOrden));
               // Compare trimmed value with potentially untrimmed original, converting original to string safely
               if (originalRow && value !== String(originalRow[key] || '').trim()) {
                 console.log(`Cell Blur Update - Row: ${noOrden}, Key: ${key}, New Value: "${value}"`);
                 updateRow(noOrden, { [key]: value });
               }
            }, [currentData, updateRow]);


            const handleSelectChange = useCallback((noOrden, value) => {
              const changes = { Tipo_Carta: value };
              const safeTemplates = Array.isArray(templates) ? templates : [];
              const template = safeTemplates.find(t => t.id === value);
              // Find the original row to check its current Radicado_Comp value
              const originalRow = currentData.find(r => r && String(r.No_Orden) === String(noOrden));
              const currentRadicado = originalRow?.Radicado_Comp || '';

              // Reset Radicado_Comp only if changing *away* from a Complementariedad template or to no template
              if (!template || !template.name.toUpperCase().includes('COMPLEMENTARIEDAD')) {
                 // Only clear if it currently has a value, to avoid unnecessary updates/edits
                 if (currentRadicado !== '') {
                     changes.Radicado_Comp = '';
                 }
              }
              // Check if Tipo_Carta actually changed before updating
              if (originalRow && originalRow.Tipo_Carta !== value) {
                 updateRow(noOrden, changes);
              } else if (changes.Radicado_Comp === '' && currentRadicado !== '') {
                 // Handle case where only Radicado needs clearing because template changed away from Complementariedad
                 updateRow(noOrden, changes);
              }
            }, [templates, currentData, updateRow]);


            const requestSort = useCallback((key) => {
              setSortConfig(currentSortConfig => {
                  let direction = 'ascending';
                  if (currentSortConfig.key === key && currentSortConfig.direction === 'ascending') {
                    direction = 'descending';
                  }
                 return { key, direction };
              });
            }, [setSortConfig]);

            const getSortIndicator = useCallback((key) => {
              if (sortConfig.key !== key) return ' '; // Return space for alignment
              return sortConfig.direction === 'ascending' ? ' ▲' : ' ▼';
            }, [sortConfig]);

            const handleExport = useCallback(() => {
                onExportForMailMerge(currentData); // Export original unfiltered/unsorted data
            }, [onExportForMailMerge, currentData]);


            return (
              <section id="area3" className="space-y-4">
                <h2 className="text-xl font-bold text-primary border-b border-border-color pb-2">Área 3: Revisión Final y Exportación</h2>
                <div className="action-bar bg-highlight p-3 rounded-lg flex flex-wrap items-center gap-4 justify-between text-sm"> {/* Reduced padding */}
                  <input
                    type="text"
                    placeholder="Buscar en tabla de revisión..."
                    className="bg-surface border border-border-color rounded-md px-3 py-1 text-text-primary placeholder-text-secondary w-full sm:w-auto text-sm" // Reduced padding/size
                    value={filter}
                    onChange={(e) => setFilter(e.target.value)}
                    aria-label="Buscar en tabla de revisión"
                  />
                  <span className="text-text-primary whitespace-nowrap">{selectedRows.size} fila(s) seleccionada(s) / {currentData.length} total</span>
                </div>

                <div className="table-container max-h-[65vh] overflow-auto border border-border-color rounded-lg bg-background/20"> {/* Adjusted max height */}
                  <table className="w-full text-xs text-left text-text-secondary table-fixed border-collapse"> {/* Smaller text, fixed layout */}
                    <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                      <tr>
                        <th className={`px-2 py-2 ${REVIEW_HEADERS[0].width}`}> {/* Checkbox width */}
                            <input type="checkbox"
                                onChange={handleSelectAll}
                                checked={filteredData.length > 0 && selectedRows.size === filteredData.length}
                                disabled={filteredData.length === 0}
                                title={filteredData.length > 0 ? "Seleccionar/Deseleccionar Todo lo Visible" : "No hay filas para seleccionar"}
                                aria-label="Seleccionar todas las filas visibles"
                            />
                        </th>
                        <th className={`px-2 py-2 ${REVIEW_HEADERS[1].width}`}>👁️</th> {/* Preview width */}
                         {REVIEW_HEADERS.map(({ key, label, width }) => (
                           <th key={key} onClick={() => requestSort(key)} className={`px-2 py-2 cursor-pointer whitespace-nowrap overflow-hidden text-ellipsis ${width} font-semibold`} title={`Ordenar por ${label}`}>
                               {label}
                               <span className="ml-1">{getSortIndicator(key)}</span>
                           </th>
                         ))}
                        <th className="px-2 py-2 w-48 font-semibold">Tipo de Carta</th> {/* Width */}
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-border-color/30"> {/* Row dividers */}
                     {filteredData.length > 0 ? filteredData.map((row) => {
                        if (!row || typeof row !== 'object' || !row.No_Orden) {
                          return <tr key={`invalid-${Math.random()}`}><td colSpan={REVIEW_HEADERS.length + 3} className="text-center text-danger py-1">Fila inválida omitida</td></tr>;
                        }

                        const noOrdenKey = String(row.No_Orden);
                        const safeTemplates = Array.isArray(templates) ? templates : [];
                        const template = safeTemplates.find(t => t.id === row.Tipo_Carta);
                        const isComplementariedad = template && template.name.toUpperCase().includes('COMPLEMENTARIEDAD');
                        const requiresRadicado = isComplementariedad;
                        const isSelected = selectedRows.has(noOrdenKey);

                        return (
                          <tr key={noOrdenKey} className={`group ${isComplementariedad ? 'bg-indigo-900/10' : ''} ${isSelected ? 'bg-primary/20 hover:bg-primary/30' : 'hover:bg-highlight/50'}`}>
                            <td className="px-2 py-1 text-center"><input type="checkbox" checked={isSelected} onChange={() => handleSelectRow(noOrdenKey)} /></td>
                            <td className="px-2 py-1 text-base cursor-pointer text-center" onClick={() => onPreview(row)} title="Vista Previa Email">👁️</td>
                            {REVIEW_HEADERS.map(({ key, width, compact }) => (
                              <td key={key}
                                  className={`px-2 py-1 border-l border-border-color/30 outline-none whitespace-nowrap overflow-hidden text-ellipsis focus-within:bg-primary/20 focus-within:text-white group-hover:whitespace-normal group-focus-within:whitespace-normal ${width}`} // Apply width
                                  contentEditable
                                  onBlur={(e) => handleCellBlur(row.No_Orden, key, e.currentTarget.innerText)}
                                  suppressContentEditableWarning={true}
                                  title={String(row[key] ?? '')} // Show full text on hover
                              >
                                  {String(row[key] ?? '')}
                              </td>
                            ))}
                            <td className="px-2 py-1 w-48 border-l border-border-color/30"> {/* Apply width */}
                              <div className="flex flex-col gap-1">
                                <select
                                  value={row.Tipo_Carta || ''}
                                  onChange={(e) => handleSelectChange(row.No_Orden, e.target.value)}
                                  className="bg-surface border border-border-color rounded px-1 py-0.5 text-text-primary w-full text-xs" // Adjusted style
                                >
                                  <option value="">-- Seleccionar --</option>
                                  {safeTemplates.map(t => <option key={t.id} value={t.id} title={t.name}>{t.name}</option>)}
                                </select>
                                {requiresRadicado && (
                                  <input
                                    type="text"
                                    placeholder="Radicado Comp..."
                                    value={row.Radicado_Comp || ''}
                                    onChange={(e) => updateRow(row.No_Orden, { Radicado_Comp: e.target.value.trim() })} // Trim input
                                    className="bg-surface border border-border-color rounded px-1 py-0.5 text-text-primary w-full mt-1 text-xs" // Adjusted style
                                  />
                                )}
                              </div>
                            </td>
                          </tr>
                        );
                      }) : (
                          <tr><td colSpan={REVIEW_HEADERS.length + 3} className="text-center py-4 text-text-secondary italic">No hay casos en revisión{filter ? ' que coincidan con la búsqueda.' : '.'}</td></tr>
                       )}
                    </tbody>
                  </table>
                </div>
                <div className="flex flex-wrap gap-3 text-sm"> {/* Reduced gap */}
                  <button
                      onClick={() => onSendToTracking(Array.from(selectedRows))}
                      disabled={selectedRows.size === 0}
                      className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed" // Adjusted padding
                  >
                    Enviar a Seguimiento ({selectedRows.size})
                  </button>
                   <button
                      onClick={handleExport}
                      disabled={currentData.length === 0}
                      className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed" // Adjusted padding
                   >
                     Exportar p/ Mail ({currentData.length})
                   </button>
                  <button
                      onClick={onClearReviewData}
                      className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-3 rounded-lg transition-colors" // Adjusted padding
                  >
                    Limpiar Tabla Revisión
                  </button>
                </div>
              </section>
            );
        }); // End of Memoized ReviewArea


        // =================================================================================
        // INLINED: components/TrackingArea.tsx - Already memoized
        // =================================================================================
        // ... (TrackingArea and TrackingTable code remains the same as previous correct version) ...
        // Ensure the useCallback dependencies are correct if modified
        const TrackingTable = React.memo(({ data, isArchived, onUpdate, onArchive, filter }) => {
            console.log(`Rendering TrackingTable (Archived: ${isArchived})`);

            const [selectedRows, setSelectedRows] = useState(new Set());

            const statusClasses = useMemo(() => ({
                'Pendiente': 'bg-yellow-900/30', // Darker background for better contrast
                'En Gestión': 'bg-blue-900/30',
                'Finalizado': 'bg-green-900/30',
            }), []);

            const currentData = useMemo(() => Array.isArray(data) ? data : [], [data]);

            const filteredData = useMemo(() => {
                if (!filter) return currentData;
                const lowercasedFilter = filter.toLowerCase();
                try {
                    return currentData.filter(row =>
                        row && typeof row === 'object' &&
                        Object.values(row).some(value => String(value).toLowerCase().includes(lowercasedFilter))
                    );
                } catch (e) {
                    console.error("Filtering error in TrackingTable:", e);
                    return currentData;
                }
            }, [currentData, filter]);

             useEffect(() => {
                 const currentIndices = new Set(filteredData.map(r => currentData.indexOf(r)).filter(i => i !== -1));
                 setSelectedRows(prevSelected => {
                     const newSelection = new Set();
                     for (const index of prevSelected) {
                         if (currentIndices.has(index)) newSelection.add(index);
                     }
                     if (newSelection.size !== prevSelected.size || ![...newSelection].every(key => prevSelected.has(key))) {
                        return newSelection;
                     }
                     return prevSelected; // No change needed
                 });
             }, [filteredData, currentData]);


            const handleSelectRow = useCallback((index) => {
              setSelectedRows(prevSelection => {
                 const newSelection = new Set(prevSelection);
                 if (newSelection.has(index)) newSelection.delete(index);
                 else newSelection.add(index);
                 return newSelection;
              });
            }, []);

            const handleSelectAll = useCallback((e) => {
              if (e.target.checked) {
                const allVisibleIndices = filteredData.map((row) => currentData.indexOf(row)).filter(index => index !== -1);
                setSelectedRows(new Set(allVisibleIndices));
              } else {
                setSelectedRows(new Set());
              }
            }, [filteredData, currentData]);

            const handleBulkArchive = useCallback(() => {
              if (selectedRows.size > 0) {
                onArchive(Array.from(selectedRows));
                setSelectedRows(new Set());
              }
            }, [selectedRows, onArchive]);

            const handleCellUpdate = useCallback((originalIndex, field, value) => {
                 const row = currentData[originalIndex];
                 // Trim notes specifically
                 const processedValue = field === 'Notas' ? String(value || '').trim() : value;
                 if (row && String(row[field] || '') !== processedValue) {
                    onUpdate(originalIndex, { ...row, [field]: processedValue }, isArchived); // Pass isArchived flag
                 }
             }, [currentData, onUpdate, isArchived]);


            return (
              <div className="space-y-3"> {/* Reduced spacing */}
                <div className="flex justify-between items-center text-sm">
                     <span className="text-text-secondary">
                         {filteredData.length} fila(s) mostrada(s)
                         {selectedRows.size > 0 ? `, ${selectedRows.size} seleccionada(s)` : ''}
                     </span>
                     {selectedRows.size > 0 && (
                         <button
                             onClick={handleBulkArchive}
                             className={`font-bold py-1 px-3 rounded transition-colors text-white text-xs ${isArchived ? 'bg-green-600 hover:bg-green-700' : 'bg-gray-600 hover:bg-gray-700'}`} // Adjusted style
                         >
                             {isArchived ? `♻️ Restaurar (${selectedRows.size})` : `🗄️ Archivar (${selectedRows.size})`}
                         </button>
                     )}
                </div>
                <div className="table-container max-h-[40vh] overflow-auto border border-border-color rounded-lg bg-background/20">
                  <table className="w-full text-xs text-left text-text-secondary table-fixed border-collapse"> {/* Smaller text */}
                    <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                      <tr>
                        <th className="px-2 py-2 w-8"><input type="checkbox" onChange={handleSelectAll} checked={filteredData.length > 0 && selectedRows.size === filteredData.length} disabled={filteredData.length === 0} title="Seleccionar/Deseleccionar Todo lo Visible" /></th>
                        <th className="px-2 py-2 w-24 font-semibold">Fecha Ing.</th>
                        <th className="px-2 py-2 w-24 font-semibold">No. Orden</th>
                        <th className="px-2 py-2 w-40 font-semibold">Nombre</th>
                        <th className="px-2 py-2 w-28 font-semibold">EPS</th>
                        <th className="px-2 py-2 w-28 font-semibold">Radicado</th>
                        <th className="px-2 py-2 w-28 font-semibold">Estado</th>
                        <th className="px-2 py-2 flex-1 min-w-[150px] font-semibold">Notas</th>
                        <th className="px-2 py-2 w-12 font-semibold">Acción</th>
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-border-color/30">
                     {filteredData.length > 0 ? filteredData.map((row) => {
                         const originalIndex = currentData.indexOf(row);
                         if (!row || typeof row !== 'object' || originalIndex === -1) return null; // Should not happen

                         const isSelected = selectedRows.has(originalIndex);
                         const rowClasses = `group ${isArchived ? 'bg-black/10 text-text-secondary italic' : statusClasses[row.Estado] || ''} ${isSelected ? '!bg-primary/30 hover:!bg-primary/40' : 'hover:bg-highlight/50'}`; // Use !important for selection

                        return (
                          <tr key={originalIndex} className={rowClasses}>
                            <td className="px-2 py-1 text-center"><input type="checkbox" checked={isSelected} onChange={() => handleSelectRow(originalIndex)} /></td>
                            <td className="px-2 py-1 w-24 whitespace-nowrap">{row.Fecha_Ing || ''}</td>
                            <td className="px-2 py-1 w-24 whitespace-nowrap">{row.No_Orden || ''}</td>
                            <td className="px-2 py-1 w-40 whitespace-nowrap overflow-hidden text-ellipsis" title={row.Nombre}>{row.Nombre || ''}</td>
                            <td className="px-2 py-1 w-28 whitespace-nowrap overflow-hidden text-ellipsis" title={row.EPS}>{row.EPS || ''}</td>
                            <td className="px-2 py-1 w-28 whitespace-nowrap overflow-hidden text-ellipsis" title={row.Radicado}>{row.Radicado || ''}</td>
                            <td className="px-2 py-1 w-28">
                              <select
                                value={row.Estado || TRACKING_STATUSES[0]}
                                onChange={e => handleCellUpdate(originalIndex, 'Estado', e.target.value)}
                                className={`bg-surface/50 border border-border-color/50 rounded px-1 py-0.5 w-full text-xs ${isArchived ? 'text-gray-400' : 'text-text-primary'}`}
                                disabled={isArchived}
                              >
                                {TRACKING_STATUSES.map(s => <option key={s} value={s}>{s}</option>)}
                              </select>
                            </td>
                            <td
                                className={`px-2 py-1 outline-none min-w-[150px] focus-within:bg-primary/20 focus-within:text-white group-hover:whitespace-normal group-focus-within:whitespace-normal ${isArchived ? '' : 'hover:bg-black/20'}`} // Allow wrap on hover/focus only if not archived
                                contentEditable={!isArchived}
                                onBlur={e => handleCellUpdate(originalIndex, 'Notas', e.currentTarget.innerText)}
                                suppressContentEditableWarning={true}
                                title={row.Notas} // Show full notes on hover
                             >
                                  {row.Notas || ''}
                             </td>
                            <td className="px-2 py-1 text-base cursor-pointer w-12 text-center" onClick={() => onArchive([originalIndex])} title={isArchived ? 'Restaurar' : 'Archivar'}>{isArchived ? '♻️' : '🗄️'}</td>
                          </tr>
                        );
                      }) : (
                          <tr><td colSpan={9} className="text-center py-4 text-text-secondary italic">
                              {isArchived ? 'No hay casos archivados' : 'No hay casos activos'} {filter ? ' que coincidan con la búsqueda.' : '.'}
                          </td></tr>
                       )}
                    </tbody>
                  </table>
                </div>
              </div>
            );
        }); // End of Memoized TrackingTable

        const TrackingArea = React.memo(({ trackingData, archivedData, updateTrackingData, archiveItems }) => {
          console.log("Rendering TrackingArea");
          const [showArchived, setShowArchived] = useState(false);
          const [filter, setFilter] = useState('');
          const currentTrackingData = useMemo(() => Array.isArray(trackingData) ? trackingData : [], [trackingData]);
          const currentArchivedData = useMemo(() => Array.isArray(archivedData) ? archivedData : [], [archivedData]);

          return (
            <section id="area4" className="space-y-4">
              <h2 className="text-xl font-bold text-primary border-b border-border-color pb-2">Área 4: Seguimiento</h2>
              <div className="action-bar bg-highlight p-3 rounded-lg flex flex-wrap items-center gap-4 justify-between text-sm"> {/* Reduced padding */}
                <input
                  type="text"
                  placeholder="Buscar en Seguimiento..."
                  className="bg-surface border border-border-color rounded-md px-3 py-1 text-text-primary placeholder-text-secondary w-full sm:w-1/2 lg:w-1/3 text-sm" // Adjusted style
                  value={filter}
                  onChange={e => setFilter(e.target.value)}
                  aria-label="Buscar en seguimiento activo y archivado"
                />
                <button onClick={() => setShowArchived(!showArchived)} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-3 rounded-lg text-xs sm:text-sm"> {/* Adjusted style */}
                  {showArchived ? 'Ocultar' : 'Mostrar'} Archivados ({currentArchivedData.length})
                </button>
              </div>

              <h3 className="text-lg font-semibold text-white">Casos Activos ({currentTrackingData.length})</h3>
              <TrackingTable
                data={currentTrackingData}
                isArchived={false}
                onUpdate={updateTrackingData}
                onArchive={archiveItems}
                filter={filter}
              />

              {showArchived && (
                <div className="mt-6"> {/* Reduced margin */}
                  <h3 className="text-lg font-semibold text-text-secondary">Casos Archivados ({currentArchivedData.length})</h3>
                  <TrackingTable
                    data={currentArchivedData}
                    isArchived={true}
                    onUpdate={updateTrackingData} // Should not be called if disabled, but passed for consistency
                    onArchive={archiveItems}
                    filter={filter}
                  />
                </div>
              )}
            </section>
          );
        }); // End of Memoized TrackingArea

        // =================================================================================
        // INLINED: components/SetupModal.tsx - No changes needed
        // =================================================================================
        // ... (SetupModal code remains the same as previous correct version) ...
         const SetupModal = ({ onSave, onClose, initialUrl = '' }) => {
            const [url, setUrl] = useState(initialUrl);
            const [isVerifying, setIsVerifying] = useState(false);
            const [errorMsg, setErrorMsg] = useState(''); // State for error message

            const handleSave = async () => {
              setErrorMsg(''); // Clear previous errors
              if (!url || !url.startsWith('https://script.google.com/macros/s/')) {
                setErrorMsg("Por favor, introduce una URL válida de Google Apps Script (debe empezar con https://script.google.com/macros/s/).");
                return;
              }
              setIsVerifying(true);
              try {
                  // onSave should throw an error if verification fails
                  await onSave(url);
                  // No need to explicitly close here, parent component handles it on success via state update
              } catch (error) {
                   console.error("Verification failed:", error);
                   // Display a user-friendly error message from the caught error
                   setErrorMsg(`Falló la verificación: ${error.message}. Revisa la URL y los permisos.`);
              } finally {
                  setIsVerifying(false); // Ensure verifying state is reset even if error occurs
              }
            };

            return (
              <div className="fixed inset-0 bg-background bg-opacity-90 flex justify-center items-center z-[200] p-4"> {/* Increased z-index */}
                <div className="bg-surface rounded-lg shadow-xl w-full max-w-lg border border-border-color p-8 space-y-6">
                  <div className="text-center">
                    <h2 className="text-2xl font-bold text-primary">Configuración de Conexión</h2>
                    <p className="text-text-secondary mt-2">
                        Proporciona la URL de Google Apps Script implementada como aplicación web.
                    </p>
                  </div>
                  <div>
                    <label htmlFor="script-url" className="block text-sm font-medium text-text-primary mb-1">
                        URL del Script
                    </label>
                    <input
                        id="script-url"
                        type="url"
                        value={url}
                        onChange={(e) => { setUrl(e.target.value); setErrorMsg(''); }} // Clear error on change
                        placeholder="https://script.google.com/macros/s/..."
                        className={`w-full bg-background border rounded-md px-3 py-2 text-text-primary placeholder-text-secondary focus:ring-primary focus:border-primary ${errorMsg ? 'border-danger' : 'border-border-color'}`} // Highlight on error
                        aria-invalid={!!errorMsg}
                        aria-describedby="url-error"
                    />
                    {errorMsg && <p id="url-error" className="text-danger text-sm mt-1">{errorMsg}</p>}
                  </div>
                  <div className="flex justify-end gap-4">
                    <button
                        onClick={onClose} // Let parent handle close logic
                        disabled={isVerifying}
                        className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                        Cancelar
                    </button>
                    <button
                        onClick={handleSave}
                        disabled={isVerifying || !url}
                        className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed min-w-[150px] flex justify-center items-center" // Ensure button size stays consistent
                    >
                        {isVerifying ? <Spinner /> : 'Guardar y Verificar'}
                    </button>
                  </div>
                </div>
              </div>
            );
         };

        // =================================================================================
        // INLINED: components/TemplateManagerModal.tsx - No changes needed
        // =================================================================================
        // ... (TemplateManagerModal code remains the same as previous correct version) ...
          const TemplateManagerModal = ({ templates, onClose, onSave, onReset }) => {
            const [currentTemplates, setCurrentTemplates] = useState(() => structuredClone(Array.isArray(templates) ? templates : [])); // Deep clone initial templates
            const [editingTemplate, setEditingTemplate] = useState(null); // Holds the template being edited/created

            const handleSaveLocal = useCallback(() => {
              // Add validation before saving if needed
              onSave(currentTemplates); // Pass the current state up
            }, [currentTemplates, onSave]);

            const handleAddNew = useCallback(() => {
              // Create a truly new ID for the new template
              setEditingTemplate({ id: `custom_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`, name: '', body: '' });
            }, []);

            const handleEdit = useCallback((template) => {
               // Create a copy for editing to avoid modifying the list directly
               setEditingTemplate({ ...template });
            }, []);

            const handleDelete = useCallback((idToDelete) => {
              if (window.confirm('¿Estás seguro de que quieres eliminar esta plantilla? Esta acción no se puede deshacer.')) {
                setCurrentTemplates(current => current.filter(t => t.id !== idToDelete)); // Use functional update
              }
            }, []);

            const handleSaveTemplateEdit = useCallback(() => {
              if (!editingTemplate || !editingTemplate.name.trim() || !editingTemplate.body.trim()) {
                alert('El nombre y el cuerpo de la plantilla no pueden estar vacíos.');
                return;
              }

              setCurrentTemplates(current => {
                  const updatedTemplates = Array.isArray(current) ? [...current] : []; // Ensure it's an array
                  const existingIndex = updatedTemplates.findIndex(t => t.id === editingTemplate.id);
                  if (existingIndex > -1) {
                      // Update existing
                      updatedTemplates[existingIndex] = { ...editingTemplate }; // Ensure it's a new object
                  } else {
                      // Add new
                      updatedTemplates.push({ ...editingTemplate }); // Ensure it's a new object
                  }
                  return updatedTemplates;
              });
              setEditingTemplate(null); // Close editor
            }, [editingTemplate]); // Depends on the template being edited


             // Handler for input changes within the editor
             const handleEditorChange = useCallback((field, value) => {
                  setEditingTemplate(prev => prev ? ({ ...prev, [field]: value }) : null);
             }, []);


            return (
              <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[250] p-4"> {/* Increased z-index */}
                <div className="bg-surface rounded-lg shadow-xl w-full max-w-4xl border border-border-color flex flex-col max-h-[90vh]">
                  <div className="p-6 border-b border-border-color flex justify-between items-center flex-shrink-0"> {/* Header */}
                    <h3 className="text-xl font-bold text-primary">Gestionar Plantillas de Correo</h3>
                    <button onClick={onClose} className="text-text-secondary text-2xl hover:text-text-primary">&times;</button>
                  </div>

                  <div className="p-6 overflow-y-auto space-y-6 flex-grow"> {/* Content Area */}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 h-full"> {/* Layout */}

                      {/* Left Side: List of Templates */}
                      <div className="flex flex-col h-full">
                        <div className="flex justify-between items-center mb-2">
                           <h4 className="text-lg font-semibold">Plantillas Actuales</h4>
                           <button onClick={handleAddNew} className="bg-green-600 hover:bg-green-700 text-white text-xs font-bold py-1 px-2 rounded disabled:opacity-50" disabled={!!editingTemplate}>
                             + Nueva
                           </button>
                        </div>
                        <ul className="space-y-1 border border-border-color rounded-lg p-2 overflow-y-auto flex-grow bg-background/30"> {/* Reduced space */}
                          {currentTemplates.map(template => (
                            <li key={template.id} className={`flex justify-between items-center p-2 rounded transition-colors text-sm ${editingTemplate?.id === template.id ? 'bg-primary/30 ring-1 ring-primary' : 'bg-highlight hover:bg-highlight/70'}`}>
                              <span className="text-text-primary truncate flex-grow mr-2" title={template.name}>{template.name}</span>
                              <div className="space-x-1 flex-shrink-0"> {/* Reduced space */}
                                <button onClick={() => handleEdit(template)} className="text-xs bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded disabled:opacity-50" disabled={!!editingTemplate}>Editar</button>
                                <button onClick={() => handleDelete(template.id)} className="text-xs bg-danger hover:bg-danger-hover px-2 py-1 rounded disabled:opacity-50" disabled={!!editingTemplate}>Borrar</button>
                              </div>
                            </li>
                          ))}
                           {currentTemplates.length === 0 && <li className="text-text-secondary text-center p-4 italic">No hay plantillas guardadas.</li>}
                        </ul>
                      </div>

                      {/* Right Side: Editor/Placeholder */}
                      <div className="flex flex-col h-full">
                         <h4 className="text-lg font-semibold mb-2">
                            {editingTemplate ? (currentTemplates.some(t => t.id === editingTemplate.id) ? 'Editar Plantilla' : 'Nueva Plantilla') : 'Editor de Plantilla'}
                         </h4>
                         {editingTemplate ? (
                             <div className="space-y-3 p-4 border border-border-color rounded-lg bg-highlight flex flex-col flex-grow">
                               <input
                                 type="text"
                                 placeholder="Nombre de la Plantilla"
                                 value={editingTemplate.name}
                                 onChange={(e) => handleEditorChange('name', e.target.value)}
                                 className="w-full bg-background border border-border-color rounded-md px-3 py-2 text-sm flex-shrink-0"
                               />
                               <textarea
                                 placeholder="Cuerpo de la Plantilla (HTML permitido)..."
                                 value={editingTemplate.body}
                                 onChange={(e) => handleEditorChange('body', e.target.value)}
                                 className="w-full bg-background border border-border-color rounded-md px-3 py-2 resize-y flex-grow text-sm min-h-[200px]" // Ensure minimum height
                               />
                                <p className="text-xs text-text-secondary flex-shrink-0">Marcadores disponibles: {`{{Columna}}`} (ej: {`{{Nombre}}`}, {`{{No_Orden}}`}, {`{{EPS}}`}, {`{{Oficina_Virtual_EPS}}`}, etc.)</p>
                               <div className="flex gap-2 flex-shrink-0 justify-end">
                                 <button onClick={() => setEditingTemplate(null)} className="bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded text-sm">Cancelar</button>
                                 <button onClick={handleSaveTemplateEdit} className="bg-success hover:bg-green-700 px-3 py-1 rounded text-sm">Guardar Cambios</button>
                               </div>
                             </div>
                           ) : (
                             <div className="flex items-center justify-center h-full border border-dashed border-border-color rounded-lg bg-background/30 text-text-secondary italic p-4 text-center">
                                Selecciona una plantilla de la lista para editarla,<br /> o haz clic en "+ Nueva" para crear una.
                             </div>
                           )}
                      </div>

                    </div>
                  </div>

                  <div className="p-4 bg-header flex justify-between items-center rounded-b-lg flex-shrink-0"> {/* Footer */}
                     <button onClick={onReset} className="bg-danger hover:bg-danger-hover text-white font-bold py-2 px-4 rounded-lg text-sm disabled:opacity-50" disabled={!!editingTemplate}>
                      Restaurar Predeterminadas
                    </button>
                    <div className="flex gap-4">
                      <button onClick={onClose} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg text-sm" disabled={!!editingTemplate}>
                          Cancelar
                      </button>
                      <button onClick={handleSaveLocal} className="bg-success hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg text-sm" disabled={!!editingTemplate}>
                          Guardar y Cerrar
                      </button>
                    </div>
                  </div>
                </div>
              </div>
          );
         };

        // =================================================================================
        // INLINED: components/PreviewModal.tsx - No changes needed
        // =================================================================================
        // ... (PreviewModal code remains the same as previous correct version) ...
          const PreviewModal = ({ data, template, onClose }) => {
            if (!data || typeof data !== 'object') {
               console.error("Invalid data provided to PreviewModal:", data);
               return (
                    <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[250] p-4">
                       <div className="bg-surface rounded-lg shadow-xl w-full max-w-lg border border-border-color p-8 text-center">
                           <h3 className="text-xl font-bold text-danger mb-4">Error</h3>
                           <p className="text-text-secondary mb-6">No se pudieron cargar los datos para la vista previa.</p>
                           <button onClick={onClose} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Cerrar</button>
                       </div>
                    </div>
               );
            }

            const bodyContent = template && template.body ? replacePlaceholders(template.body, data) : '<p class="italic text-gray-500">[Selecciona un tipo de carta en el Área 3 para ver la vista previa aquí]</p>';
            const fullBody = `<div style="font-family: Arial, sans-serif; font-size: 14px; color: #333; line-height: 1.6;">${bodyContent}${COMMON_EMAIL_BODY}${SIGNATURE}</div>`; // Wrap in basic styles


            const copyToClipboard = useCallback(() => {
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = fullBody;
              const textContent = tempDiv.textContent || tempDiv.innerText || "";
              navigator.clipboard.writeText(textContent.trim())
                .then(() => alert('¡Contenido de texto copiado al portapapeles!'))
                .catch(err => { console.error('Failed to copy text content:', err); alert('Falló al copiar el contenido de texto.'); });
            }, [fullBody]);


            const copyHtmlToClipboard = useCallback(() => {
                 try {
                    if (navigator.clipboard && window.ClipboardItem) {
                        const type = "text/html";
                        const blob = new Blob([fullBody], { type });
                        const data = [new ClipboardItem({ [type]: blob })];
                        navigator.clipboard.write(data)
                           .then(() => alert('¡Contenido HTML copiado al portapapeles!'))
                           .catch(err => { console.error('Failed to copy HTML using ClipboardItem:', err); alert('Falló al copiar el contenido HTML (tu navegador podría no soportarlo). Intenta copiar el texto.'); });
                    } else {
                         console.warn("ClipboardItem API not supported, attempting fallback text copy.");
                         copyToClipboard();
                         alert("Se copió el texto, pero el formato HTML puede no ser compatible con tu navegador.");
                    }
                 } catch (error) {
                     console.error('Error copying HTML:', error);
                     alert('Error inesperado al intentar copiar HTML.');
                 }
              }, [fullBody, copyToClipboard]);


            return (
              <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[250] p-4"> {/* Higher z-index */}
                <div className="bg-white rounded-lg shadow-xl w-full max-w-3xl border border-gray-300 flex flex-col max-h-[90vh]"> {/* White background for preview */}
                  <div className="p-4 border-b border-gray-300 flex justify-between items-center flex-shrink-0 bg-gray-100 rounded-t-lg"> {/* Header */}
                    <h3 className="text-lg font-bold text-gray-800 truncate">Vista Previa: Orden {data.No_Orden || 'N/A'}</h3>
                     <button onClick={onClose} className="text-gray-500 hover:text-gray-800 text-2xl ml-4">&times;</button>
                  </div>
                  <iframe
                    // srcDoc={`<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{margin: 1rem;}</style></head><body>${fullBody}</body></html>`}
                    srcDoc={fullBody} // Let the div styling handle it mostly
                    className="flex-grow overflow-y-auto border-none w-full bg-white p-4" // Added padding inside iframe
                    sandbox="allow-same-origin"
                    title={`Vista Previa Email Orden ${data.No_Orden || 'N/A'}`}
                  />
                  <div className="p-4 bg-gray-100 flex justify-end gap-3 rounded-b-lg flex-shrink-0 border-t border-gray-300"> {/* Footer */}
                     <button onClick={copyHtmlToClipboard} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-lg transition-colors text-sm" title="Copiar como HTML formateado">
                       Copiar HTML
                     </button>
                    <button onClick={copyToClipboard} className="bg-blue-800 hover:bg-blue-900 text-white font-bold py-2 px-3 rounded-lg transition-colors text-sm" title="Copiar solo el texto">
                      Copiar Texto
                    </button>
                    <button onClick={onClose} className="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-3 rounded-lg transition-colors text-sm">
                      Cerrar
                    </button>
                  </div>
                </div>
              </div>
            );
          };

        // =================================================================================
        // INLINED: App.tsx (The main application component)
        // =================================================================================
        const App = () => {
          console.log("Rendering App"); // Debug: Check if App renders multiple times unexpectedly
          const [state, setState] = useState({
            finalData: [],
            trackingData: [],
            archivedData: [],
            portalData: [],
            pdfData: Array(5).fill({}),
            templates: [],
            scriptUrl: null,
            isSetupNeeded: false,
            isReconfiguring: false,
            isLoading: true,
            isSaving: false,
            isTemplateManagerOpen: false,
            previewData: null,
            notification: null,
            editsCount: 0,
            onlineStatus: true,
            masterTrackingOrders: new Set(),
          });

          const [sortConfig, setSortConfig] = useState({
            key: 'Fecha_Neg', // Default sort by date
            direction: 'descending', // Show newest first
          });

          // --- Notification Management (useRef for timeout ID) ---
          const notificationTimeoutIdRef = useRef(null);
          const hideNotification = useCallback(() => {
              if (notificationTimeoutIdRef.current) {
                  clearTimeout(notificationTimeoutIdRef.current);
                  notificationTimeoutIdRef.current = null;
              }
              setState(prev => ({ ...prev, notification: null }));
          }, []);

          const showNotification = useCallback((message, type = 'info', duration = 5000) => {
             // Clear existing timeout before setting a new one
             if (notificationTimeoutIdRef.current) {
                  clearTimeout(notificationTimeoutIdRef.current);
             }
             // Set the new notification state
             setState(prev => ({ ...prev, notification: { message, type } }));
             // Set new timeout and store its ID
             notificationTimeoutIdRef.current = setTimeout(hideNotification, duration);
          }, [hideNotification]);


          // --- Script URL and Initial Data Loading ---
          const handleSetScriptUrl = useCallback(async (url) => {
              console.log("Attempting to set script URL and fetch initial data...");
             setState(prev => ({ ...prev, isLoading: true, isReconfiguring: false }));
             try {
               const data = await fetchData(url);
               localStorage.setItem('sigweb_scriptUrl', url);
               setState(prev => ({
                 ...prev,
                 finalData: data.finalData,
                 trackingData: data.trackingData,
                 archivedData: data.archivedData,
                 masterTrackingOrders: new Set(data.masterTrackingOrders.map(String)),
                 scriptUrl: url,
                 isSetupNeeded: false,
                 isLoading: false,
                 editsCount: 0, // Reset edits on successful load/reload
               }));
               showNotification('¡Conexión exitosa y datos cargados!', 'success');
               console.log("Initial data fetched successfully.");
             } catch (error) {
               console.error("Error setting script URL or fetching data:", error);
               showNotification(
                 `Falló la conexión: ${error.message}. Revisa la URL y permisos del script.`, 'error', 15000 // Show error much longer
               );
               setState(prev => ({ ...prev, isLoading: false, isSetupNeeded: true, scriptUrl: null }));
               localStorage.removeItem('sigweb_scriptUrl');
               throw error; // Re-throw for SetupModal error handling
             }
          }, [showNotification]); // showNotification is stable


          // --- Effect for Initial Load and Online Status ---
          useEffect(() => {
              console.log("App component mounted. Checking config...");
            const url = localStorage.getItem('sigweb_scriptUrl');
            const loadedTemplates = loadTemplates();
            setState(prev => ({ ...prev, templates: loadedTemplates }));

            if (url) {
                console.log("Found script URL:", url);
                handleSetScriptUrl(url).catch(err => {
                    console.error("Initial data load failed on mount:", err);
                    // State should reflect setup needed due to error in handleSetScriptUrl
                });
            } else {
                console.log("No script URL found. Setup needed.");
                setState(prev => ({ ...prev, isSetupNeeded: true, isLoading: false }));
            }

            // Online/Offline handling
            const updateOnlineStatus = () => {
                const isOnline = navigator.onLine;
                 setState(prev => {
                     if (prev.onlineStatus === isOnline) return prev; // No change
                     console.log("Network status changed:", isOnline ? "Online" : "Offline");
                     if (!isOnline) {
                        showNotification("Estás desconectado. El guardado en la nube está deshabilitado.", "warning", 10000);
                     } else if (prev.onlineStatus === false && isOnline){
                         showNotification("Estás conectado de nuevo.", "success", 3000); // Shorter success message
                     }
                     return { ...prev, onlineStatus: isOnline };
                });
            };

            window.addEventListener('online', updateOnlineStatus);
            window.addEventListener('offline', updateOnlineStatus);
            updateOnlineStatus(); // Initial check

            return () => { // Cleanup
                console.log("App component unmounting. Removing listeners.");
                window.removeEventListener('online', updateOnlineStatus);
                window.removeEventListener('offline', updateOnlineStatus);
                if (notificationTimeoutIdRef.current) { // Clear notification timeout on unmount
                   clearTimeout(notificationTimeoutIdRef.current);
                }
            };
            // Only run on mount. handleSetScriptUrl is stable due to useCallback.
          }, [handleSetScriptUrl, showNotification]); // Added showNotification


          // --- Edit Counter ---
          const incrementEdits = useCallback((count = 1) => { // Allow incrementing by more than 1 if needed
            console.log(`Incrementing edits count by ${count}`);
            setState(prev => ({ ...prev, editsCount: prev.editsCount + count }));
          },[]);


          // --- Save Data ---
          const handleSave = useCallback(async () => {
              // ... (handleSave logic remains the same as the previous correct version) ...
               console.log("Save button clicked.");
               if (!state.scriptUrl) {
                   showNotification('No se puede guardar. La URL del script no está configurada.', 'error');
                   return;
               }
               if (!state.onlineStatus) {
                   showNotification('No se puede guardar mientras estás desconectado.', 'error');
                   return;
               }

               const safeFinalData = Array.isArray(state.finalData) ? state.finalData : [];
               const safeTrackingData = Array.isArray(state.trackingData) ? state.trackingData : [];
               const safeArchivedData = Array.isArray(state.archivedData) ? state.archivedData : [];

               if (safeFinalData.length === 0 && state.editsCount === 0) {
                    showNotification('No hay datos nuevos o modificados para guardar.', 'info');
                    return;
               }

               setState(prev => ({ ...prev, isSaving: true }));
               console.log("Attempting to save data...");

               try {
                   const payload = {
                       action: 'saveData',
                       payload: {
                           finalData: safeFinalData,
                           trackingData: safeTrackingData,
                           archivedData: safeArchivedData,
                       }
                   };
                   await saveData(state.scriptUrl, payload);

                   const newOrders = new Set(state.masterTrackingOrders);
                   [...safeFinalData, ...safeTrackingData, ...safeArchivedData].forEach(row => {
                       if (row && row.No_Orden) {
                           newOrders.add(String(row.No_Orden).trim());
                       }
                   });

                   showNotification('Datos enviados a la nube (respuesta no verificada).', 'success'); // Adjusted message for no-cors
                   console.log("Save request sent successfully. Updated masterTrackingOrders locally.");

                   setState(prev => ({
                       ...prev,
                       editsCount: 0,
                       masterTrackingOrders: newOrders,
                       finalData: [] // Clear review area
                   }));
               } catch (error) {
                   console.error("Error during save:", error);
                   showNotification(`Falló el guardado: ${error.message}`, 'error', 10000); // Show error longer
               } finally {
                   setState(prev => ({ ...prev, isSaving: false }));
                   console.log("Save process finished.");
               }
          }, [state.scriptUrl, state.onlineStatus, state.finalData, state.trackingData, state.archivedData, state.masterTrackingOrders, state.editsCount, showNotification]);


          // --- Process Area 1 Data (Excel Upload) ---
          const processPortalData = useCallback(() => {
              // ... (processPortalData logic remains the same as previous correct version) ...
                console.log("Processing portal data...");
                const currentPortalData = Array.isArray(state.portalData) ? state.portalData.filter(row => row && Object.values(row).some(val => String(val).trim() !== '')) : [];

                if (currentPortalData.length === 0) {
                     showNotification("No hay datos válidos cargados desde el archivo para procesar.", "warning");
                     setState(prev => ({ ...prev, portalData: [] }));
                     return;
                }

                const newRows = currentPortalData.filter(row => {
                     const orderKey = row && row.No_Orden ? String(row.No_Orden).trim() : null;
                     return orderKey && !state.masterTrackingOrders.has(orderKey);
                });

                const duplicates = currentPortalData.length - newRows.length;
                console.log(`Found ${newRows.length} new rows, skipped ${duplicates} duplicates.`);

                const processedData = newRows
                    .map((row) => ({ // Assume row is valid due to initial filter
                        ...row,
                        Nombre: capitalizeWords(row.Nombre || ''),
                        EPS: (row.EPS || '').toUpperCase(),
                        Descripcion_PDF: row.Descripcion_PDF || '(pendiente)',
                        Justificacion_PDF: row.Justificacion_PDF || '(pendiente)',
                        Fundamento_Legal_PDF: row.Fundamento_Legal_PDF || '(pendiente)',
                        Tipo_Carta: row.Tipo_Carta || '',
                        Radicado_Comp: row.Radicado_Comp || '',
                    }));

                setState(prev => ({
                      ...prev,
                      finalData: [...(Array.isArray(prev.finalData) ? prev.finalData : []), ...processedData],
                      portalData: [] // Clear Area 1 input
                }));

                let message = `${processedData.length} nuevas filas procesadas y añadidas al Área 3.`;
                if (duplicates > 0) message += ` ${duplicates} fila(s) ya existentes fueron omitidas.`;
                showNotification(message, processedData.length > 0 ? 'success' : 'info');

          }, [state.portalData, state.masterTrackingOrders, state.finalData, showNotification]);


           // --- Process Area 2 Data (PDF Paste) ---
           const mergePdfData = useCallback(() => {
               // ... (mergePdfData logic remains the same as previous correct version) ...
                 console.log("Merging PDF data...");
                 const currentPdfData = Array.isArray(state.pdfData) ? state.pdfData.filter(row => row && Object.values(row).some(val => String(val).trim() !== '')) : [];

                 if (currentPdfData.length === 0) {
                      showNotification("No hay datos válidos en el Área 2 para combinar.", "warning");
                       setState(prev => ({ ...prev, pdfData: Array(5).fill({}) }));
                      return;
                 }

               const pdfMap = new Map();
               currentPdfData
                 .filter(row => row && row['Archivo (No. Orden)'] && String(row['Archivo (No. Orden)']).trim())
                 .forEach(row => {
                    const key = String(row['Archivo (No. Orden)']).trim();
                    if (key) {
                      pdfMap.set(key, {
                        Descripcion_PDF: String(row['Descripción'] || '').trim(),
                        Justificacion_PDF: String(row['Justificación'] || '').trim(),
                        Fundamento_Legal_PDF: String(row['Fundamento Legal'] || '').trim(),
                      });
                    }
                 });
               console.log(`Created PDF map with ${pdfMap.size} entries.`);

               const currentFinalData = Array.isArray(state.finalData) ? state.finalData : [];
               let mergeCount = 0;
               const mergedData = currentFinalData.map(finalRow => {
                 const orderKey = finalRow && finalRow.No_Orden ? String(finalRow.No_Orden).trim() : null;
                 if (orderKey) {
                    const pdfMatch = pdfMap.get(orderKey);
                    if (pdfMatch) {
                        let updated = false;
                        const newRowData = { ...finalRow }; // Create copy to modify

                        // Update only if PDF data is non-empty/non-placeholder and different
                        if (pdfMatch.Descripcion_PDF && pdfMatch.Descripcion_PDF !== '(pendiente)' && pdfMatch.Descripcion_PDF !== finalRow.Descripcion_PDF) {
                            newRowData.Descripcion_PDF = pdfMatch.Descripcion_PDF; updated = true;
                        }
                        if (pdfMatch.Justificacion_PDF && pdfMatch.Justificacion_PDF !== '(pendiente)' && pdfMatch.Justificacion_PDF !== finalRow.Justificacion_PDF) {
                            newRowData.Justificacion_PDF = pdfMatch.Justificacion_PDF; updated = true;
                        }
                        if (pdfMatch.Fundamento_Legal_PDF && pdfMatch.Fundamento_Legal_PDF !== '(pendiente)' && pdfMatch.Fundamento_Legal_PDF !== finalRow.Fundamento_Legal_PDF) {
                            newRowData.Fundamento_Legal_PDF = pdfMatch.Fundamento_Legal_PDF; updated = true;
                        }

                        if (updated) {
                            mergeCount++;
                            return newRowData; // Return the updated object
                        }
                    }
                 }
                 return finalRow; // Return original if no match or no update
               });

               if (mergeCount > 0) {
                   setState(prev => ({
                       ...prev,
                       finalData: mergedData,
                       pdfData: Array(5).fill({}),
                       editsCount: prev.editsCount + mergeCount
                   }));
                   showNotification(`${mergeCount} fila(s) actualizadas con datos del PDF en el Área 3.`, 'success');
                   console.log(`Merged PDF data into ${mergeCount} rows.`);
               } else {
                   setState(prev => ({ ...prev, pdfData: Array(5).fill({}) }));
                   showNotification('No se encontraron coincidencias o datos nuevos para combinar desde el PDF.', 'info');
                   console.log('No PDF data merged.');
               }

           }, [state.pdfData, state.finalData, showNotification]);


          // --- Update Row in Area 3 (Review Area) ---
          const updateFinalDataRow = useCallback((noOrden, partialUpdate) => {
              const keyToUpdate = String(noOrden);
             setState(prev => {
                const currentFinalData = Array.isArray(prev.finalData) ? prev.finalData : [];
                let rowUpdated = false;
                const newData = currentFinalData.map(row => {
                  if (row && String(row.No_Orden) === keyToUpdate) {
                      const isChanged = Object.keys(partialUpdate).some(updateKey => String(row[updateKey] ?? '') !== String(partialUpdate[updateKey] ?? ''));
                      if (isChanged) {
                         rowUpdated = true;
                         return { ...row, ...partialUpdate };
                      }
                  }
                  return row;
                });
                if (rowUpdated) {
                   console.log(`Updating finalData row ${keyToUpdate}`);
                   return { ...prev, finalData: newData, editsCount: prev.editsCount + 1 };
                }
                return prev;
             });
          }, []); // Removed incrementEdits dependency


          // --- Clear Area 3 Data ---
          const handleClearReviewData = useCallback(() => {
              const currentFinalData = Array.isArray(state.finalData) ? state.finalData : [];
              if (currentFinalData.length === 0) {
                   showNotification("La tabla de Revisión ya está vacía.", "info");
                   return;
              }
              if (window.confirm("¿Limpiar toda la tabla de Revisión (Área 3)? Los datos no guardados se perderán.\nEsto NO afecta los datos en Google Sheets.")) {
                  setState(prev => ({ ...prev, finalData: [] }));
                  showNotification("Tabla de Revisión limpiada.", "info");
                  // editsCount is not reset here intentionally
              }
          }, [showNotification, state.finalData]);


          // --- Send to Area 4 (Tracking) ---
          const handleSendToTracking = useCallback((selectedOrderKeys) => {
              // ... (handleSendToTracking logic remains the same as previous correct version) ...
              console.log("Attempting to send items to tracking:", selectedOrderKeys);
              const currentFinalData = Array.isArray(state.finalData) ? state.finalData : [];
              const safeTemplates = Array.isArray(state.templates) ? state.templates : [];
              let itemsSkippedNoRadicado = 0; // Count items skipped specifically for missing Radicado

              const itemsToSend = currentFinalData
                  .filter(row => row && selectedOrderKeys.includes(String(row.No_Orden)))
                  .filter(row => {
                      const template = safeTemplates.find((t) => t.id === row.Tipo_Carta);
                      const hasComplementariedadTemplate = template && template.name.toUpperCase().includes('COMPLEMENTARIEDAD');
                      const hasRadicado = row.Radicado_Comp && String(row.Radicado_Comp).trim() !== '';

                      if (hasComplementariedadTemplate && !hasRadicado) {
                          itemsSkippedNoRadicado++; // Increment skip count
                          console.warn(`Row ${row.No_Orden} has Complementariedad template but no Radicado. Skipping.`);
                      }
                      return hasComplementariedadTemplate && hasRadicado; // Must meet both to be included in itemsToSend
                  });

              // Notify about skips due to missing Radicado *before* checking if any items are left to send
              if (itemsSkippedNoRadicado > 0) {
                  showNotification(`${itemsSkippedNoRadicado} caso(s) seleccionado(s) con plantilla 'Complementariedad' omitido(s) por falta de Radicado.`, 'warning', 7000);
              }

              if (itemsToSend.length === 0) {
                  // Adjust message if skips already occurred
                  const mainMsg = itemsSkippedNoRadicado > 0
                      ? "Ningún otro ítem seleccionado cumplió los criterios para enviar a seguimiento."
                      : "No hay ítems seleccionados que cumplan los criterios (Tipo 'COMPLEMENTARIEDAD' con 'Radicado') para enviar a seguimiento.";
                  showNotification(mainMsg, 'warning');
                  return;
              }

              console.log(`${itemsToSend.length} items meet criteria for tracking.`);

              setState(prev => {
                 const currentTrackingData = Array.isArray(prev.trackingData) ? prev.trackingData : [];
                 let newTrackingData = [...currentTrackingData];
                 let newFinalData = Array.isArray(prev.finalData) ? [...prev.finalData] : [];
                 let addedCount = 0;
                 let updatedCount = 0;
                 let skippedExistingCount = 0;
                 const itemsActuallyMovedKeys = new Set();

                 itemsToSend.forEach(item => {
                   const itemOrderKey = String(item.No_Orden);
                   const existingIndex = newTrackingData.findIndex(t => t && String(t.No_Orden) === itemOrderKey);

                   if (existingIndex !== -1) {
                      if (newTrackingData[existingIndex].Radicado !== item.Radicado_Comp) {
                         if (window.confirm(`El caso ${itemOrderKey} ya está en seguimiento con Radicado "${newTrackingData[existingIndex].Radicado}".\n¿Actualizar a "${item.Radicado_Comp}"?`)) {
                           newTrackingData[existingIndex] = { ...newTrackingData[existingIndex], Radicado: item.Radicado_Comp };
                           updatedCount++;
                           itemsActuallyMovedKeys.add(itemOrderKey);
                         } else { skippedExistingCount++; }
                      } else { skippedExistingCount++; console.log(`Skipping ${itemOrderKey}, already in tracking.`); }
                   } else {
                     newTrackingData.push({
                       Fecha_Ing: item.Fecha_Neg || new Date().toISOString().slice(0,10), No_Orden: item.No_Orden, Nombre: item.Nombre || '',
                       EPS: item.EPS || '', Radicado: item.Radicado_Comp, Estado: TRACKING_STATUSES[0], Notas: '',
                     });
                     addedCount++;
                     itemsActuallyMovedKeys.add(itemOrderKey);
                   }
                 });

                 newFinalData = newFinalData.filter(f => !(f && itemsActuallyMovedKeys.has(String(f.No_Orden))));

                 let summaryMessage = "";
                 if (addedCount > 0) summaryMessage += `${addedCount} nuevo(s) enviado(s). `;
                 if (updatedCount > 0) summaryMessage += `${updatedCount} actualizado(s). `;
                 if (skippedExistingCount > 0) summaryMessage += `${skippedExistingCount} omitido(s) (ya existían).`;

                 if(addedCount > 0 || updatedCount > 0){
                     showNotification(summaryMessage.trim(), 'success');
                     return { ...prev, trackingData: newTrackingData, finalData: newFinalData, editsCount: prev.editsCount + addedCount + updatedCount };
                 } else {
                     showNotification(summaryMessage.trim() || "No se realizaron cambios en Seguimiento.", 'info');
                     return { ...prev, finalData: newFinalData };
                 }
              });

          }, [state.templates, state.finalData, state.trackingData, showNotification]);


          // --- Export Area 3 Data for Mail Merge ---
          const exportForMailMerge = useCallback((dataToExport) => {
              // ... (exportForMailMerge logic remains the same as previous correct version) ...
                const currentData = Array.isArray(dataToExport) ? dataToExport : [];
                if (currentData.length === 0) {
                    showNotification("No hay datos en revisión (Área 3) para exportar.", "warning");
                    return;
                }
                console.log(`Exporting ${currentData.length} rows for mail merge.`);
                try {
                    const safeTemplates = Array.isArray(state.templates) ? state.templates : [];
                    const exportable = currentData.map(row => {
                        const templateName = safeTemplates.find(t => t.id === row?.Tipo_Carta)?.name || "NO_SELECCIONADA";
                        return { // Define exact columns and order for export
                           "Fecha": row?.Fecha_Neg || '', "Orden": row?.No_Orden || '', "Cedula": row?.No_Cedula || '',
                           "Nombre": row?.Nombre || '', "EPS": row?.EPS || '', "Programa": row?.Programa || '',
                           "Email": row?.Email || '', "Motivo": row?.Motivo_Negacion || '',
                           "Desc_PDF": row?.Descripcion_PDF || '', "Just_PDF": row?.Justificacion_PDF || '', "Fund_PDF": row?.Fundamento_Legal_PDF || '',
                           "Tipo_Carta_Seleccionada": templateName, "Radicado_Complementariedad": row?.Radicado_Comp || ''
                           // Add other specific columns if needed, e.g., row?.Telefono, row?.Celular
                        };
                    });
                    const ws = XLSX.utils.json_to_sheet(exportable);
                    const wb = XLSX.utils.book_new();
                    XLSX.utils.book_append_sheet(wb, ws, "DatosParaEnvio");
                    XLSX.writeFile(wb, `Sigweb_Procesado_MailMerge_${new Date().toISOString().slice(0, 10)}.xlsx`);
                    showNotification("Archivo para Envío Masivo generado.", "success");
                } catch (error) {
                     console.error("Error exporting for mail merge:", error);
                     showNotification("Error al generar el archivo para envío masivo.", "error");
                }
          }, [state.templates, showNotification]);


          // --- Update Row in Area 4 (Tracking/Archived) ---
          const updateTrackingData = useCallback((index, updatedRow, isArchived) => {
              // ... (updateTrackingData logic remains the same as previous correct version) ...
                if (typeof index !== 'number' || index < 0) {
                   console.error("Invalid index provided to updateTrackingData:", index); return;
                }
              const dataKey = isArchived ? 'archivedData' : 'trackingData';
              setState(prev => {
                 const currentData = Array.isArray(prev[dataKey]) ? prev[dataKey] : [];
                 if(index < currentData.length) {
                     const newData = [...currentData]; // Create a copy
                     newData[index] = updatedRow; // Assign the updated row object
                     console.log(`Updated item at index ${index} in ${dataKey}`);
                     const newEditsCount = prev.isSaving ? prev.editsCount : prev.editsCount + 1;
                     return { ...prev, [dataKey]: newData, editsCount: newEditsCount };
                 } else {
                     console.error(`Index ${index} out of bounds for ${dataKey}`); return prev;
                 }
              });
          }, []);


          // --- Archive/Unarchive Items in Area 4 ---
          const archiveItems = useCallback((indicesToMove, fromArchived) => {
              // ... (archiveItems logic remains the same as previous correct version) ...
                if (!Array.isArray(indicesToMove) || indicesToMove.some(isNaN) || indicesToMove.length === 0){
                   console.warn("Invalid or empty indices provided to archiveItems:", indicesToMove); return;
                }
                console.log(`${fromArchived ? 'Unarchiving' : 'Archiving'} indices:`, indicesToMove);
              const sourceKey = fromArchived ? 'archivedData' : 'trackingData';
              const targetKey = fromArchived ? 'trackingData' : 'archivedData';

              setState(prev => {
                 const sourceData = Array.isArray(prev[sourceKey]) ? prev[sourceKey] : [];
                 const targetData = Array.isArray(prev[targetKey]) ? [...prev[targetKey]] : [];
                 const itemsToMove = [];
                 const remainingSourceIndices = new Set(sourceData.map((_, i) => i)); // Start with all indices

                 indicesToMove.forEach(index => {
                    if(index >= 0 && index < sourceData.length && sourceData[index]){
                       itemsToMove.push(sourceData[index]);
                       remainingSourceIndices.delete(index); // Remove moved index
                    }
                 });

                 if (itemsToMove.length === 0) { console.warn("No valid items found for moving."); return prev; }

                 const newSourceData = Array.from(remainingSourceIndices).map(index => sourceData[index]); // Build new source array
                 const newTargetData = [...targetData, ...itemsToMove]; // Append moved items

                 console.log(`Moving ${itemsToMove.length} items from ${sourceKey} to ${targetKey}.`);

                 return {
                   ...prev,
                   [sourceKey]: newSourceData,
                   [targetKey]: newTargetData,
                   editsCount: prev.isSaving ? prev.editsCount : prev.editsCount + itemsToMove.length
                 };
              });
          }, []);


          // --- Template Management Callbacks ---
          const handleSaveTemplates = useCallback((newTemplates) => {
            const templatesToSave = Array.isArray(newTemplates) ? newTemplates : defaultTemplates;
            setState(prev => ({ ...prev, templates: templatesToSave }));
            saveTemplates(templatesToSave);
            showNotification('Plantillas guardadas.', 'success');
          }, [showNotification]);

          const handleResetTemplates = useCallback(() => {
            if (window.confirm('¿Restaurar plantillas predeterminadas? Se perderán las personalizadas.')) {
              handleSaveTemplates([...defaultTemplates]);
            }
          }, [handleSaveTemplates]);

          // --- Memoized Sorted Data for Review Area ---
          const sortedFinalData = useMemo(() => {
            let sortableItems = Array.isArray(state.finalData) ? [...state.finalData] : [];
            if (sortConfig.key) {
                sortableItems.sort((a, b) => {
                    if (!a || !b) return 0;
                    const aVal = a[sortConfig.key] ?? '';
                    const bVal = b[sortConfig.key] ?? '';
                    // Attempt numeric sort for No_Orden, fallback to localeCompare
                    if (sortConfig.key === 'No_Orden') {
                       const numA = parseInt(aVal, 10);
                       const numB = parseInt(bVal, 10);
                       if (!isNaN(numA) && !isNaN(numB)) {
                          const comparison = numA - numB;
                          return sortConfig.direction === 'ascending' ? comparison : -comparison;
                       }
                    }
                    // LocaleCompare for other columns
                    const comparison = String(aVal).localeCompare(String(bVal), undefined, { numeric: true, sensitivity: 'base' });
                    return sortConfig.direction === 'ascending' ? comparison : -comparison;
                });
            }
            return sortableItems;
          }, [state.finalData, sortConfig]);

          // --- Close Setup Modal Callback ---
           const handleCloseSetupModal = useCallback(() => {
                if (!state.isSetupNeeded || state.scriptUrl) {
                    setState(prev => ({ ...prev, isReconfiguring: false }));
                } else {
                    alert("Debes configurar y verificar la URL del script para poder usar la aplicación.");
                }
           }, [state.isSetupNeeded, state.scriptUrl]);


          // ================== Render Logic ==================

          if (state.isLoading && !state.isSetupNeeded) {
            return <div className="fixed inset-0 bg-background/90 flex items-center justify-center z-[300]"><Spinner /> <span className="ml-4 text-xl">Cargando Datos Iniciales...</span></div>;
          }

          if (state.isSetupNeeded || state.isReconfiguring) {
            return <SetupModal
                onSave={handleSetScriptUrl}
                onClose={handleCloseSetupModal}
                initialUrl={state.scriptUrl || ''}
             />;
          }

          return (
            <div className="p-3 sm:p-6 bg-background min-h-screen text-sm"> {/* Smaller base padding/text */}
              {state.notification && (
                <Notification
                  message={state.notification.message}
                  type={state.notification.type}
                  onClose={hideNotification}
                />
              )}
              {!state.onlineStatus && (
                   <div className="bg-yellow-500 text-black text-center p-2 fixed top-0 left-0 w-full z-[100] shadow font-semibold">
                    ⚠ Estás desconectado. El guardado en la nube está deshabilitado.
                   </div>
              )}

              <main className={`max-w-screen-2xl mx-auto bg-surface p-4 sm:p-5 rounded-xl border border-border-color space-y-6 ${!state.onlineStatus ? 'pt-12 sm:pt-14' : ''}`}> {/* Adjusted padding */}
                <Header
                    onSave={handleSave}
                    onManageTemplates={() => setState(prev => ({ ...prev, isTemplateManagerOpen: true }))}
                    onReconfigure={() => setState(prev => ({ ...prev, isReconfiguring: true }))}
                />
                <Dashboard
                  reviewCount={Array.isArray(state.finalData) ? state.finalData.length : 0}
                  trackingCount={Array.isArray(state.trackingData) ? state.trackingData.length : 0}
                  archivedCount={Array.isArray(state.archivedData) ? state.archivedData.length : 0}
                  editsCount={state.editsCount}
                />
                <div className="text-right">
                       <button
                           onClick={() => exportDetailedReport(state.finalData, state.trackingData, state.archivedData)}
                           className="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-3 rounded-lg transition-colors text-xs sm:text-sm" // Adjusted style
                       >
                           Descargar Reporte Excel
                       </button>
                </div>

                <div className="grid grid-cols-1 lg:grid-cols-2 gap-6"> {/* Adjusted gap */}
                  <DataInputArea
                    id="portal-area"
                    title="Área 1: Cargar Excel del Portal"
                    headers={PORTAL_HEADERS}
                    data={state.portalData}
                    onDataChange={(newData) => setState(prev => ({ ...prev, portalData: newData }))}
                    onProcess={processPortalData}
                    processButtonText="Procesar y Añadir a Revisión"
                    inputType="file"
                  />
                  <DataInputArea
                    id="pdf-area"
                    title="Área 2: Pegar Datos del Extractor PDF"
                    headers={PDF_HEADERS}
                    data={state.pdfData}
                    onDataChange={(newData) => setState(prev => ({ ...prev, pdfData: newData }))}
                    onProcess={mergePdfData}
                    processButtonText="Combinar PDF con Revisión"
                    inputType="paste"
                  />
                </div>
                <ReviewArea
                  data={sortedFinalData}
                  templates={state.templates}
                  updateRow={updateFinalDataRow}
                  incrementEdits={incrementEdits} // Pass it down, even if called internally elsewhere
                  onSendToTracking={handleSendToTracking}
                  onPreview={(row) => setState(prev => ({ ...prev, previewData: row }))}
                  onExportForMailMerge={exportForMailMerge}
                  onClearReviewData={handleClearReviewData}
                  sortConfig={sortConfig}
                  setSortConfig={setSortConfig}
                />
                <TrackingArea
                  trackingData={state.trackingData}
                  archivedData={state.archivedData}
                  updateTrackingData={updateTrackingData} // Pass the correct callback
                  archiveItems={archiveItems}
                />

                {state.isSaving && <div className="fixed inset-0 bg-background/80 flex items-center justify-center z-[300]"><Spinner /> <span className="ml-4 text-lg">Guardando Datos...</span></div>} {/* Adjusted style */}
              </main>

              {state.isTemplateManagerOpen && (
                <TemplateManagerModal
                  templates={state.templates}
                  onClose={() => setState(prev => ({...prev, isTemplateManagerOpen: false}))}
                  onSave={handleSaveTemplates}
                  onReset={handleResetTemplates}
                />
              )}
              {state.previewData && (
                <PreviewModal
                  data={state.previewData}
                  template={Array.isArray(state.templates) ? state.templates.find(t => t.id === state.previewData?.Tipo_Carta) : null}
                  onClose={() => setState(prev => ({...prev, previewData: null}))}
                />
              )}
            </div>
          );
        };

        // =================================================================================
        // INLINED: index.tsx (Render the application)
        // =================================================================================
        const rootElement = document.getElementById('root');
        if (!rootElement) {
          console.error("Fatal Error: Root element 'root' not found in HTML.");
          document.body.innerHTML = '<div style="color: red; padding: 20px; font-family: sans-serif; background-color: #333; text-align: center;"><h1>Error Crítico</h1><p>No se encontró el elemento raíz de la aplicación (#root).<br>Verifica que el archivo HTML incluya <code style="background: #555; padding: 2px 4px; border-radius: 3px;">&lt;div id="root"&gt;&lt;/div&gt;</code> en el body.</p></div>';
        } else {
            try {
               const root = ReactDOM.createRoot(rootElement);
               root.render(<App />); // Render without StrictMode to avoid potential double fetch on mount in dev
            } catch(error) {
                console.error("Error rendering React application:", error);
                 rootElement.innerHTML = `<div style="color: orange; padding: 20px; font-family: sans-serif; background-color: #333;"><h1>Error Crítico al Iniciar React</h1><pre style="white-space: pre-wrap; word-wrap: break-word;">${error.stack || error.message}</pre></div>`;
            }
        }

    </script>
</body>
</html>
