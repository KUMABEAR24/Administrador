<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta http-equiv="Content-Security-Policy"
          content="default-src 'self' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://unpkg.com https://esm.sh;
                   script-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://unpkg.com https://esm.sh;
                   style-src 'self' 'unsafe-inline';
                   connect-src 'self' https://script.google.com;">

    <title>GESTION NEGACIONES EJE CAFETERO</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'primary': '#4e9fef',
              'background': '#1e1e1e',
              'surface': '#2d2d2d',
              'text-primary': '#d4d4d4',
              'text-secondary': '#a0a0a0',
              'border-color': '#444',
              'header': '#3a3a3a',
              'highlight': '#252526',
              'warning': '#6e550c',
              'archive': '#3a3a3a',
              'success': '#28a745',
              'danger': '#a02d2d',
              'danger-hover': '#c0392b',
              'btn-primary': '#0e639c',
              'btn-primary-hover': '#1a73e8',
            },
            animation: {
              'flash-success': 'flash-success 1s ease-out',
               // Optional: Add fade-in animation for notifications
               'fade-in-down': 'fade-in-down 0.5s ease-out forwards',
            },
            keyframes: {
              'flash-success': {
                'from': { backgroundColor: '#28a745' },
                'to': { backgroundColor: 'transparent' },
              },
               // Keyframes for fade-in
               'fade-in-down': {
                 '0%': { opacity: '0', transform: 'translateY(-10px)' },
                 '100%': { opacity: '1', transform: 'translateY(0)' },
               },
            }
          }
        }
      }
    </script>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client"
      }
    }
    </script>
</head>

<body class="bg-background text-text-primary">
    <div id="root"></div>

    <script type="text/babel" data-presets="react" data-type="module">
        import React, { useState, useEffect, useCallback, useMemo } from 'react';
        import ReactDOM from 'react-dom/client';

        // =================================================================================
        // INLINED: constants.ts
        // =================================================================================
        const PORTAL_HEADERS = [
            "Fecha_Neg", "Sucursal", "No_Orden", "No_Cedula", "Nombre", "Entidad_Ejecutora",
            "Motivo_Negacion", "Usuario_Emitio", "Auditor", "Observacion_Auditor", "Observacion_Ejecutivo",
            "Programa", "Plan", "Antiguedad", "EPS", "Telefono", "Celular", "Direccion", "Email", "Edad",
            "Tipo_Usuario", "Llamada", "Complementariedad", "Notificacion", "Gestion_Negacion", "Alternativa",
            "Observacion_Alternativa", "Monto", "Nit_Prestador", "Fecha_Complementariedad", "Tiempo_de_Gestion", "Regional"
        ];

        const PDF_HEADERS = [
          "Archivo (No. Orden)", "Descripci√≥n", "Justificaci√≥n", "Fundamento Legal", "C√≥digo"
        ];

        const TRACKING_STATUSES = ['Pendiente', 'En Gesti√≥n', 'Finalizado'];

        const COMMON_EMAIL_BODY = `<br><br><b>Si tiene alguna duda puede contactarse por medio de los canales que tenemos disponibles para usted:</b><br>¬∑ Nuestra l√≠nea nacional 018000931666. O con nuestras l√≠neas locales: Cali (602) 489 0073, Bogot√° (601) 743 5485, Medell√≠n (604) 604 4507, Barranquilla (605) 385 3165, Bucaramanga (607) 697 3350, Cartagena (605) 693 9853, Tulu√° (602) 235 9483, Valledupar (605)588 5699, Pereira (606) 340 2635.<br>¬∑ WhatsApp: 317-224-07-94<br><br>Gracias por su Atenci√≥n.`;
        const SIGNATURE = `<br><br>Cordialmente,<br><br><b>Juan Ricardo Morales Agudelo</b><br>Ejecutivo De Atenci√≥n Integral<br>Coomeva Medicina Prepagada<br>Cra. 13 No.11-12 Centro M√©dico Circunvalar<br>Coomeva Medicina Prepagada Pereira, Risaralda<br><br><i>Este correo es generado autom√°ticamente, por favor no responda este mensaje.</i>`;

        const defaultTemplates = [
            { id: 'tpl_neg_gen', name: 'PLANTILLA NEGACION GENERAL', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar informaci√≥n acerca del servicio {{Motivo_Negacion}} que en esta oportunidad no est√° aprobado debido a que corresponde a EXCLUSI√ìN ({{Descripcion_PDF}}), ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>El servicio negado anteriormente; debe tramitarlo a trav√©s su EPS asignada. Adjuntamos soporte de la carta de negaci√≥n.` },
            { id: 'tpl_neg_pert', name: 'PLANTILLA NO PERTINENCIA Y TEMAS ESTETICOS', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar informaci√≥n acerca del servicio {{Motivo_Negacion}} que en esta oportunidad No est√° aprobado debido a que corresponde a NO PERTINENCIA ({{Descripcion_PDF}}), ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>` },
            { id: 'tpl_comp_coinc', name: 'COMPLEMENTARIEDAD RED COINCIDENTE', body: `Apreciado Usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y el de su familia. Por medio de este correo queremos brindar informaci√≥n acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no fue aprobado, debido a que ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>Sin embargo, est√° en gesti√≥n a trav√©s de su EPS ({{EPS}}) con el n√∫mero de radicado ({{Radicado_Comp}}), puede realizar seguimiento mediante la oficina virtual de la EPS ({{Oficina_Virtual_EPS}}).<br><br>Adicional estaremos haciendo seguimiento al radicado y una vez se encuentre gestionado por la EPS, le notificaremos por medio de correo electr√≥nico.` },
            { id: 'tpl_comp_no_coinc', name: 'COMPLEMENTARIEDAD RED NO COINCIDENTE', body: `Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar informaci√≥n acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no est√° aprobado, debido a que corresponde a ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>El prestador actual solicitado, no tiene convenio con la EPS, por lo que los costos adicionales del servicio o insumo estar√°n a cargo del paciente. Sin embargo; se radica la solicitud ante su EPS con el n√∫mero ({{Radicado_Comp}}) por favor realizar seguimiento mediante la oficina virtual de la EPS ({{Oficina_Virtual_EPS}}).` },
            { id: 'tpl_comp_ayudas', name: 'COMPLEMENTARIEDAD AYUDAS DIAGNOSTICAS', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar informaci√≥n acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no est√° aprobado debido a que corresponde a ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>Sin embargo, se encuentra en gesti√≥n a trav√©s de su EPS con el n√∫mero de radicado ({{Radicado_Comp}}), por favor realizar seguimiento mediante la oficina virtual. ({{Oficina_Virtual_EPS}}).` },
        ];


        // =================================================================================
        // INLINED: services/utilityService.ts
        // =================================================================================
        const capitalizeWords = (str) => {
          if (!str) return '';
          return str.toLowerCase().replace(/\b\w/g, char => char.toUpperCase());
        };

        const processPastedData = (pastedText, headers) => {
          return pastedText
            .trim()
            .split(/\r?\n/)
            .map(rowText => {
              const cells = rowText.split('\t');
              const rowObject = {};
              headers.forEach((header, index) => {
                 // Assign cell value if it exists, otherwise assign empty string
                 rowObject[header] = cells[index] ? cells[index].trim() : '';
              });
              return rowObject;
            });
        };


        const replacePlaceholders = (templateBody, data) => {
          const getOficinaVirtual = (eps) => {
            const e = (eps || "").toUpperCase();
            if (e.includes("NUEVA EPS")) return `<a href='https://portal.nuevaeps.com.co/Portal/home.jspx' target='_blank' rel='noopener noreferrer' style='color: #1a73e8; text-decoration: underline;'>NUEVA EPS</a>`; // Added style
            if (e.includes("SALUD TOTAL")) return `<a href='https://saludtotal.com.co/' target='_blank' rel='noopener noreferrer' style='color: #1a73e8; text-decoration: underline;'>SALUD TOTAL</a>`; // Added style
            return eps || ''; // Return empty string if eps is null/undefined
          };

          // Ensure data is an object, default to empty object if not
          const safeData = (typeof data === 'object' && data !== null) ? data : {};
          const fullData = { ...safeData, Oficina_Virtual_EPS: getOficinaVirtual(safeData.EPS) };

          // Ensure templateBody is a string
          const safeTemplateBody = typeof templateBody === 'string' ? templateBody : '';

          return safeTemplateBody.replace(/\{\{(\w+)\}\}/g, (match, key) => {
             // Access data safely, default to empty string if key doesn't exist or value is null/undefined
             const value = fullData[key];
             return value !== null && value !== undefined ? String(value) : '';
          });
        };


        const exportDetailedReport = (finalData, trackingData, archivedData) => {
          try {
            const masterDataMap = new Map();

            // Ensure all inputs are arrays before spreading
            const safeFinalData = Array.isArray(finalData) ? finalData : [];
            const safeTrackingData = Array.isArray(trackingData) ? trackingData : [];
            const safeArchivedData = Array.isArray(archivedData) ? archivedData : [];

            [...safeFinalData, ...safeTrackingData, ...safeArchivedData].forEach(row => {
              if (row && row.No_Orden) {
                const key = String(row.No_Orden).trim();
                if (key) {
                  const existing = masterDataMap.get(key) || {};
                  // Deep merge might be too complex, simple override is usually sufficient here
                  const mergedRow = { ...existing, ...row };
                  masterDataMap.set(key, mergedRow);
                }
              }
            });

            const masterData = Array.from(masterDataMap.values());

            if (masterData.length === 0) {
              alert("No hay datos consolidados para exportar.");
              return;
            }

            const wb = XLSX.utils.book_new();

            // Create sheets ensuring headers match PORTAL_HEADERS + Tracking specific ones if needed
             const allHeaders = [ ...new Set([
                 ...PORTAL_HEADERS,
                 // Add headers specific to tracking/archived if they exist and aren't in PORTAL_HEADERS
                 'Fecha_Ing', 'Radicado', 'Estado', 'Notas'
             ])];


            // Add sheets only if data exists, using allHeaders for consistency
            if (safeFinalData.length > 0) {
              const ws1 = XLSX.utils.json_to_sheet(safeFinalData, { header: allHeaders });
              XLSX.utils.book_append_sheet(wb, ws1, "Casos en Revisi√≥n");
            }

            if (safeTrackingData.length > 0) {
              const ws2 = XLSX.utils.json_to_sheet(safeTrackingData, { header: allHeaders });
              XLSX.utils.book_append_sheet(wb, ws2, "Seguimiento Activo");
            }

            if (safeArchivedData.length > 0) {
              const ws3 = XLSX.utils.json_to_sheet(safeArchivedData, { header: allHeaders });
              XLSX.utils.book_append_sheet(wb, ws3, "Seguimiento Archivado");
            }

            // Always add Maestro Consolidado if masterData exists, using allHeaders
            const ws4 = XLSX.utils.json_to_sheet(masterData, { header: allHeaders });
            XLSX.utils.book_append_sheet(wb, ws4, "Maestro Consolidado");

            XLSX.writeFile(wb, `Sigweb_Reporte_Detallado_${new Date().toISOString().slice(0, 10)}.xlsx`);
          } catch (error) {
            console.error("Fall√≥ la exportaci√≥n del reporte Excel:", error);
            alert("Ocurri√≥ un error al generar el reporte detallado.");
          }
        };


        // =================================================================================
        // INLINED: services/templateService.ts
        // =================================================================================
        const TEMPLATE_STORAGE_KEY = 'sigweb_emailTemplates';

        const loadTemplates = () => {
          let loadedTemplates = [...defaultTemplates]; // Start with defaults
          try {
            const storedTemplates = localStorage.getItem(TEMPLATE_STORAGE_KEY);
            if (storedTemplates) {
              const parsed = JSON.parse(storedTemplates);
              // Robust validation
              if (Array.isArray(parsed) && parsed.every(t => t && typeof t.id === 'string' && typeof t.name === 'string' && typeof t.body === 'string')) {
                 loadedTemplates = parsed; // Use stored if valid
                 console.log("Loaded templates from localStorage.");
              } else {
                 console.warn("Stored templates data is invalid. Using defaults and removing invalid data.");
                 localStorage.removeItem(TEMPLATE_STORAGE_KEY); // Remove invalid data
              }
            } else {
                 console.log("No templates found in localStorage. Using defaults.");
            }
          } catch (error) {
            console.error("Error loading templates from localStorage. Using defaults.", error);
            localStorage.removeItem(TEMPLATE_STORAGE_KEY); // Remove potentially corrupted data
          }

           // Ensure all default templates are present (add if missing)
           const loadedIds = new Set(loadedTemplates.map(t => t.id));
           const missingDefaults = defaultTemplates.filter(dt => !loadedIds.has(dt.id));
           if (missingDefaults.length > 0) {
               console.log("Adding missing default templates.");
               loadedTemplates = [...loadedTemplates, ...missingDefaults];
               saveTemplates(loadedTemplates); // Save the combined list back immediately
           }

           return loadedTemplates;
        };


        const saveTemplates = (templates) => {
          try {
            if (!Array.isArray(templates)) {
              console.error("Attempted to save non-array templates data.");
              alert("Error: No se pudieron guardar las plantillas (datos inv√°lidos).");
              return;
            }
            if (!templates.every(t => t && typeof t.id === 'string' && typeof t.name === 'string' && typeof t.body === 'string')) {
               console.error("Attempted to save templates with invalid structure.");
               alert("Error: No se pudieron guardar las plantillas (estructura inv√°lida).");
               return;
            }
            localStorage.setItem(TEMPLATE_STORAGE_KEY, JSON.stringify(templates));
             console.log("Templates saved to localStorage.");
          } catch (error) {
            console.error("Fall√≥ el guardado de plantillas en localStorage", error);
             alert("Error: No se pudieron guardar las plantillas localmente. El almacenamiento podr√≠a estar lleno o deshabilitado.");
          }
        };


        // =================================================================================
        // INLINED: services/googleSheetService.ts
        // =================================================================================
        const fetchData = async (url) => {
            console.log("Fetching data from:", url);
            if (!url || typeof url !== 'string' || !url.startsWith('https://script.google.com/macros/s/')) {
               throw new Error("URL de Google Apps Script inv√°lida proporcionada para fetchData.");
            }
            try {
                // Add a timestamp to try and prevent caching issues
                const fetchUrl = `${url}?action=getData&t=${Date.now()}`;
                const response = await fetch(fetchUrl);
                console.log("Fetch response status:", response.status, response.statusText);
                if (!response.ok) {
                    let errorText = `HTTP error ${response.status} ${response.statusText}`;
                    try {
                       // Try to get more details from the response body if possible
                       const bodyText = await response.text();
                       if (bodyText) errorText += ` - ${bodyText}`;
                    } catch (e) { console.warn("Could not read error response body:", e); }
                    console.error("Network response was not ok:", errorText);
                    // Provide specific advice for common errors
                    if (response.status === 401 || response.status === 403) {
                       errorText += "\n\n**Sugerencia:** Verifica que el script est√© implementado para ejecutarse como 'Yo' y que el acceso a la app web est√© configurado como 'Cualquier usuario, incluso an√≥nimo'.";
                    } else if (response.status === 404) {
                        errorText += "\n\n**Sugerencia:** Verifica que la URL del script sea correcta y que la implementaci√≥n est√© activa.";
                    }
                    throw new Error(`La respuesta de la red no fue correcta: ${errorText}`);
                }

                // Check content type before parsing JSON
                const contentType = response.headers.get("content-type");
                if (!contentType || !contentType.includes("application/json")) {
                     console.error("Received non-JSON response:", await response.text());
                     throw new Error(`Respuesta inesperada del servidor (no es JSON). Verifica la implementaci√≥n del script. Content-Type: ${contentType}`);
                }

                const data = await response.json();
                console.log("Fetched data:", data);

                 // Ensure returned data fields are arrays, default to empty if not present or wrong type
                 const finalData = Array.isArray(data.finalData) ? data.finalData : [];
                 const trackingData = Array.isArray(data.trackingData) ? data.trackingData : [];
                 const archivedData = Array.isArray(data.archivedData) ? data.archivedData : [];
                 const masterTrackingOrders = Array.isArray(data.masterTrackingOrders) ? data.masterTrackingOrders : [];

                return { finalData, trackingData, archivedData, masterTrackingOrders };
            } catch (error) {
                 console.error("Fetch data failed:", error);
                 if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                    throw new Error("Error de red: No se pudo conectar al servidor del script. Verifica la URL y tu conexi√≥n a internet.");
                 }
                 // Re-throw errors that already have specific messages
                 if (error.message.startsWith("La respuesta de la red no fue correcta") || error.message.startsWith("Respuesta inesperada del servidor")) {
                    throw error;
                 }
                 // Throw a generic error for other issues
                 throw new Error(`Error al obtener datos: ${error.message}`);
            }
        };


        const saveData = async (url, requestBody) => {
            console.log("Saving data to:", url);
            if (!url || typeof url !== 'string' || !url.startsWith('https://script.google.com/macros/s/')) {
               throw new Error("URL de Google Apps Script inv√°lida proporcionada para saveData.");
            }
            if (!requestBody || typeof requestBody !== 'object' || requestBody.action !== 'saveData' || !requestBody.payload) {
                console.error("Invalid request body for saveData:", requestBody);
                throw new Error("Formato de datos inv√°lido para guardar.");
             }
            const bodyString = JSON.stringify(requestBody);
            console.log(`Save request body size: ~${(bodyString.length / 1024).toFixed(2)} KB`); // Log size

            try {
                // IMPORTANT: POST requests to Apps Script Web Apps often require proper handling of redirects (302)
                // Fetch might not follow automatically in all contexts, especially with 'no-cors'.
                // The 'no-cors' mode is a significant limitation here.
                const response = await fetch(url, {
                    method: 'POST',
                    mode: 'no-cors', // Cannot see response, assume success if no network error
                    cache: 'no-cache', // Prevent caching POST
                    headers: {
                        'Content-Type': 'text/plain;charset=utf-8', // Be explicit with charset
                    },
                    body: bodyString,
                    // redirect: 'follow' // Note: 'redirect' has no effect in 'no-cors' mode
                });

                // Since mode is 'no-cors', response object is opaque. We can't check status.
                console.log("Save request sent via fetch (no-cors). Assuming success if no error was thrown.");
                return { status: 'success', message: 'Datos enviados al servidor (no se pudo verificar respuesta).' };

            } catch (error) {
                console.error("Error during save fetch:", error);
                if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                   throw new Error("Error de red: No se pudo conectar al servidor para guardar. Verifica la URL y tu conexi√≥n a internet.");
                }
                 // Check for potential size limits (though hard to detect with no-cors)
                 if (bodyString.length > 100 * 1024) { // Warn if payload is large (e.g., > 100KB)
                    console.warn("Payload size is large, which might exceed Google Apps Script limits.");
                 }
                throw new Error(`Error al guardar datos: ${error.message}`);
            }
        };


        // =================================================================================
        // INLINED: components/Spinner.tsx - No changes needed
        // =================================================================================
        const Spinner = React.memo(() => { // Memoize simple component
          return (
            <div
              className="inline-block h-6 w-6 animate-spin rounded-full border-4 border-solid border-primary border-r-transparent align-[-0.125em] motion-reduce:animate-[spin_1.5s_linear_infinite]" // Slightly smaller spinner
              role="status"
            >
              <span className="!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]">
                Cargando...
              </span>
            </div>
          );
        });

        // =================================================================================
        // INLINED: components/Notification.tsx - Already adjusted
        // =================================================================================
        const Notification = React.memo(({ message, type = 'info', onClose }) => { // Memoize Notification
            const typeClasses = {
                success: 'bg-green-600',
                error: 'bg-red-600',
                warning: 'bg-yellow-500 text-black', // Adjusted warning color
                info: 'bg-blue-600',
            };
            const [isVisible, setIsVisible] = useState(true);
            const timeoutIdRef = useRef(null); // Use ref to store timeout ID

            const handleClose = useCallback(() => {
                setIsVisible(false);
                if (timeoutIdRef.current) {
                    clearTimeout(timeoutIdRef.current); // Clear timeout on manual close
                }
                if (onClose) {
                    onClose();
                }
            }, [onClose]);

            useEffect(() => {
                if (onClose) { // Only auto-close if onClose prop is provided (implies auto-close behavior)
                    timeoutIdRef.current = setTimeout(handleClose, 5000);
                    return () => {
                        if (timeoutIdRef.current) {
                            clearTimeout(timeoutIdRef.current);
                        }
                    };
                }
            }, [handleClose, onClose]); // Rerun effect if handleClose or onClose changes

            if (!isVisible) return null;

            return (
                <div className={`fixed top-5 right-5 z-[250] p-4 rounded-lg shadow-lg text-white ${typeClasses[type] || typeClasses.info} flex items-center gap-4 animate-fade-in-down`}>
                    <span>{message}</span>
                    <button onClick={handleClose} className="text-xl font-bold leading-none ml-2 flex-shrink-0">&times;</button>
                </div>
            );
        });


        // =================================================================================
        // INLINED: components/Header.tsx - Already memoized
        // =================================================================================
        const Header = React.memo(({ onSave, onManageTemplates, onReconfigure }) => {
          console.log("Rendering Header");
          return (
            <header className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 pb-4 border-b border-border-color">
              <div>
                <h1 className="text-2xl lg:text-3xl font-bold text-white">
                  GESTION NEGACIONES EJE CAFETERO
                </h1>
                <p className="text-text-secondary text-sm">Sistema Integrado de Gesti√≥n de Flujos de Trabajo</p>
              </div>
              <div className="flex flex-wrap gap-2">
                <button onClick={onManageTemplates} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-3 rounded-lg transition-colors text-xs sm:text-sm">
                  Plantillas
                </button>
                <button onClick={onReconfigure} className="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-3 rounded-lg transition-colors flex items-center gap-1 text-xs sm:text-sm">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0L8.21 5.15a1.5 1.5 0 01-1.25.82l-2.09.28c-1.68.23-2.34 2.26-1.09 3.42l1.52 1.48a1.5 1.5 0 01-.42 2.1l-1.83 1.25c-1.38.94-.92 3.01.7 3.42l2.05.51a1.5 1.5 0 011.1.98l.8 2.07c.43 1.12 2.29 1.12 2.72 0l.8-2.07a1.5 1.5 0 011.1-.98l2.05-.51c1.62-.4 2.08-2.48.7-3.42l-1.83-1.25a1.5 1.5 0 01-.42-2.1l1.52-1.48c1.25-1.16.59-3.19-1.09-3.42L13 5.97a1.5 1.5 0 01-1.25-.82l-.3-1.98zM10 13a3 3 0 100-6 3 3 0 000 6z" clipRule="evenodd" />
                  </svg>
                  Config
                </button>
                <button onClick={onSave} className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-lg transition-colors flex items-center gap-1 text-xs sm:text-sm">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M5.5 16.5a2.5 2.5 0 01-5 0V4.414a1.5 1.5 0 01.44-1.06L4.354.439A1.5 1.5 0 015.414 0H12.5a2.5 2.5 0 012.5 2.5v2" />
                    <path d="M5.5 16.5h8a2.5 2.5 0 002.5-2.5V8.5h-13v5.5a2.5 2.5 0 002.5 2.5z" />
                    <path d="M10.5 10a.5.5 0 01.5-.5h2a.5.5 0 010 1h-2a.5.5 0 01-.5-.5z" />
                  </svg>
                  Guardar
                </button>
              </div>
            </header>
          );
        });

        // =================================================================================
        // INLINED: components/Dashboard.tsx - Already memoized
        // =================================================================================
        const DashboardCard = React.memo(({ title, value, icon }) => (
          <div className="bg-surface p-3 rounded-lg border border-border-color flex items-center">
            <div className="text-2xl text-primary mr-3">{icon}</div>
            <div>
              <h4 className="text-xs font-semibold text-text-secondary uppercase tracking-wider">{title}</h4>
              <p className="text-xl font-bold text-text-primary">{value}</p>
            </div>
          </div>
        ));

        const Dashboard = React.memo(({ reviewCount, trackingCount, archivedCount, editsCount }) => (
          <section id="dashboard" className="grid grid-cols-2 sm:grid-cols-4 gap-3 sm:gap-4">
            <DashboardCard title="En Revisi√≥n" value={reviewCount} icon={'üìã'} />
            <DashboardCard title="Seguimiento" value={trackingCount} icon={'‚è≥'} />
            <DashboardCard title="Archivados" value={archivedCount} icon={'üóÑÔ∏è'} />
            <DashboardCard title="Edits Pendientes" value={editsCount} icon={'‚úèÔ∏è'} />
          </section>
        ));

        // =================================================================================
        // INLINED: components/DataInputArea.tsx - Already memoized
        // =================================================================================
        // ... (DataInputArea code remains the same as previous correct version) ...
        // Ensure the useCallback dependencies are correct if modified
          function DataInputArea({
            id,
            title,
            headers,
            data,
            onDataChange,
            onProcess,
            processButtonText = "Procesar Datos",
            inputType = "paste", // "paste" or "file"
          }) {
            console.log(`Rendering DataInputArea: ${id}`); // Debug log

            const handlePaste = useCallback((e) => {
              e.preventDefault();
              const pastedText = e.clipboardData.getData('text/plain');
              const newRows = processPastedData(pastedText, headers);

              // Ensure data is always an array before filtering
              const currentData = Array.isArray(data) ? data : [];
              // Filter out fully empty objects before adding new rows
              const filteredCurrent = currentData.filter(row => row && Object.values(row).some(val => String(val).trim() !== ''));
              const updatedData = [...filteredCurrent, ...newRows];

              // Add empty rows only if it's the paste input type
              if (inputType === 'paste') {
                const emptyRowCount = updatedData.filter(row => !row || !Object.values(row).some(val => String(val).trim() !== '')).length;
                const targetEmptyRows = 5; // Maintain 5 empty rows for pasting
                if (emptyRowCount < targetEmptyRows) {
                  for (let i = 0; i < (targetEmptyRows - emptyRowCount); i++) {
                    updatedData.push({}); // Add empty object placeholders
                  }
                }
              }

              onDataChange(updatedData);
            }, [data, headers, onDataChange, inputType]);

            const handleCellChange = useCallback((rowIndex, header, value) => {
               // Ensure data is always an array
              const currentData = Array.isArray(data) ? data : [];
              const newData = [...currentData];
              // Ensure the row exists before trying to update it
              if(newData[rowIndex]){
                  // Create a new object for the updated row to ensure immutability
                  newData[rowIndex] = { ...newData[rowIndex], [header]: value };
              } else {
                   console.warn(`Attempted to edit non-existent row at index ${rowIndex}`);
                   return; // Prevent further processing if row doesn't exist
              }

              // Add/remove empty rows only if it's the paste input type
               if (inputType === 'paste') {
                 const targetEmptyRows = 5;
                 // Filter out rows that are completely empty or just whitespace
                 const nonEmptyRows = newData.filter(row => row && Object.values(row).some(val => String(val).trim() !== ''));
                 const currentEmptyRowCount = newData.length - nonEmptyRows.length;

                 // Add empty rows if needed
                 if (currentEmptyRowCount < targetEmptyRows) {
                     for (let i = 0; i < (targetEmptyRows - currentEmptyRowCount); i++) {
                         nonEmptyRows.push({});
                     }
                 }
                 // Trim excess empty rows (leave exactly targetEmptyRows)
                 const finalData = [...nonEmptyRows];
                 while (finalData.filter(row => !row || !Object.values(row).some(val => String(val).trim() !== '')).length > targetEmptyRows && finalData.length > targetEmptyRows) {
                    const lastEmptyIndex = finalData.findLastIndex(row => !row || !Object.values(row).some(val => String(val).trim() !== ''));
                    if (lastEmptyIndex !== -1) {
                        finalData.splice(lastEmptyIndex, 1);
                    } else {
                        break; // Should not happen if logic is correct
                    }
                 }
                 onDataChange(finalData);
              } else {
                   onDataChange(newData); // For file input, just update the data
              }
            }, [data, onDataChange, inputType]);


            const handleFileChange = useCallback((e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const fileData = new Uint8Array(event.target.result);
                        const workbook = XLSX.read(fileData, { type: 'array', cellDates: true, dateNF: 'yyyy-mm-dd' }); // Specify date format hint
                        const sheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];

                        // Get headers separately
                        const headerRow = XLSX.utils.sheet_to_json(worksheet, { header: 1, range: 0, raw: false, defval: '' })[0] || [];
                        const excelHeaders = headerRow.map(h => String(h).trim());

                         // Convert data rows, ensuring dates are parsed correctly
                         // Use raw: false initially to get formatted strings
                        const jsonDataObjects = XLSX.utils.sheet_to_json(worksheet, { raw: false, defval: '' });


                        if (jsonDataObjects.length === 0) {
                            alert("El archivo Excel no contiene filas de datos.");
                            onDataChange([]); // Clear data on empty file
                            e.target.value = null; // Reset file input
                            return;
                        }

                        const normalizeHeadersAndData = (d, excelHeaderList) => {
                            const keyMap = { // Use lowercase keys for matching
                              'fecha neg.': 'Fecha_Neg', 'no. orden': 'No_Orden', 'no. c√©dula': 'No_Cedula',
                              'entidad ejecutora': 'Entidad_Ejecutora', 'motivo negaci√≥n': 'Motivo_Negacion',
                              'usuario emiti√≥': 'Usuario_Emitio', 'observaci√≥n auditor': 'Observacion_Auditor',
                              'observaci√≥n ejecutivo': 'Observacion_Ejecutivo', 'antig√ºedad': 'Antiguedad',
                              'tel√©fono': 'Telefono', 'direcci√≥n': 'Direccion', 'tipo usuario': 'Tipo_Usuario',
                              'notificaci√≥n': 'Notificacion', 'gesti√≥n': 'Gestion_Negacion',
                              'observaci√≥n alternativa': 'Observacion_Alternativa', 'nit prestador': 'Nit_Prestador',
                              'fecha complementariedad': 'Fecha_Complementariedad', 'tiempo de gestion': 'Tiempo_de_Gestion',
                              'sucursal': 'Sucursal', 'nombre': 'Nombre', 'programa': 'Programa', 'plan': 'Plan',
                              'eps': 'EPS', 'celular': 'Celular', 'email': 'Email', 'edad': 'Edad', 'llamada': 'Llamada',
                              'complementariedad': 'Complementariedad', 'alternativa': 'Alternativa', 'monto': 'Monto',
                              'regional': 'Regional'
                             };
                             const dateKeysInternal = new Set(['Fecha_Neg', 'Fecha_Complementariedad']);

                            const parseDateValue = (value) => {
                               if (value === null || value === undefined || String(value).trim() === '') return '';
                               if (typeof value === 'number') {
                                  try {
                                     const jsDate = XLSX.SSF.parse_date_code(value);
                                     if (jsDate && jsDate.y >= 1900) { // Basic year validation
                                        const month = String(jsDate.m).padStart(2, '0');
                                        const day = String(jsDate.d).padStart(2, '0');
                                        return `${jsDate.y}-${month}-${day}`;
                                     }
                                  } catch (dateError) { console.warn("Error parsing Excel date number:", value, dateError); }
                               } else if (typeof value === 'string') {
                                   if (/^\d{4}-\d{2}-\d{2}(T.*)?$/.test(value)) return value.substring(0, 10); // Handle YYYY-MM-DD and ISO strings
                                   try {
                                       const partsDMY = value.match(/(\d{1,2})[/-](\d{1,2})[/-](\d{4})/); // DD/MM/YYYY or DD-MM-YYYY
                                       if (partsDMY) {
                                           const year = parseInt(partsDMY[3], 10);
                                           const month = parseInt(partsDMY[2], 10);
                                           const day = parseInt(partsDMY[1], 10);
                                           if (year >= 1900 && month >= 1 && month <= 12 && day >= 1 && day <= 31) {
                                              return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                                           }
                                       }
                                       // Add MM/DD/YYYY parsing if needed
                                       // const partsMDY = value.match(/(\d{1,2})[/-](\d{1,2})[/-](\d{4})/); ...

                                       // Generic fallback (less reliable)
                                       const parsed = new Date(value);
                                       if (!isNaN(parsed) && parsed.getFullYear() >= 1900) {
                                           return parsed.toISOString().slice(0, 10);
                                       }
                                   } catch (parseError) { console.warn("Could not parse date string:", value, parseError); }
                               }
                               console.warn(`Returning original value for date column as string:`, value);
                               return String(value); // Fallback to string
                             };


                            return d.map(row => {
                                const newRow = {};
                                PORTAL_HEADERS.forEach(header => { newRow[header] = ''; }); // Initialize

                                for (const key in row) {
                                    const trimmedKeyLower = String(key).trim().toLowerCase();
                                    const internalKey = keyMap[trimmedKeyLower];
                                    if (internalKey) {
                                       const rawValue = row[key];
                                       newRow[internalKey] = dateKeysInternal.has(internalKey)
                                           ? parseDateValue(rawValue)
                                           : (rawValue !== null && rawValue !== undefined ? String(rawValue) : '');
                                    }
                                }
                                return newRow;
                            });
                        };

                        const normalizedData = normalizeHeadersAndData(jsonDataObjects, excelHeaders);
                        onDataChange(normalizedData);

                    } catch (error) {
                        console.error("Error processing Excel file:", error);
                        alert("Hubo un error al procesar el archivo Excel. Aseg√∫rate de que el formato y las columnas son correctos.\nDetalle: " + error.message);
                        onDataChange([]); // Clear data on error
                    } finally {
                         if(e.target) e.target.value = null; // Reset file input regardless of outcome
                    }
                };
                reader.onerror = (error) => {
                     console.error("Error reading file:", error);
                     alert("Hubo un error al leer el archivo.");
                     onDataChange([]); // Clear data on error
                      if(e.target) e.target.value = null; // Reset file input
                };
                reader.readAsArrayBuffer(file);
            }, [onDataChange, headers]); // Include headers in dependencies

            const clearTable = useCallback(() => {
              // Ask for confirmation for file input type as it clears potentially loaded data
              if (inputType === 'file' && data.length > 0 && !data.every(row => !Object.values(row).some(v=>v))) {
                  if (!window.confirm("¬øEst√°s seguro de que quieres limpiar los datos cargados del archivo?")) {
                      return;
                  }
              }
              onDataChange(inputType === 'paste' ? Array(5).fill({}) : []);
            }, [inputType, onDataChange, data]);

            // Ensure 'data' is always an array for rendering
            const renderData = useMemo(() => Array.isArray(data) ? data : (inputType === 'paste' ? Array(5).fill({}) : []), [data, inputType]);


            return (
              <section id={id} className="space-y-4">
                <h2 className="text-xl font-bold text-primary border-b border-border-color pb-2">{title}</h2>

                {inputType === 'file' && (
                   <div className="flex items-center gap-4">
                     <label htmlFor={`${id}-file-upload`} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-3 rounded-lg transition-colors cursor-pointer text-sm">
                         Subir Excel
                     </label>
                     <input
                         id={`${id}-file-upload`}
                         type="file"
                         className="hidden"
                         accept=".xlsx, .xls, .csv"
                         onChange={handleFileChange}
                     />
                     <span className="text-text-secondary text-sm">
                        {renderData.length > 0 && renderData.some(row => Object.values(row).some(v=>String(v).trim() !== ''))
                            ? `${renderData.filter(row => Object.values(row).some(v=>String(v).trim() !== '')).length} fila(s) cargada(s)`
                            : 'Ning√∫n archivo seleccionado'}
                     </span>
                   </div>
                )}

                <div className="table-container max-h-60 overflow-auto border border-border-color rounded-lg bg-background/20"> {/* Adjusted max-h */}
                  <table className="w-full text-xs text-left text-text-secondary table-fixed"> {/* Smaller text, fixed layout */}
                    <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                      <tr>
                        {headers.map(header => (
                          <th key={header} scope="col" className="px-3 py-2 whitespace-nowrap overflow-hidden text-ellipsis w-32 font-semibold">{header.replace(/_/g, ' ')}</th> {/* Adjusted padding/width */}
                        ))}
                      </tr>
                    </thead>
                    <tbody onPaste={inputType === 'paste' ? handlePaste : undefined}>
                      {renderData.map((row, rowIndex) => (
                        <tr key={rowIndex} className="border-b border-border-color/50 hover:bg-highlight group">
                          {headers.map(header => (
                            <td
                              key={`${rowIndex}-${header}`}
                              className="px-3 py-1 border-r border-border-color/50 outline-none whitespace-nowrap overflow-hidden text-ellipsis w-32 focus-within:bg-primary/20 focus-within:text-white group-focus-within:whitespace-normal group-hover:whitespace-normal" // Adjusted styles
                              contentEditable={inputType === 'paste'}
                              onBlur={inputType === 'paste' ? (e) => handleCellChange(rowIndex, header, e.currentTarget.innerText) : undefined}
                              suppressContentEditableWarning={true}
                              // Use textContent directly for safety
                            >{(typeof row === 'object' && row !== null && row[header] !== undefined) ? String(row[header]) : ''}</td>
                          ))}
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
                <div className="flex gap-3">
                  <button
                      onClick={onProcess}
                      disabled={renderData.length === 0 || renderData.every(row => !row || !Object.values(row).some(val => String(val).trim() !== ''))}
                      className="bg-primary hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                   >
                    {processButtonText}
                  </button>
                  <button onClick={clearTable} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-3 rounded-lg transition-colors text-sm">
                    Limpiar Tabla
                  </button>
                </div>
              </section>
            );
        } // End of Memoized DataInputArea


        // =================================================================================
        // INLINED: components/ReviewArea.tsx - Already memoized
        // =================================================================================
        // ... (ReviewArea code remains the same as previous correct version) ...
        // Ensure the useMemo/useCallback dependencies are correct if modified
        const ReviewArea = React.memo(({
            data, templates, updateRow, incrementEdits, onSendToTracking, onPreview, onExportForMailMerge, onClearReviewData, sortConfig, setSortConfig,
           }) => {
            console.log("Rendering ReviewArea");
            const [selectedRows, setSelectedRows] = useState(new Set());
            const [filter, setFilter] = useState('');

            const REVIEW_HEADERS = useMemo(() => [
                { key: 'Fecha_Neg', label: 'Fecha Neg.', width: 'w-28' }, // Added width classes
                { key: 'No_Orden', label: 'No. Orden', width: 'w-28' },
                { key: 'No_Cedula', label: 'No. C√©dula', width: 'w-32' },
                { key: 'Nombre', label: 'Nombre', width: 'w-48 flex-1 min-w-[12rem]' }, // Flexible Name
                { key: 'EPS', label: 'EPS', width: 'w-36' },
                { key: 'Programa', label: 'Programa', width: 'w-32', compact: true },
                { key: 'Motivo_Negacion', label: 'Motivo Neg.', width: 'w-48', compact: true },
                { key: 'Descripcion_PDF', label: 'Descripci√≥n', width: 'w-48', compact: true },
                { key: 'Justificacion_PDF', label: 'Justificaci√≥n', width: 'w-48', compact: true },
                { key: 'Fundamento_Legal_PDF', label: 'Fund. Legal', width: 'w-40', compact: true },
            ], []);

            const currentData = useMemo(() => Array.isArray(data) ? data : [], [data]); // Memoize currentData

            const filteredData = useMemo(() => {
                if (!filter) return currentData;
                const lowercasedFilter = filter.toLowerCase();
                try {
                    // Basic filtering across all string values
                    return currentData.filter(row =>
                        row && typeof row === 'object' &&
                        Object.values(row).some(value =>
                            String(value).toLowerCase().includes(lowercasedFilter)
                        )
                    );
                } catch (e) {
                    console.error("Filtering error:", e);
                    return currentData; // Fallback on error
                }
            }, [currentData, filter]);

            useEffect(() => {
                const currentKeys = new Set(filteredData.map(r => r ? String(r.No_Orden) : null).filter(Boolean));
                setSelectedRows(prevSelected => {
                    const newSelection = new Set();
                    for (const key of prevSelected) {
                        if (currentKeys.has(key)) {
                            newSelection.add(key);
                        }
                    }
                    // Only update state if the selection actually changes
                    if (newSelection.size !== prevSelected.size || ![...newSelection].every(key => prevSelected.has(key))) {
                        return newSelection;
                    }
                    return prevSelected;
                });
            }, [filteredData]);


            const handleSelectRow = useCallback((noOrden) => {
              const key = String(noOrden);
              setSelectedRows(prevSelection => {
                 const newSelection = new Set(prevSelection);
                 if (newSelection.has(key)) newSelection.delete(key);
                 else newSelection.add(key);
                 return newSelection;
              });
            }, []);

            const handleSelectAll = useCallback((e) => {
              if (e.target.checked) {
                const allOrderNumbers = filteredData.map(row => row ? String(row.No_Orden) : null).filter(Boolean);
                setSelectedRows(new Set(allOrderNumbers));
              } else {
                setSelectedRows(new Set());
              }
            }, [filteredData]);

            const handleCellBlur = useCallback((noOrden, key, rawValue) => {
               // Trim whitespace from edited value
               const value = String(rawValue || '').trim();
               const originalRow = currentData.find(r => r && String(r.No_Orden) === String(noOrden));
               // Compare trimmed value with potentially untrimmed original, converting original to string safely
               if (originalRow && value !== String(originalRow[key] || '').trim()) {
                 console.log(`Cell Blur Update - Row: ${noOrden}, Key: ${key}, New Value: "${value}"`);
                 updateRow(noOrden, { [key]: value });
               }
            }, [currentData, updateRow]);


            const handleSelectChange = useCallback((noOrden, value) => {
              const changes = { Tipo_Carta: value };
              const safeTemplates = Array.isArray(templates) ? templates : [];
              const template = safeTemplates.find(t => t.id === value);
              // Find the original row to check its current Radicado_Comp value
              const originalRow = currentData.find(r => r && String(r.No_Orden) === String(noOrden));
              const currentRadicado = originalRow?.Radicado_Comp || '';

              // Reset Radicado_Comp only if changing *away* from a Complementariedad template or to no template
              if (!template || !template.name.toUpperCase().includes('COMPLEMENTARIEDAD')) {
                 // Only clear if it currently has a value, to avoid unnecessary updates/edits
                 if (currentRadicado !== '') {
                     changes.Radicado_Comp = '';
                 }
              }
              // Check if Tipo_Carta actually changed before updating
              if (originalRow && originalRow.Tipo_Carta !== value) {
                 updateRow(noOrden, changes);
              } else if (changes.Radicado_Comp === '' && currentRadicado !== '') {
                 // Handle case where only Radicado needs clearing because template changed away from Complementariedad
                 updateRow(noOrden, changes);
              }
            }, [templates, currentData, updateRow]);


            const requestSort = useCallback((key) => {
              setSortConfig(currentSortConfig => {
                  let direction = 'ascending';
                  if (currentSortConfig.key === key && currentSortConfig.direction === 'ascending') {
                    direction = 'descending';
                  }
                 return { key, direction };
              });
            }, [setSortConfig]);

            const getSortIndicator = useCallback((key) => {
              if (sortConfig.key !== key) return ' '; // Return space for alignment
              return sortConfig.direction === 'ascending' ? ' ‚ñ≤' : ' ‚ñº';
            }, [sortConfig]);

            const handleExport = useCallback(() => {
                onExportForMailMerge(currentData); // Export original unfiltered/unsorted data
            }, [onExportForMailMerge, currentData]);


            return (
              <section id="area3" className="space-y-4">
                <h2 className="text-xl font-bold text-primary border-b border-border-color pb-2">√Årea 3: Revisi√≥n Final y Exportaci√≥n</h2>
                <div className="action-bar bg-highlight p-3 rounded-lg flex flex-wrap items-center gap-4 justify-between text-sm"> {/* Reduced padding */}
                  <input
                    type="text"
                    placeholder="Buscar en tabla de revisi√≥n..."
                    className="bg-surface border border-border-color rounded-md px-3 py-1 text-text-primary placeholder-text-secondary w-full sm:w-auto text-sm" // Reduced padding/size
                    value={filter}
                    onChange={(e) => setFilter(e.target.value)}
                    aria-label="Buscar en tabla de revisi√≥n"
                  />
                  <span className="text-text-primary whitespace-nowrap">{selectedRows.size} fila(s) seleccionada(s) / {currentData.length} total</span>
                </div>

                <div className="table-container max-h-[65vh] overflow-auto border border-border-color rounded-lg bg-background/20"> {/* Adjusted max height */}
                  <table className="w-full text-xs text-left text-text-secondary table-fixed border-collapse"> {/* Smaller text, fixed layout */}
                    <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                      <tr>
                        <th className={`px-2 py-2 ${REVIEW_HEADERS[0].width}`}> {/* Checkbox width */}
                            <input type="checkbox"
                                onChange={handleSelectAll}
                                checked={filteredData.length > 0 && selectedRows.size === filteredData.length}
                                disabled={filteredData.length === 0}
                                title={filteredData.length > 0 ? "Seleccionar/Deseleccionar Todo lo Visible" : "No hay filas para seleccionar"}
                                aria-label="Seleccionar todas las filas visibles"
                            />
                        </th>
                        <th className={`px-2 py-2 ${REVIEW_HEADERS[1].width}`}>üëÅÔ∏è</th> {/* Preview width */}
                         {REVIEW_HEADERS.map(({ key, label, width }) => (
                           <th key={key} onClick={() => requestSort(key)} className={`px-2 py-2 cursor-pointer whitespace-nowrap overflow-hidden text-ellipsis ${width} font-semibold`} title={`Ordenar por ${label}`}>
                               {label}
                               <span className="ml-1">{getSortIndicator(key)}</span>
                           </th>
                         ))}
                        <th className="px-2 py-2 w-48 font-semibold">Tipo de Carta</th> {/* Width */}
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-border-color/30"> {/* Row dividers */}
                     {filteredData.length > 0 ? filteredData.map((row) => {
                        if (!row || typeof row !== 'object' || !row.No_Orden) {
                          return <tr key={`invalid-${Math.random()}`}><td colSpan={REVIEW_HEADERS.length + 3} className="text-center text-danger py-1">Fila inv√°lida omitida</td></tr>;
                        }

                        const noOrdenKey = String(row.No_Orden);
                        const safeTemplates = Array.isArray(templates) ? templates : [];
                        const template = safeTemplates.find(t => t.id === row.Tipo_Carta);
                        const isComplementariedad = template && template.name.toUpperCase().includes('COMPLEMENTARIEDAD');
                        const requiresRadicado = isComplementariedad;
                        const isSelected = selectedRows.has(noOrdenKey);

                        return (
                          <tr key={noOrdenKey} className={`group ${isComplementariedad ? 'bg-indigo-900/10' : ''} ${isSelected ? 'bg-primary/20 hover:bg-primary/30' : 'hover:bg-highlight/50'}`}>
                            <td className="px-2 py-1 text-center"><input type="checkbox" checked={isSelected} onChange={() => handleSelectRow(noOrdenKey)} /></td>
                            <td className="px-2 py-1 text-base cursor-pointer text-center" onClick={() => onPreview(row)} title="Vista Previa Email">üëÅÔ∏è</td>
                            {REVIEW_HEADERS.map(({ key, width, compact }) => (
                              <td key={key}
                                  className={`px-2 py-1 border-l border-border-color/30 outline-none whitespace-nowrap overflow-hidden text-ellipsis focus-within:bg-primary/20 focus-within:text-white group-hover:whitespace-normal group-focus-within:whitespace-normal ${width}`} // Apply width
                                  contentEditable
                                  onBlur={(e) => handleCellBlur(row.No_Orden, key, e.currentTarget.innerText)}
                                  suppressContentEditableWarning={true}
                                  title={String(row[key] ?? '')} // Show full text on hover
                              >
                                  {String(row[key] ?? '')}
                              </td>
                            ))}
                            <td className="px-2 py-1 w-48 border-l border-border-color/30"> {/* Apply width */}
                              <div className="flex flex-col gap-1">
                                <select
                                  value={row.Tipo_Carta || ''}
                                  onChange={(e) => handleSelectChange(row.No_Orden, e.target.value)}
                                  className="bg-surface border border-border-color rounded px-1 py-0.5 text-text-primary w-full text-xs" // Adjusted style
                                >
                                  <option value="">-- Seleccionar --</option>
                                  {safeTemplates.map(t => <option key={t.id} value={t.id} title={t.name}>{t.name}</option>)}
                                </select>
                                {requiresRadicado && (
                                  <input
                                    type="text"
                                    placeholder="Radicado Comp..."
                                    value={row.Radicado_Comp || ''}
                                    onChange={(e) => updateRow(row.No_Orden, { Radicado_Comp: e.target.value.trim() })} // Trim input
                                    className="bg-surface border border-border-color rounded px-1 py-0.5 text-text-primary w-full mt-1 text-xs" // Adjusted style
                                  />
                                )}
                              </div>
                            </td>
                          </tr>
                        );
                      }) : (
                          <tr><td colSpan={REVIEW_HEADERS.length + 3} className="text-center py-4 text-text-secondary italic">No hay casos en revisi√≥n{filter ? ' que coincidan con la b√∫squeda.' : '.'}</td></tr>
                       )}
                    </tbody>
                  </table>
                </div>
                <div className="flex flex-wrap gap-3 text-sm"> {/* Reduced gap */}
                  <button
                      onClick={() => onSendToTracking(Array.from(selectedRows))}
                      disabled={selectedRows.size === 0}
                      className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed" // Adjusted padding
                  >
                    Enviar a Seguimiento ({selectedRows.size})
                  </button>
                   <button
                      onClick={handleExport}
                      disabled={currentData.length === 0}
                      className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed" // Adjusted padding
                   >
                     Exportar p/ Mail ({currentData.length})
                   </button>
                  <button
                      onClick={onClearReviewData}
                      className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-3 rounded-lg transition-colors" // Adjusted padding
                  >
                    Limpiar Tabla Revisi√≥n
                  </button>
                </div>
              </section>
            );
        }); // End of Memoized ReviewArea


        // =================================================================================
        // INLINED: components/TrackingArea.tsx - Already memoized
        // =================================================================================
        // ... (TrackingArea and TrackingTable code remains the same as previous correct version) ...
        // Ensure the useCallback dependencies are correct if modified
        const TrackingTable = React.memo(({ data, isArchived, onUpdate, onArchive, filter }) => {
            console.log(`Rendering TrackingTable (Archived: ${isArchived})`);

            const [selectedRows, setSelectedRows] = useState(new Set());

            const statusClasses = useMemo(() => ({
                'Pendiente': 'bg-yellow-900/30', // Darker background for better contrast
                'En Gesti√≥n': 'bg-blue-900/30',
                'Finalizado': 'bg-green-900/30',
            }), []);

            const currentData = useMemo(() => Array.isArray(data) ? data : [], [data]);

            const filteredData = useMemo(() => {
                if (!filter) return currentData;
                const lowercasedFilter = filter.toLowerCase();
                try {
                    return currentData.filter(row =>
                        row && typeof row === 'object' &&
                        Object.values(row).some(value => String(value).toLowerCase().includes(lowercasedFilter))
                    );
                } catch (e) {
                    console.error("Filtering error in TrackingTable:", e);
                    return currentData;
                }
            }, [currentData, filter]);

             useEffect(() => {
                 const currentIndices = new Set(filteredData.map(r => currentData.indexOf(r)).filter(i => i !== -1));
                 setSelectedRows(prevSelected => {
                     const newSelection = new Set();
                     for (const index of prevSelected) {
                         if (currentIndices.has(index)) newSelection.add(index);
                     }
                     if (newSelection.size !== prevSelected.size || ![...newSelection].every(key => prevSelected.has(key))) {
                        return newSelection;
                     }
                     return prevSelected; // No change needed
                 });
             }, [filteredData, currentData]);


            const handleSelectRow = useCallback((index) => {
              setSelectedRows(prevSelection => {
                 const newSelection = new Set(prevSelection);
                 if (newSelection.has(index)) newSelection.delete(index);
                 else newSelection.add(index);
                 return newSelection;
              });
            }, []);

            const handleSelectAll = useCallback((e) => {
              if (e.target.checked) {
                const allVisibleIndices = filteredData.map((row) => currentData.indexOf(row)).filter(index => index !== -1);
                setSelectedRows(new Set(allVisibleIndices));
              } else {
                setSelectedRows(new Set());
              }
            }, [filteredData, currentData]);

            const handleBulkArchive = useCallback(() => {
              if (selectedRows.size > 0) {
                onArchive(Array.from(selectedRows));
                setSelectedRows(new Set());
              }
            }, [selectedRows, onArchive]);

            const handleCellUpdate = useCallback((originalIndex, field, value) => {
                 const row = currentData[originalIndex];
                 // Trim notes specifically
                 const processedValue = field === 'Notas' ? String(value || '').trim() : value;
                 if (row && String(row[field] || '') !== processedValue) {
                    onUpdate(originalIndex, { ...row, [field]: processedValue }, isArchived); // Pass isArchived flag
                 }
             }, [currentData, onUpdate, isArchived]);


            return (
              <div className="space-y-3"> {/* Reduced spacing */}
                <div className="flex justify-between items-center text-sm">
                     <span className="text-text-secondary">
                         {filteredData.length} fila(s) mostrada(s)
                         {selectedRows.size > 0 ? `, ${selectedRows.size} seleccionada(s)` : ''}
                     </span>
                     {selectedRows.size > 0 && (
                         <button
                             onClick={handleBulkArchive}
                             className={`font-bold py-1 px-3 rounded transition-colors text-white text-xs ${isArchived ? 'bg-green-600 hover:bg-green-700' : 'bg-gray-600 hover:bg-gray-700'}`} // Adjusted style
                         >
                             {isArchived ? `‚ôªÔ∏è Restaurar (${selectedRows.size})` : `üóÑÔ∏è Archivar (${selectedRows.size})`}
                         </button>
                     )}
                </div>
                <div className="table-container max-h-[40vh] overflow-auto border border-border-color rounded-lg bg-background/20">
                  <table className="w-full text-xs text-left text-text-secondary table-fixed border-collapse"> {/* Smaller text */}
                    <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                      <tr>
                        <th className="px-2 py-2 w-8"><input type="checkbox" onChange={handleSelectAll} checked={filteredData.length > 0 && selectedRows.size === filteredData.length} disabled={filteredData.length === 0} title="Seleccionar/Deseleccionar Todo lo Visible" /></th>
                        <th className="px-2 py-2 w-24 font-semibold">Fecha Ing.</th>
                        <th className="px-2 py-2 w-24 font-semibold">No. Orden</th>
                        <th className="px-2 py-2 w-40 font-semibold">Nombre</th>
                        <th className="px-2 py-2 w-28 font-semibold">EPS</th>
                        <th className="px-2 py-2 w-28 font-semibold">Radicado</th>
                        <th className="px-2 py-2 w-28 font-semibold">Estado</th>
                        <th className="px-2 py-2 flex-1 min-w-[150px] font-semibold">Notas</th>
                        <th className="px-2 py-2 w-12 font-semibold">Acci√≥n</th>
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-border-color/30">
                     {filteredData.length > 0 ? filteredData.map((row) => {
                         const originalIndex = currentData.indexOf(row);
                         if (!row || typeof row !== 'object' || originalIndex === -1) return null; // Should not happen

                         const isSelected = selectedRows.has(originalIndex);
                         const rowClasses = `group ${isArchived ? 'bg-black/10 text-text-secondary italic' : statusClasses[row.Estado] || ''} ${isSelected ? '!bg-primary/30 hover:!bg-primary/40' : 'hover:bg-highlight/50'}`; // Use !important for selection

                        return (
                          <tr key={originalIndex} className={rowClasses}>
                            <td className="px-2 py-1 text-center"><input type="checkbox" checked={isSelected} onChange={() => handleSelectRow(originalIndex)} /></td>
                            <td className="px-2 py-1 w-24 whitespace-nowrap">{row.Fecha_Ing || ''}</td>
                            <td className="px-2 py-1 w-24 whitespace-nowrap">{row.No_Orden || ''}</td>
                            <td className="px-2 py-1 w-40 whitespace-nowrap overflow-hidden text-ellipsis" title={row.Nombre}>{row.Nombre || ''}</td>
                            <td className="px-2 py-1 w-28 whitespace-nowrap overflow-hidden text-ellipsis" title={row.EPS}>{row.EPS || ''}</td>
                            <td className="px-2 py-1 w-28 whitespace-nowrap overflow-hidden text-ellipsis" title={row.Radicado}>{row.Radicado || ''}</td>
                            <td className="px-2 py-1 w-28">
                              <select
                                value={row.Estado || TRACKING_STATUSES[0]}
                                onChange={e => handleCellUpdate(originalIndex, 'Estado', e.target.value)}
                                className={`bg-surface/50 border border-border-color/50 rounded px-1 py-0.5 w-full text-xs ${isArchived ? 'text-gray-400' : 'text-text-primary'}`}
                                disabled={isArchived}
                              >
                                {TRACKING_STATUSES.map(s => <option key={s} value={s}>{s}</option>)}
                              </select>
                            </td>
                            <td
                                className={`px-2 py-1 outline-none min-w-[150px] focus-within:bg-primary/20 focus-within:text-white group-hover:whitespace-normal group-focus-within:whitespace-normal ${isArchived ? '' : 'hover:bg-black/20'}`} // Allow wrap on hover/focus only if not archived
                                contentEditable={!isArchived}
                                onBlur={e => handleCellUpdate(originalIndex, 'Notas', e.currentTarget.innerText)}
                                suppressContentEditableWarning={true}
                                title={row.Notas} // Show full notes on hover
                             >
                                  {row.Notas || ''}
                             </td>
                            <td className="px-2 py-1 text-base cursor-pointer w-12 text-center" onClick={() => onArchive([originalIndex])} title={isArchived ? 'Restaurar' : 'Archivar'}>{isArchived ? '‚ôªÔ∏è' : 'üóÑÔ∏è'}</td>
                          </tr>
                        );
                      }) : (
                          <tr><td colSpan={9} className="text-center py-4 text-text-secondary italic">
                              {isArchived ? 'No hay casos archivados' : 'No hay casos activos'} {filter ? ' que coincidan con la b√∫squeda.' : '.'}
                          </td></tr>
                       )}
                    </tbody>
                  </table>
                </div>
              </div>
            );
        }); // End of Memoized TrackingTable

        const TrackingArea = React.memo(({ trackingData, archivedData, updateTrackingData, archiveItems }) => {
          console.log("Rendering TrackingArea");
          const [showArchived, setShowArchived] = useState(false);
          const [filter, setFilter] = useState('');
          const currentTrackingData = useMemo(() => Array.isArray(trackingData) ? trackingData : [], [trackingData]);
          const currentArchivedData = useMemo(() => Array.isArray(archivedData) ? archivedData : [], [archivedData]);

          return (
            <section id="area4" className="space-y-4">
              <h2 className="text-xl font-bold text-primary border-b border-border-color pb-2">√Årea 4: Seguimiento</h2>
              <div className="action-bar bg-highlight p-3 rounded-lg flex flex-wrap items-center gap-4 justify-between text-sm"> {/* Reduced padding */}
                <input
                  type="text"
                  placeholder="Buscar en Seguimiento..."
                  className="bg-surface border border-border-color rounded-md px-3 py-1 text-text-primary placeholder-text-secondary w-full sm:w-1/2 lg:w-1/3 text-sm" // Adjusted style
                  value={filter}
                  onChange={e => setFilter(e.target.value)}
                  aria-label="Buscar en seguimiento activo y archivado"
                />
                <button onClick={() => setShowArchived(!showArchived)} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-3 rounded-lg text-xs sm:text-sm"> {/* Adjusted style */}
                  {showArchived ? 'Ocultar' : 'Mostrar'} Archivados ({currentArchivedData.length})
                </button>
              </div>

              <h3 className="text-lg font-semibold text-white">Casos Activos ({currentTrackingData.length})</h3>
              <TrackingTable
                data={currentTrackingData}
                isArchived={false}
                onUpdate={updateTrackingData}
                onArchive={archiveItems}
                filter={filter}
              />

              {showArchived && (
                <div className="mt-6"> {/* Reduced margin */}
                  <h3 className="text-lg font-semibold text-text-secondary">Casos Archivados ({currentArchivedData.length})</h3>
                  <TrackingTable
                    data={currentArchivedData}
                    isArchived={true}
                    onUpdate={updateTrackingData} // Should not be called if disabled, but passed for consistency
                    onArchive={archiveItems}
                    filter={filter}
                  />
                </div>
              )}
            </section>
          );
        }); // End of Memoized TrackingArea

        // =================================================================================
        // INLINED: components/SetupModal.tsx - No changes needed
        // =================================================================================
        // ... (SetupModal code remains the same as previous correct version) ...
         const SetupModal = ({ onSave, onClose, initialUrl = '' }) => {
            const [url, setUrl] = useState(initialUrl);
            const [isVerifying, setIsVerifying] = useState(false);
            const [errorMsg, setErrorMsg] = useState(''); // State for error message

            const handleSave = async () => {
              setErrorMsg(''); // Clear previous errors
              if (!url || !url.startsWith('https://script.google.com/macros/s/')) {
                setErrorMsg("Por favor, introduce una URL v√°lida de Google Apps Script (debe empezar con https://script.google.com/macros/s/).");
                return;
              }
              setIsVerifying(true);
              try {
                  // onSave should throw an error if verification fails
                  await onSave(url);
                  // No need to explicitly close here, parent component handles it on success via state update
              } catch (error) {
                   console.error("Verification failed:", error);
                   // Display a user-friendly error message from the caught error
                   setErrorMsg(`Fall√≥ la verificaci√≥n: ${error.message}. Revisa la URL y los permisos.`);
              } finally {
                  setIsVerifying(false); // Ensure verifying state is reset even if error occurs
              }
            };

            return (
              <div className="fixed inset-0 bg-background bg-opacity-90 flex justify-center items-center z-[200] p-4"> {/* Increased z-index */}
                <div className="bg-surface rounded-lg shadow-xl w-full max-w-lg border border-border-color p-8 space-y-6">
                  <div className="text-center">
                    <h2 className="text-2xl font-bold text-primary">Configuraci√≥n de Conexi√≥n</h2>
                    <p className="text-text-secondary mt-2">
                        Proporciona la URL de Google Apps Script implementada como aplicaci√≥n web.
                    </p>
                  </div>
                  <div>
                    <label htmlFor="script-url" className="block text-sm font-medium text-text-primary mb-1">
                        URL del Script
                    </label>
                    <input
                        id="script-url"
                        type="url"
                        value={url}
                        onChange={(e) => { setUrl(e.target.value); setErrorMsg(''); }} // Clear error on change
                        placeholder="https://script.google.com/macros/s/..."
                        className={`w-full bg-background border rounded-md px-3 py-2 text-text-primary placeholder-text-secondary focus:ring-primary focus:border-primary ${errorMsg ? 'border-danger' : 'border-border-color'}`} // Highlight on error
                        aria-invalid={!!errorMsg}
                        aria-describedby="url-error"
                    />
                    {errorMsg && <p id="url-error" className="text-danger text-sm mt-1">{errorMsg}</p>}
                  </div>
                  <div className="flex justify-end gap-4">
                    <button
                        onClick={onClose} // Let parent handle close logic
                        disabled={isVerifying}
                        className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                        Cancelar
                    </button>
                    <button
                        onClick={handleSave}
                        disabled={isVerifying || !url}
                        className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed min-w-[150px] flex justify-center items-center" // Ensure button size stays consistent
                    >
                        {isVerifying ? <Spinner /> : 'Guardar y Verificar'}
                    </button>
                  </div>
                </div>
              </div>
            );
         };

        // =================================================================================
        // INLINED: components/TemplateManagerModal.tsx - No changes needed
        // =================================================================================
        // ... (TemplateManagerModal code remains the same as previous correct version) ...
          const TemplateManagerModal = ({ templates, onClose, onSave, onReset }) => {
            const [currentTemplates, setCurrentTemplates] = useState(() => structuredClone(Array.isArray(templates) ? templates : [])); // Deep clone initial templates
            const [editingTemplate, setEditingTemplate] = useState(null); // Holds the template being edited/created

            const handleSaveLocal = useCallback(() => {
              // Add validation before saving if needed
              onSave(currentTemplates); // Pass the current state up
            }, [currentTemplates, onSave]);

            const handleAddNew = useCallback(() => {
              // Create a truly new ID for the new template
              setEditingTemplate({ id: `custom_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`, name: '', body: '' });
            }, []);

            const handleEdit = useCallback((template) => {
               // Create a copy for editing to avoid modifying the list directly
               setEditingTemplate({ ...template });
            }, []);

            const handleDelete = useCallback((idToDelete) => {
              if (window.confirm('¬øEst√°s seguro de que quieres eliminar esta plantilla? Esta acci√≥n no se puede deshacer.')) {
                setCurrentTemplates(current => current.filter(t => t.id !== idToDelete)); // Use functional update
              }
            }, []);

            const handleSaveTemplateEdit = useCallback(() => {
              if (!editingTemplate || !editingTemplate.name.trim() || !editingTemplate.body.trim()) {
                alert('El nombre y el cuerpo de la plantilla no pueden estar vac√≠os.');
                return;
              }

              setCurrentTemplates(current => {
                  const updatedTemplates = Array.isArray(current) ? [...current] : []; // Ensure it's an array
                  const existingIndex = updatedTemplates.findIndex(t => t.id === editingTemplate.id);
                  if (existingIndex > -1) {
                      // Update existing
                      updatedTemplates[existingIndex] = { ...editingTemplate }; // Ensure it's a new object
                  } else {
                      // Add new
                      updatedTemplates.push({ ...editingTemplate }); // Ensure it's a new object
                  }
                  return updatedTemplates;
              });
              setEditingTemplate(null); // Close editor
            }, [editingTemplate]); // Depends on the template being edited


             // Handler for input changes within the editor
             const handleEditorChange = useCallback((field, value) => {
                  setEditingTemplate(prev => prev ? ({ ...prev, [field]: value }) : null);
             }, []);


            return (
              <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[250] p-4"> {/* Increased z-index */}
                <div className="bg-surface rounded-lg shadow-xl w-full max-w-4xl border border-border-color flex flex-col max-h-[90vh]">
                  <div className="p-6 border-b border-border-color flex justify-between items-center flex-shrink-0"> {/* Header */}
                    <h3 className="text-xl font-bold text-primary">Gestionar Plantillas de Correo</h3>
                    <button onClick={onClose} className="text-text-secondary text-2xl hover:text-text-primary">&times;</button>
                  </div>

                  <div className="p-6 overflow-y-auto space-y-6 flex-grow"> {/* Content Area */}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 h-full"> {/* Layout */}

                      {/* Left Side: List of Templates */}
                      <div className="flex flex-col h-full">
                        <div className="flex justify-between items-center mb-2">
                           <h4 className="text-lg font-semibold">Plantillas Actuales</h4>
                           <button onClick={handleAddNew} className="bg-green-600 hover:bg-green-700 text-white text-xs font-bold py-1 px-2 rounded disabled:opacity-50" disabled={!!editingTemplate}>
                             + Nueva
                           </button>
                        </div>
                        <ul className="space-y-1 border border-border-color rounded-lg p-2 overflow-y-auto flex-grow bg-background/30"> {/* Reduced space */}
                          {currentTemplates.map(template => (
                            <li key={template.id} className={`flex justify-between items-center p-2 rounded transition-colors text-sm ${editingTemplate?.id === template.id ? 'bg-primary/30 ring-1 ring-primary' : 'bg-highlight hover:bg-highlight/70'}`}>
                              <span className="text-text-primary truncate flex-grow mr-2" title={template.name}>{template.name}</span>
                              <div className="space-x-1 flex-shrink-0"> {/* Reduced space */}
                                <button onClick={() => handleEdit(template)} className="text-xs bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded disabled:opacity-50" disabled={!!editingTemplate}>Editar</button>
                                <button onClick={() => handleDelete(template.id)} className="text-xs bg-danger hover:bg-danger-hover px-2 py-1 rounded disabled:opacity-50" disabled={!!editingTemplate}>Borrar</button>
                              </div>
                            </li>
                          ))}
                           {currentTemplates.length === 0 && <li className="text-text-secondary text-center p-4 italic">No hay plantillas guardadas.</li>}
                        </ul>
                      </div>

                      {/* Right Side: Editor/Placeholder */}
                      <div className="flex flex-col h-full">
                         <h4 className="text-lg font-semibold mb-2">
                            {editingTemplate ? (currentTemplates.some(t => t.id === editingTemplate.id) ? 'Editar Plantilla' : 'Nueva Plantilla') : 'Editor de Plantilla'}
                         </h4>
                         {editingTemplate ? (
                             <div className="space-y-3 p-4 border border-border-color rounded-lg bg-highlight flex flex-col flex-grow">
                               <input
                                 type="text"
                                 placeholder="Nombre de la Plantilla"
                                 value={editingTemplate.name}
                                 onChange={(e) => handleEditorChange('name', e.target.value)}
                                 className="w-full bg-background border border-border-color rounded-md px-3 py-2 text-sm flex-shrink-0"
                               />
                               <textarea
                                 placeholder="Cuerpo de la Plantilla (HTML permitido)..."
                                 value={editingTemplate.body}
                                 onChange={(e) => handleEditorChange('body', e.target.value)}
                                 className="w-full bg-background border border-border-color rounded-md px-3 py-2 resize-y flex-grow text-sm min-h-[200px]" // Ensure minimum height
                               />
                                <p className="text-xs text-text-secondary flex-shrink-0">Marcadores disponibles: {`{{Columna}}`} (ej: {`{{Nombre}}`}, {`{{No_Orden}}`}, {`{{EPS}}`}, {`{{Oficina_Virtual_EPS}}`}, etc.)</p>
                               <div className="flex gap-2 flex-shrink-0 justify-end">
                                 <button onClick={() => setEditingTemplate(null)} className="bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded text-sm">Cancelar</button>
                                 <button onClick={handleSaveTemplateEdit} className="bg-success hover:bg-green-700 px-3 py-1 rounded text-sm">Guardar Cambios</button>
                               </div>
                             </div>
                           ) : (
                             <div className="flex items-center justify-center h-full border border-dashed border-border-color rounded-lg bg-background/30 text-text-secondary italic p-4 text-center">
                                Selecciona una plantilla de la lista para editarla,<br /> o haz clic en "+ Nueva" para crear una.
                             </div>
                           )}
                      </div>

                    </div>
                  </div>

                  <div className="p-4 bg-header flex justify-between items-center rounded-b-lg flex-shrink-0"> {/* Footer */}
                     <button onClick={onReset} className="bg-danger hover:bg-danger-hover text-white font-bold py-2 px-4 rounded-lg text-sm disabled:opacity-50" disabled={!!editingTemplate}>
                      Restaurar Predeterminadas
                    </button>
                    <div className="flex gap-4">
                      <button onClick={onClose} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg text-sm" disabled={!!editingTemplate}>
                          Cancelar
                      </button>
                      <button onClick={handleSaveLocal} className="bg-success hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg text-sm" disabled={!!editingTemplate}>
                          Guardar y Cerrar
                      </button>
                    </div>
                  </div>
                </div>
              </div>
          );
         };

        // =================================================================================
        // INLINED: components/PreviewModal.tsx - No changes needed
        // =================================================================================
        // ... (PreviewModal code remains the same as previous correct version) ...
          const PreviewModal = ({ data, template, onClose }) => {
            if (!data || typeof data !== 'object') {
               console.error("Invalid data provided to PreviewModal:", data);
               return (
                    <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[250] p-4">
                       <div className="bg-surface rounded-lg shadow-xl w-full max-w-lg border border-border-color p-8 text-center">
                           <h3 className="text-xl font-bold text-danger mb-4">Error</h3>
                           <p className="text-text-secondary mb-6">No se pudieron cargar los datos para la vista previa.</p>
                           <button onClick={onClose} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Cerrar</button>
                       </div>
                    </div>
               );
            }

            const bodyContent = template && template.body ? replacePlaceholders(template.body, data) : '<p class="italic text-gray-500">[Selecciona un tipo de carta en el √Årea 3 para ver la vista previa aqu√≠]</p>';
            const fullBody = `<div style="font-family: Arial, sans-serif; font-size: 14px; color: #333; line-height: 1.6;">${bodyContent}${COMMON_EMAIL_BODY}${SIGNATURE}</div>`; // Wrap in basic styles


            const copyToClipboard = useCallback(() => {
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = fullBody;
              const textContent = tempDiv.textContent || tempDiv.innerText || "";
              navigator.clipboard.writeText(textContent.trim())
                .then(() => alert('¬°Contenido de texto copiado al portapapeles!'))
                .catch(err => { console.error('Failed to copy text content:', err); alert('Fall√≥ al copiar el contenido de texto.'); });
            }, [fullBody]);


            const copyHtmlToClipboard = useCallback(() => {
                 try {
                    if (navigator.clipboard && window.ClipboardItem) {
                        const type = "text/html";
                        const blob = new Blob([fullBody], { type });
                        const data = [new ClipboardItem({ [type]: blob })];
                        navigator.clipboard.write(data)
                           .then(() => alert('¬°Contenido HTML copiado al portapapeles!'))
                           .catch(err => { console.error('Failed to copy HTML using ClipboardItem:', err); alert('Fall√≥ al copiar el contenido HTML (tu navegador podr√≠a no soportarlo). Intenta copiar el texto.'); });
                    } else {
                         console.warn("ClipboardItem API not supported, attempting fallback text copy.");
                         copyToClipboard();
                         alert("Se copi√≥ el texto, pero el formato HTML puede no ser compatible con tu navegador.");
                    }
                 } catch (error) {
                     console.error('Error copying HTML:', error);
                     alert('Error inesperado al intentar copiar HTML.');
                 }
              }, [fullBody, copyToClipboard]);


            return (
              <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[250] p-4"> {/* Higher z-index */}
                <div className="bg-white rounded-lg shadow-xl w-full max-w-3xl border border-gray-300 flex flex-col max-h-[90vh]"> {/* White background for preview */}
                  <div className="p-4 border-b border-gray-300 flex justify-between items-center flex-shrink-0 bg-gray-100 rounded-t-lg"> {/* Header */}
                    <h3 className="text-lg font-bold text-gray-800 truncate">Vista Previa: Orden {data.No_Orden || 'N/A'}</h3>
                     <button onClick={onClose} className="text-gray-500 hover:text-gray-800 text-2xl ml-4">&times;</button>
                  </div>
                  <iframe
                    // srcDoc={`<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{margin: 1rem;}</style></head><body>${fullBody}</body></html>`}
                    srcDoc={fullBody} // Let the div styling handle it mostly
                    className="flex-grow overflow-y-auto border-none w-full bg-white p-4" // Added padding inside iframe
                    sandbox="allow-same-origin"
                    title={`Vista Previa Email Orden ${data.No_Orden || 'N/A'}`}
                  />
                  <div className="p-4 bg-gray-100 flex justify-end gap-3 rounded-b-lg flex-shrink-0 border-t border-gray-300"> {/* Footer */}
                     <button onClick={copyHtmlToClipboard} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-lg transition-colors text-sm" title="Copiar como HTML formateado">
                       Copiar HTML
                     </button>
                    <button onClick={copyToClipboard} className="bg-blue-800 hover:bg-blue-900 text-white font-bold py-2 px-3 rounded-lg transition-colors text-sm" title="Copiar solo el texto">
                      Copiar Texto
                    </button>
                    <button onClick={onClose} className="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-3 rounded-lg transition-colors text-sm">
                      Cerrar
                    </button>
                  </div>
                </div>
              </div>
            );
          };

        // =================================================================================
        // INLINED: App.tsx (The main application component)
        // =================================================================================
        const App = () => {
          console.log("Rendering App"); // Debug: Check if App renders multiple times unexpectedly
          const [state, setState] = useState({
            finalData: [],
            trackingData: [],
            archivedData: [],
            portalData: [],
            pdfData: Array(5).fill({}),
            templates: [],
            scriptUrl: null,
            isSetupNeeded: false,
            isReconfiguring: false,
            isLoading: true,
            isSaving: false,
            isTemplateManagerOpen: false,
            previewData: null,
            notification: null,
            editsCount: 0,
            onlineStatus: true,
            masterTrackingOrders: new Set(),
          });

          const [sortConfig, setSortConfig] = useState({
            key: 'Fecha_Neg', // Default sort by date
            direction: 'descending', // Show newest first
          });

          // --- Notification Management (useRef for timeout ID) ---
          const notificationTimeoutIdRef = useRef(null);
          const hideNotification = useCallback(() => {
              if (notificationTimeoutIdRef.current) {
                  clearTimeout(notificationTimeoutIdRef.current);
                  notificationTimeoutIdRef.current = null;
              }
              setState(prev => ({ ...prev, notification: null }));
          }, []);

          const showNotification = useCallback((message, type = 'info', duration = 5000) => {
             // Clear existing timeout before setting a new one
             if (notificationTimeoutIdRef.current) {
                  clearTimeout(notificationTimeoutIdRef.current);
             }
             // Set the new notification state
             setState(prev => ({ ...prev, notification: { message, type } }));
             // Set new timeout and store its ID
             notificationTimeoutIdRef.current = setTimeout(hideNotification, duration);
          }, [hideNotification]);


          // --- Script URL and Initial Data Loading ---
          const handleSetScriptUrl = useCallback(async (url) => {
              console.log("Attempting to set script URL and fetch initial data...");
             setState(prev => ({ ...prev, isLoading: true, isReconfiguring: false }));
             try {
               const data = await fetchData(url);
               localStorage.setItem('sigweb_scriptUrl', url);
               setState(prev => ({
                 ...prev,
                 finalData: data.finalData,
                 trackingData: data.trackingData,
                 archivedData: data.archivedData,
                 masterTrackingOrders: new Set(data.masterTrackingOrders.map(String)),
                 scriptUrl: url,
                 isSetupNeeded: false,
                 isLoading: false,
                 editsCount: 0, // Reset edits on successful load/reload
               }));
               showNotification('¬°Conexi√≥n exitosa y datos cargados!', 'success');
               console.log("Initial data fetched successfully.");
             } catch (error) {
               console.error("Error setting script URL or fetching data:", error);
               showNotification(
                 `Fall√≥ la conexi√≥n: ${error.message}. Revisa la URL y permisos del script.`, 'error', 15000 // Show error much longer
               );
               setState(prev => ({ ...prev, isLoading: false, isSetupNeeded: true, scriptUrl: null }));
               localStorage.removeItem('sigweb_scriptUrl');
               throw error; // Re-throw for SetupModal error handling
             }
          }, [showNotification]); // showNotification is stable


          // --- Effect for Initial Load and Online Status ---
          useEffect(() => {
              console.log("App component mounted. Checking config...");
            const url = localStorage.getItem('sigweb_scriptUrl');
            const loadedTemplates = loadTemplates();
            setState(prev => ({ ...prev, templates: loadedTemplates }));

            if (url) {
                console.log("Found script URL:", url);
                handleSetScriptUrl(url).catch(err => {
                    console.error("Initial data load failed on mount:", err);
                    // State should reflect setup needed due to error in handleSetScriptUrl
                });
            } else {
                console.log("No script URL found. Setup needed.");
                setState(prev => ({ ...prev, isSetupNeeded: true, isLoading: false }));
            }

            // Online/Offline handling
            const updateOnlineStatus = () => {
                const isOnline = navigator.onLine;
                 setState(prev => {
                     if (prev.onlineStatus === isOnline) return prev; // No change
                     console.log("Network status changed:", isOnline ? "Online" : "Offline");
                     if (!isOnline) {
                        showNotification("Est√°s desconectado. El guardado en la nube est√° deshabilitado.", "warning", 10000);
                     } else if (prev.onlineStatus === false && isOnline){
                         showNotification("Est√°s conectado de nuevo.", "success", 3000); // Shorter success message
                     }
                     return { ...prev, onlineStatus: isOnline };
                });
            };

            window.addEventListener('online', updateOnlineStatus);
            window.addEventListener('offline', updateOnlineStatus);
            updateOnlineStatus(); // Initial check

            return () => { // Cleanup
                console.log("App component unmounting. Removing listeners.");
                window.removeEventListener('online', updateOnlineStatus);
                window.removeEventListener('offline', updateOnlineStatus);
                if (notificationTimeoutIdRef.current) { // Clear notification timeout on unmount
                   clearTimeout(notificationTimeoutIdRef.current);
                }
            };
            // Only run on mount. handleSetScriptUrl is stable due to useCallback.
          }, [handleSetScriptUrl, showNotification]); // Added showNotification


          // --- Edit Counter ---
          const incrementEdits = useCallback((count = 1) => { // Allow incrementing by more than 1 if needed
            console.log(`Incrementing edits count by ${count}`);
            setState(prev => ({ ...prev, editsCount: prev.editsCount + count }));
          },[]);


          // --- Save Data ---
          const handleSave = useCallback(async () => {
              // ... (handleSave logic remains the same as the previous correct version) ...
               console.log("Save button clicked.");
               if (!state.scriptUrl) {
                   showNotification('No se puede guardar. La URL del script no est√° configurada.', 'error');
                   return;
               }
               if (!state.onlineStatus) {
                   showNotification('No se puede guardar mientras est√°s desconectado.', 'error');
                   return;
               }

               const safeFinalData = Array.isArray(state.finalData) ? state.finalData : [];
               const safeTrackingData = Array.isArray(state.trackingData) ? state.trackingData : [];
               const safeArchivedData = Array.isArray(state.archivedData) ? state.archivedData : [];

               if (safeFinalData.length === 0 && state.editsCount === 0) {
                    showNotification('No hay datos nuevos o modificados para guardar.', 'info');
                    return;
               }

               setState(prev => ({ ...prev, isSaving: true }));
               console.log("Attempting to save data...");

               try {
                   const payload = {
                       action: 'saveData',
                       payload: {
                           finalData: safeFinalData,
                           trackingData: safeTrackingData,
                           archivedData: safeArchivedData,
                       }
                   };
                   await saveData(state.scriptUrl, payload);

                   const newOrders = new Set(state.masterTrackingOrders);
                   [...safeFinalData, ...safeTrackingData, ...safeArchivedData].forEach(row => {
                       if (row && row.No_Orden) {
                           newOrders.add(String(row.No_Orden).trim());
                       }
                   });

                   showNotification('Datos enviados a la nube (respuesta no verificada).', 'success'); // Adjusted message for no-cors
                   console.log("Save request sent successfully. Updated masterTrackingOrders locally.");

                   setState(prev => ({
                       ...prev,
                       editsCount: 0,
                       masterTrackingOrders: newOrders,
                       finalData: [] // Clear review area
                   }));
               } catch (error) {
                   console.error("Error during save:", error);
                   showNotification(`Fall√≥ el guardado: ${error.message}`, 'error', 10000); // Show error longer
               } finally {
                   setState(prev => ({ ...prev, isSaving: false }));
                   console.log("Save process finished.");
               }
          }, [state.scriptUrl, state.onlineStatus, state.finalData, state.trackingData, state.archivedData, state.masterTrackingOrders, state.editsCount, showNotification]);


          // --- Process Area 1 Data (Excel Upload) ---
          const processPortalData = useCallback(() => {
              // ... (processPortalData logic remains the same as previous correct version) ...
                console.log("Processing portal data...");
                const currentPortalData = Array.isArray(state.portalData) ? state.portalData.filter(row => row && Object.values(row).some(val => String(val).trim() !== '')) : [];

                if (currentPortalData.length === 0) {
                     showNotification("No hay datos v√°lidos cargados desde el archivo para procesar.", "warning");
                     setState(prev => ({ ...prev, portalData: [] }));
                     return;
                }

                const newRows = currentPortalData.filter(row => {
                     const orderKey = row && row.No_Orden ? String(row.No_Orden).trim() : null;
                     return orderKey && !state.masterTrackingOrders.has(orderKey);
                });

                const duplicates = currentPortalData.length - newRows.length;
                console.log(`Found ${newRows.length} new rows, skipped ${duplicates} duplicates.`);

                const processedData = newRows
                    .map((row) => ({ // Assume row is valid due to initial filter
                        ...row,
                        Nombre: capitalizeWords(row.Nombre || ''),
                        EPS: (row.EPS || '').toUpperCase(),
                        Descripcion_PDF: row.Descripcion_PDF || '(pendiente)',
                        Justificacion_PDF: row.Justificacion_PDF || '(pendiente)',
                        Fundamento_Legal_PDF: row.Fundamento_Legal_PDF || '(pendiente)',
                        Tipo_Carta: row.Tipo_Carta || '',
                        Radicado_Comp: row.Radicado_Comp || '',
                    }));

                setState(prev => ({
                      ...prev,
                      finalData: [...(Array.isArray(prev.finalData) ? prev.finalData : []), ...processedData],
                      portalData: [] // Clear Area 1 input
                }));

                let message = `${processedData.length} nuevas filas procesadas y a√±adidas al √Årea 3.`;
                if (duplicates > 0) message += ` ${duplicates} fila(s) ya existentes fueron omitidas.`;
                showNotification(message, processedData.length > 0 ? 'success' : 'info');

          }, [state.portalData, state.masterTrackingOrders, state.finalData, showNotification]);


           // --- Process Area 2 Data (PDF Paste) ---
           const mergePdfData = useCallback(() => {
               // ... (mergePdfData logic remains the same as previous correct version) ...
                 console.log("Merging PDF data...");
                 const currentPdfData = Array.isArray(state.pdfData) ? state.pdfData.filter(row => row && Object.values(row).some(val => String(val).trim() !== '')) : [];

                 if (currentPdfData.length === 0) {
                      showNotification("No hay datos v√°lidos en el √Årea 2 para combinar.", "warning");
                       setState(prev => ({ ...prev, pdfData: Array(5).fill({}) }));
                      return;
                 }

               const pdfMap = new Map();
               currentPdfData
                 .filter(row => row && row['Archivo (No. Orden)'] && String(row['Archivo (No. Orden)']).trim())
                 .forEach(row => {
                    const key = String(row['Archivo (No. Orden)']).trim();
                    if (key) {
                      pdfMap.set(key, {
                        Descripcion_PDF: String(row['Descripci√≥n'] || '').trim(),
                        Justificacion_PDF: String(row['Justificaci√≥n'] || '').trim(),
                        Fundamento_Legal_PDF: String(row['Fundamento Legal'] || '').trim(),
                      });
                    }
                 });
               console.log(`Created PDF map with ${pdfMap.size} entries.`);

               const currentFinalData = Array.isArray(state.finalData) ? state.finalData : [];
               let mergeCount = 0;
               const mergedData = currentFinalData.map(finalRow => {
                 const orderKey = finalRow && finalRow.No_Orden ? String(finalRow.No_Orden).trim() : null;
                 if (orderKey) {
                    const pdfMatch = pdfMap.get(orderKey);
                    if (pdfMatch) {
                        let updated = false;
                        const newRowData = { ...finalRow }; // Create copy to modify

                        // Update only if PDF data is non-empty/non-placeholder and different
                        if (pdfMatch.Descripcion_PDF && pdfMatch.Descripcion_PDF !== '(pendiente)' && pdfMatch.Descripcion_PDF !== finalRow.Descripcion_PDF) {
                            newRowData.Descripcion_PDF = pdfMatch.Descripcion_PDF; updated = true;
                        }
                        if (pdfMatch.Justificacion_PDF && pdfMatch.Justificacion_PDF !== '(pendiente)' && pdfMatch.Justificacion_PDF !== finalRow.Justificacion_PDF) {
                            newRowData.Justificacion_PDF = pdfMatch.Justificacion_PDF; updated = true;
                        }
                        if (pdfMatch.Fundamento_Legal_PDF && pdfMatch.Fundamento_Legal_PDF !== '(pendiente)' && pdfMatch.Fundamento_Legal_PDF !== finalRow.Fundamento_Legal_PDF) {
                            newRowData.Fundamento_Legal_PDF = pdfMatch.Fundamento_Legal_PDF; updated = true;
                        }

                        if (updated) {
                            mergeCount++;
                            return newRowData; // Return the updated object
                        }
                    }
                 }
                 return finalRow; // Return original if no match or no update
               });

               if (mergeCount > 0) {
                   setState(prev => ({
                       ...prev,
                       finalData: mergedData,
                       pdfData: Array(5).fill({}),
                       editsCount: prev.editsCount + mergeCount
                   }));
                   showNotification(`${mergeCount} fila(s) actualizadas con datos del PDF en el √Årea 3.`, 'success');
                   console.log(`Merged PDF data into ${mergeCount} rows.`);
               } else {
                   setState(prev => ({ ...prev, pdfData: Array(5).fill({}) }));
                   showNotification('No se encontraron coincidencias o datos nuevos para combinar desde el PDF.', 'info');
                   console.log('No PDF data merged.');
               }

           }, [state.pdfData, state.finalData, showNotification]);


          // --- Update Row in Area 3 (Review Area) ---
          const updateFinalDataRow = useCallback((noOrden, partialUpdate) => {
              const keyToUpdate = String(noOrden);
             setState(prev => {
                const currentFinalData = Array.isArray(prev.finalData) ? prev.finalData : [];
                let rowUpdated = false;
                const newData = currentFinalData.map(row => {
                  if (row && String(row.No_Orden) === keyToUpdate) {
                      const isChanged = Object.keys(partialUpdate).some(updateKey => String(row[updateKey] ?? '') !== String(partialUpdate[updateKey] ?? ''));
                      if (isChanged) {
                         rowUpdated = true;
                         return { ...row, ...partialUpdate };
                      }
                  }
                  return row;
                });
                if (rowUpdated) {
                   console.log(`Updating finalData row ${keyToUpdate}`);
                   return { ...prev, finalData: newData, editsCount: prev.editsCount + 1 };
                }
                return prev;
             });
          }, []); // Removed incrementEdits dependency


          // --- Clear Area 3 Data ---
          const handleClearReviewData = useCallback(() => {
              const currentFinalData = Array.isArray(state.finalData) ? state.finalData : [];
              if (currentFinalData.length === 0) {
                   showNotification("La tabla de Revisi√≥n ya est√° vac√≠a.", "info");
                   return;
              }
              if (window.confirm("¬øLimpiar toda la tabla de Revisi√≥n (√Årea 3)? Los datos no guardados se perder√°n.\nEsto NO afecta los datos en Google Sheets.")) {
                  setState(prev => ({ ...prev, finalData: [] }));
                  showNotification("Tabla de Revisi√≥n limpiada.", "info");
                  // editsCount is not reset here intentionally
              }
          }, [showNotification, state.finalData]);


          // --- Send to Area 4 (Tracking) ---
          const handleSendToTracking = useCallback((selectedOrderKeys) => {
              // ... (handleSendToTracking logic remains the same as previous correct version) ...
              console.log("Attempting to send items to tracking:", selectedOrderKeys);
              const currentFinalData = Array.isArray(state.finalData) ? state.finalData : [];
              const safeTemplates = Array.isArray(state.templates) ? state.templates : [];
              let itemsSkippedNoRadicado = 0; // Count items skipped specifically for missing Radicado

              const itemsToSend = currentFinalData
                  .filter(row => row && selectedOrderKeys.includes(String(row.No_Orden)))
                  .filter(row => {
                      const template = safeTemplates.find((t) => t.id === row.Tipo_Carta);
                      const hasComplementariedadTemplate = template && template.name.toUpperCase().includes('COMPLEMENTARIEDAD');
                      const hasRadicado = row.Radicado_Comp && String(row.Radicado_Comp).trim() !== '';

                      if (hasComplementariedadTemplate && !hasRadicado) {
                          itemsSkippedNoRadicado++; // Increment skip count
                          console.warn(`Row ${row.No_Orden} has Complementariedad template but no Radicado. Skipping.`);
                      }
                      return hasComplementariedadTemplate && hasRadicado; // Must meet both to be included in itemsToSend
                  });

              // Notify about skips due to missing Radicado *before* checking if any items are left to send
              if (itemsSkippedNoRadicado > 0) {
                  showNotification(`${itemsSkippedNoRadicado} caso(s) seleccionado(s) con plantilla 'Complementariedad' omitido(s) por falta de Radicado.`, 'warning', 7000);
              }

              if (itemsToSend.length === 0) {
                  // Adjust message if skips already occurred
                  const mainMsg = itemsSkippedNoRadicado > 0
                      ? "Ning√∫n otro √≠tem seleccionado cumpli√≥ los criterios para enviar a seguimiento."
                      : "No hay √≠tems seleccionados que cumplan los criterios (Tipo 'COMPLEMENTARIEDAD' con 'Radicado') para enviar a seguimiento.";
                  showNotification(mainMsg, 'warning');
                  return;
              }

              console.log(`${itemsToSend.length} items meet criteria for tracking.`);

              setState(prev => {
                 const currentTrackingData = Array.isArray(prev.trackingData) ? prev.trackingData : [];
                 let newTrackingData = [...currentTrackingData];
                 let newFinalData = Array.isArray(prev.finalData) ? [...prev.finalData] : [];
                 let addedCount = 0;
                 let updatedCount = 0;
                 let skippedExistingCount = 0;
                 const itemsActuallyMovedKeys = new Set();

                 itemsToSend.forEach(item => {
                   const itemOrderKey = String(item.No_Orden);
                   const existingIndex = newTrackingData.findIndex(t => t && String(t.No_Orden) === itemOrderKey);

                   if (existingIndex !== -1) {
                      if (newTrackingData[existingIndex].Radicado !== item.Radicado_Comp) {
                         if (window.confirm(`El caso ${itemOrderKey} ya est√° en seguimiento con Radicado "${newTrackingData[existingIndex].Radicado}".\n¬øActualizar a "${item.Radicado_Comp}"?`)) {
                           newTrackingData[existingIndex] = { ...newTrackingData[existingIndex], Radicado: item.Radicado_Comp };
                           updatedCount++;
                           itemsActuallyMovedKeys.add(itemOrderKey);
                         } else { skippedExistingCount++; }
                      } else { skippedExistingCount++; console.log(`Skipping ${itemOrderKey}, already in tracking.`); }
                   } else {
                     newTrackingData.push({
                       Fecha_Ing: item.Fecha_Neg || new Date().toISOString().slice(0,10), No_Orden: item.No_Orden, Nombre: item.Nombre || '',
                       EPS: item.EPS || '', Radicado: item.Radicado_Comp, Estado: TRACKING_STATUSES[0], Notas: '',
                     });
                     addedCount++;
                     itemsActuallyMovedKeys.add(itemOrderKey);
                   }
                 });

                 newFinalData = newFinalData.filter(f => !(f && itemsActuallyMovedKeys.has(String(f.No_Orden))));

                 let summaryMessage = "";
                 if (addedCount > 0) summaryMessage += `${addedCount} nuevo(s) enviado(s). `;
                 if (updatedCount > 0) summaryMessage += `${updatedCount} actualizado(s). `;
                 if (skippedExistingCount > 0) summaryMessage += `${skippedExistingCount} omitido(s) (ya exist√≠an).`;

                 if(addedCount > 0 || updatedCount > 0){
                     showNotification(summaryMessage.trim(), 'success');
                     return { ...prev, trackingData: newTrackingData, finalData: newFinalData, editsCount: prev.editsCount + addedCount + updatedCount };
                 } else {
                     showNotification(summaryMessage.trim() || "No se realizaron cambios en Seguimiento.", 'info');
                     return { ...prev, finalData: newFinalData };
                 }
              });

          }, [state.templates, state.finalData, state.trackingData, showNotification]);


          // --- Export Area 3 Data for Mail Merge ---
          const exportForMailMerge = useCallback((dataToExport) => {
              // ... (exportForMailMerge logic remains the same as previous correct version) ...
                const currentData = Array.isArray(dataToExport) ? dataToExport : [];
                if (currentData.length === 0) {
                    showNotification("No hay datos en revisi√≥n (√Årea 3) para exportar.", "warning");
                    return;
                }
                console.log(`Exporting ${currentData.length} rows for mail merge.`);
                try {
                    const safeTemplates = Array.isArray(state.templates) ? state.templates : [];
                    const exportable = currentData.map(row => {
                        const templateName = safeTemplates.find(t => t.id === row?.Tipo_Carta)?.name || "NO_SELECCIONADA";
                        return { // Define exact columns and order for export
                           "Fecha": row?.Fecha_Neg || '', "Orden": row?.No_Orden || '', "Cedula": row?.No_Cedula || '',
                           "Nombre": row?.Nombre || '', "EPS": row?.EPS || '', "Programa": row?.Programa || '',
                           "Email": row?.Email || '', "Motivo": row?.Motivo_Negacion || '',
                           "Desc_PDF": row?.Descripcion_PDF || '', "Just_PDF": row?.Justificacion_PDF || '', "Fund_PDF": row?.Fundamento_Legal_PDF || '',
                           "Tipo_Carta_Seleccionada": templateName, "Radicado_Complementariedad": row?.Radicado_Comp || ''
                           // Add other specific columns if needed, e.g., row?.Telefono, row?.Celular
                        };
                    });
                    const ws = XLSX.utils.json_to_sheet(exportable);
                    const wb = XLSX.utils.book_new();
                    XLSX.utils.book_append_sheet(wb, ws, "DatosParaEnvio");
                    XLSX.writeFile(wb, `Sigweb_Procesado_MailMerge_${new Date().toISOString().slice(0, 10)}.xlsx`);
                    showNotification("Archivo para Env√≠o Masivo generado.", "success");
                } catch (error) {
                     console.error("Error exporting for mail merge:", error);
                     showNotification("Error al generar el archivo para env√≠o masivo.", "error");
                }
          }, [state.templates, showNotification]);


          // --- Update Row in Area 4 (Tracking/Archived) ---
          const updateTrackingData = useCallback((index, updatedRow, isArchived) => {
              // ... (updateTrackingData logic remains the same as previous correct version) ...
                if (typeof index !== 'number' || index < 0) {
                   console.error("Invalid index provided to updateTrackingData:", index); return;
                }
              const dataKey = isArchived ? 'archivedData' : 'trackingData';
              setState(prev => {
                 const currentData = Array.isArray(prev[dataKey]) ? prev[dataKey] : [];
                 if(index < currentData.length) {
                     const newData = [...currentData]; // Create a copy
                     newData[index] = updatedRow; // Assign the updated row object
                     console.log(`Updated item at index ${index} in ${dataKey}`);
                     const newEditsCount = prev.isSaving ? prev.editsCount : prev.editsCount + 1;
                     return { ...prev, [dataKey]: newData, editsCount: newEditsCount };
                 } else {
                     console.error(`Index ${index} out of bounds for ${dataKey}`); return prev;
                 }
              });
          }, []);


          // --- Archive/Unarchive Items in Area 4 ---
          const archiveItems = useCallback((indicesToMove, fromArchived) => {
              // ... (archiveItems logic remains the same as previous correct version) ...
                if (!Array.isArray(indicesToMove) || indicesToMove.some(isNaN) || indicesToMove.length === 0){
                   console.warn("Invalid or empty indices provided to archiveItems:", indicesToMove); return;
                }
                console.log(`${fromArchived ? 'Unarchiving' : 'Archiving'} indices:`, indicesToMove);
              const sourceKey = fromArchived ? 'archivedData' : 'trackingData';
              const targetKey = fromArchived ? 'trackingData' : 'archivedData';

              setState(prev => {
                 const sourceData = Array.isArray(prev[sourceKey]) ? prev[sourceKey] : [];
                 const targetData = Array.isArray(prev[targetKey]) ? [...prev[targetKey]] : [];
                 const itemsToMove = [];
                 const remainingSourceIndices = new Set(sourceData.map((_, i) => i)); // Start with all indices

                 indicesToMove.forEach(index => {
                    if(index >= 0 && index < sourceData.length && sourceData[index]){
                       itemsToMove.push(sourceData[index]);
                       remainingSourceIndices.delete(index); // Remove moved index
                    }
                 });

                 if (itemsToMove.length === 0) { console.warn("No valid items found for moving."); return prev; }

                 const newSourceData = Array.from(remainingSourceIndices).map(index => sourceData[index]); // Build new source array
                 const newTargetData = [...targetData, ...itemsToMove]; // Append moved items

                 console.log(`Moving ${itemsToMove.length} items from ${sourceKey} to ${targetKey}.`);

                 return {
                   ...prev,
                   [sourceKey]: newSourceData,
                   [targetKey]: newTargetData,
                   editsCount: prev.isSaving ? prev.editsCount : prev.editsCount + itemsToMove.length
                 };
              });
          }, []);


          // --- Template Management Callbacks ---
          const handleSaveTemplates = useCallback((newTemplates) => {
            const templatesToSave = Array.isArray(newTemplates) ? newTemplates : defaultTemplates;
            setState(prev => ({ ...prev, templates: templatesToSave }));
            saveTemplates(templatesToSave);
            showNotification('Plantillas guardadas.', 'success');
          }, [showNotification]);

          const handleResetTemplates = useCallback(() => {
            if (window.confirm('¬øRestaurar plantillas predeterminadas? Se perder√°n las personalizadas.')) {
              handleSaveTemplates([...defaultTemplates]);
            }
          }, [handleSaveTemplates]);

          // --- Memoized Sorted Data for Review Area ---
          const sortedFinalData = useMemo(() => {
            let sortableItems = Array.isArray(state.finalData) ? [...state.finalData] : [];
            if (sortConfig.key) {
                sortableItems.sort((a, b) => {
                    if (!a || !b) return 0;
                    const aVal = a[sortConfig.key] ?? '';
                    const bVal = b[sortConfig.key] ?? '';
                    // Attempt numeric sort for No_Orden, fallback to localeCompare
                    if (sortConfig.key === 'No_Orden') {
                       const numA = parseInt(aVal, 10);
                       const numB = parseInt(bVal, 10);
                       if (!isNaN(numA) && !isNaN(numB)) {
                          const comparison = numA - numB;
                          return sortConfig.direction === 'ascending' ? comparison : -comparison;
                       }
                    }
                    // LocaleCompare for other columns
                    const comparison = String(aVal).localeCompare(String(bVal), undefined, { numeric: true, sensitivity: 'base' });
                    return sortConfig.direction === 'ascending' ? comparison : -comparison;
                });
            }
            return sortableItems;
          }, [state.finalData, sortConfig]);

          // --- Close Setup Modal Callback ---
           const handleCloseSetupModal = useCallback(() => {
                if (!state.isSetupNeeded || state.scriptUrl) {
                    setState(prev => ({ ...prev, isReconfiguring: false }));
                } else {
                    alert("Debes configurar y verificar la URL del script para poder usar la aplicaci√≥n.");
                }
           }, [state.isSetupNeeded, state.scriptUrl]);


          // ================== Render Logic ==================

          if (state.isLoading && !state.isSetupNeeded) {
            return <div className="fixed inset-0 bg-background/90 flex items-center justify-center z-[300]"><Spinner /> <span className="ml-4 text-xl">Cargando Datos Iniciales...</span></div>;
          }

          if (state.isSetupNeeded || state.isReconfiguring) {
            return <SetupModal
                onSave={handleSetScriptUrl}
                onClose={handleCloseSetupModal}
                initialUrl={state.scriptUrl || ''}
             />;
          }

          return (
            <div className="p-3 sm:p-6 bg-background min-h-screen text-sm"> {/* Smaller base padding/text */}
              {state.notification && (
                <Notification
                  message={state.notification.message}
                  type={state.notification.type}
                  onClose={hideNotification}
                />
              )}
              {!state.onlineStatus && (
                   <div className="bg-yellow-500 text-black text-center p-2 fixed top-0 left-0 w-full z-[100] shadow font-semibold">
                    ‚ö† Est√°s desconectado. El guardado en la nube est√° deshabilitado.
                   </div>
              )}

              <main className={`max-w-screen-2xl mx-auto bg-surface p-4 sm:p-5 rounded-xl border border-border-color space-y-6 ${!state.onlineStatus ? 'pt-12 sm:pt-14' : ''}`}> {/* Adjusted padding */}
                <Header
                    onSave={handleSave}
                    onManageTemplates={() => setState(prev => ({ ...prev, isTemplateManagerOpen: true }))}
                    onReconfigure={() => setState(prev => ({ ...prev, isReconfiguring: true }))}
                />
                <Dashboard
                  reviewCount={Array.isArray(state.finalData) ? state.finalData.length : 0}
                  trackingCount={Array.isArray(state.trackingData) ? state.trackingData.length : 0}
                  archivedCount={Array.isArray(state.archivedData) ? state.archivedData.length : 0}
                  editsCount={state.editsCount}
                />
                <div className="text-right">
                       <button
                           onClick={() => exportDetailedReport(state.finalData, state.trackingData, state.archivedData)}
                           className="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-3 rounded-lg transition-colors text-xs sm:text-sm" // Adjusted style
                       >
                           Descargar Reporte Excel
                       </button>
                </div>

                <div className="grid grid-cols-1 lg:grid-cols-2 gap-6"> {/* Adjusted gap */}
                  <DataInputArea
                    id="portal-area"
                    title="√Årea 1: Cargar Excel del Portal"
                    headers={PORTAL_HEADERS}
                    data={state.portalData}
                    onDataChange={(newData) => setState(prev => ({ ...prev, portalData: newData }))}
                    onProcess={processPortalData}
                    processButtonText="Procesar y A√±adir a Revisi√≥n"
                    inputType="file"
                  />
                  <DataInputArea
                    id="pdf-area"
                    title="√Årea 2: Pegar Datos del Extractor PDF"
                    headers={PDF_HEADERS}
                    data={state.pdfData}
                    onDataChange={(newData) => setState(prev => ({ ...prev, pdfData: newData }))}
                    onProcess={mergePdfData}
                    processButtonText="Combinar PDF con Revisi√≥n"
                    inputType="paste"
                  />
                </div>
                <ReviewArea
                  data={sortedFinalData}
                  templates={state.templates}
                  updateRow={updateFinalDataRow}
                  incrementEdits={incrementEdits} // Pass it down, even if called internally elsewhere
                  onSendToTracking={handleSendToTracking}
                  onPreview={(row) => setState(prev => ({ ...prev, previewData: row }))}
                  onExportForMailMerge={exportForMailMerge}
                  onClearReviewData={handleClearReviewData}
                  sortConfig={sortConfig}
                  setSortConfig={setSortConfig}
                />
                <TrackingArea
                  trackingData={state.trackingData}
                  archivedData={state.archivedData}
                  updateTrackingData={updateTrackingData} // Pass the correct callback
                  archiveItems={archiveItems}
                />

                {state.isSaving && <div className="fixed inset-0 bg-background/80 flex items-center justify-center z-[300]"><Spinner /> <span className="ml-4 text-lg">Guardando Datos...</span></div>} {/* Adjusted style */}
              </main>

              {state.isTemplateManagerOpen && (
                <TemplateManagerModal
                  templates={state.templates}
                  onClose={() => setState(prev => ({...prev, isTemplateManagerOpen: false}))}
                  onSave={handleSaveTemplates}
                  onReset={handleResetTemplates}
                />
              )}
              {state.previewData && (
                <PreviewModal
                  data={state.previewData}
                  template={Array.isArray(state.templates) ? state.templates.find(t => t.id === state.previewData?.Tipo_Carta) : null}
                  onClose={() => setState(prev => ({...prev, previewData: null}))}
                />
              )}
            </div>
          );
        };

        // =================================================================================
        // INLINED: index.tsx (Render the application)
        // =================================================================================
        const rootElement = document.getElementById('root');
        if (!rootElement) {
          console.error("Fatal Error: Root element 'root' not found in HTML.");
          document.body.innerHTML = '<div style="color: red; padding: 20px; font-family: sans-serif; background-color: #333; text-align: center;"><h1>Error Cr√≠tico</h1><p>No se encontr√≥ el elemento ra√≠z de la aplicaci√≥n (#root).<br>Verifica que el archivo HTML incluya <code style="background: #555; padding: 2px 4px; border-radius: 3px;">&lt;div id="root"&gt;&lt;/div&gt;</code> en el body.</p></div>';
        } else {
            try {
               const root = ReactDOM.createRoot(rootElement);
               root.render(<App />); // Render without StrictMode to avoid potential double fetch on mount in dev
            } catch(error) {
                console.error("Error rendering React application:", error);
                 rootElement.innerHTML = `<div style="color: orange; padding: 20px; font-family: sans-serif; background-color: #333;"><h1>Error Cr√≠tico al Iniciar React</h1><pre style="white-space: pre-wrap; word-wrap: break-word;">${error.stack || error.message}</pre></div>`;
            }
        }

    </script>
</body>
</html>
