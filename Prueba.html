<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <meta http-equiv="Content-Security-Policy" 
        content="default-src 'self' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://unpkg.com https://esm.sh; script-src 'self' 'unsafe-eval' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://unpkg.com https://esm.sh;">

  <title>GESTION NEGACIONES EJE CAFETERO</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script>
     // Tailwind config...
  </script>
  <script type="importmap">
     // Import map...
  </script>
</head>
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GESTION NEGACIONES EJE CAFETERO</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script>
      // Tailwind CSS Configuration
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'primary': '#4e9fef',
              'background': '#1e1e1e',
              'surface': '#2d2d2d',
              'text-primary': '#d4d4d4',
              'text-secondary': '#a0a0a0',
              'border-color': '#444',
              'header': '#3a3a3a',
              'highlight': '#252526',
              'warning': '#6e550c',
              'archive': '#3a3a3a',
              'success': '#28a745',
              'danger': '#a02d2d',
              'danger-hover': '#c0392b',
              'btn-primary': '#0e639c',
              'btn-primary-hover': '#1a73e8',
            },
            animation: {
              'flash-success': 'flash-success 1s ease-out',
            },
            keyframes: {
              'flash-success': {
                'from': { backgroundColor: '#28a745' },
                'to': { backgroundColor: 'transparent' },
              }
            }
          }
        }
      }
    </script>
    
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client"
      }
    }
    </script>
</head>
    
<body class="bg-background text-text-primary">
    <div id="root"></div>

    <script type="text/babel" data-presets="react" data-type="module">
        import React, { useState, useEffect, useCallback, useMemo } from 'react';
        import ReactDOM from 'react-dom/client';

        // =================================================================================
        // INLINED: constants.ts
        // =================================================================================
        const PORTAL_HEADERS = [
            "Fecha_Neg", "Sucursal", "No_Orden", "No_Cedula", "Nombre", "Entidad_Ejecutora",
            "Motivo_Negacion", "Usuario_Emitio", "Auditor", "Observacion_Auditor", "Observacion_Ejecutivo",
            "Programa", "Plan", "Antiguedad", "EPS", "Telefono", "Celular", "Direccion", "Email", "Edad",
            "Tipo_Usuario", "Llamada", "Complementariedad", "Notificacion", "Gestion_Negacion", "Alternativa",
            "Observacion_Alternativa", "Monto", "Nit_Prestador", "Fecha_Complementariedad", "Tiempo_de_Gestion", "Regional"
        ];

        const PDF_HEADERS = [
          "Archivo (No. Orden)", "Descripci√≥n", "Justificaci√≥n", "Fundamento Legal", "C√≥digo"
        ];

        const TRACKING_STATUSES = ['Pendiente', 'En Gesti√≥n', 'Finalizado'];
        
        const COMMON_EMAIL_BODY = `<br><br><b>Si tiene alguna duda puede contactarse por medio de los canales que tenemos disponibles para usted:</b><br>¬∑ Nuestra l√≠nea nacional 018000931666. O con nuestras l√≠neas locales: Cali (602) 489 0073, Bogot√° (601) 743 5485, Medell√≠n (604) 604 4507, Barranquilla (605) 385 3165, Bucaramanga (607) 697 3350, Cartagena (605) 693 9853, Tulu√° (602) 235 9483, Valledupar (605)588 5699, Pereira (606) 340 2635.<br>¬∑ WhatsApp: 317-224-07-94<br><br>Gracias por su Atenci√≥n.`;
        const SIGNATURE = `<br><br>Cordialmente,<br><br><b>Juan Ricardo Morales Agudelo</b><br>Ejecutivo De Atenci√≥n Integral<br>Coomeva Medicina Prepagada<br>Cra. 13 No.11-12 Centro M√©dico Circunvalar<br>Coomeva Medicina Prepagada Pereira, Risaralda<br><br><i>Este correo es generado autom√°ticamente, por favor no responda este mensaje.</i>`;

        const defaultTemplates = [
            { id: 'tpl_neg_gen', name: 'PLANTILLA NEGACION GENERAL', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar informaci√≥n acerca del servicio {{Motivo_Negacion}} que en esta oportunidad no est√° aprobado debido a que corresponde a EXCLUSI√ìN ({{Descripcion_PDF}}), ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>El servicio negado anteriormente; debe tramitarlo a trav√©s su EPS asignada. Adjuntamos soporte de la carta de negaci√≥n.` },
            { id: 'tpl_neg_pert', name: 'PLANTILLA NO PERTINENCIA Y TEMAS ESTETICOS', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar informaci√≥n acerca del servicio {{Motivo_Negacion}} que en esta oportunidad No est√° aprobado debido a que corresponde a NO PERTINENCIA ({{Descripcion_PDF}}), ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>` },
            { id: 'tpl_comp_coinc', name: 'COMPLEMENTARIEDAD RED COINCIDENTE', body: `Apreciado Usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y el de su familia. Por medio de este correo queremos brindar informaci√≥n acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no fue aprobado, debido a que ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>Sin embargo, est√° en gesti√≥n a trav√©s de su EPS ({{EPS}}) con el n√∫mero de radicado ({{Radicado_Comp}}), puede realizar seguimiento mediante la oficina virtual de la EPS ({{Oficina_Virtual_EPS}}).<br><br>Adicional estaremos haciendo seguimiento al radicado y una vez se encuentre gestionado por la EPS, le notificaremos por medio de correo electr√≥nico.` },
            { id: 'tpl_comp_no_coinc', name: 'COMPLEMENTARIEDAD RED NO COINCIDENTE', body: `Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar informaci√≥n acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no est√° aprobado, debido a que corresponde a ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>El prestador actual solicitado, no tiene convenio con la EPS, por lo que los costos adicionales del servicio o insumo estar√°n a cargo del paciente. Sin embargo; se radica la solicitud ante su EPS con el n√∫mero ({{Radicado_Comp}}) por favor realizar seguimiento mediante la oficina virtual de la EPS ({{Oficina_Virtual_EPS}}).` },
            { id: 'tpl_comp_ayudas', name: 'COMPLEMENTARIEDAD AYUDAS DIAGNOSTICAS', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar informaci√≥n acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no est√° aprobado debido a que corresponde a ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>Sin embargo, se encuentra en gesti√≥n a trav√©s de su EPS con el n√∫mero de radicado ({{Radicado_Comp}}), por favor realizar seguimiento mediante la oficina virtual. ({{Oficina_Virtual_EPS}}).` },
        ];


        // =================================================================================
        // INLINED: services/utilityService.ts
        // =================================================================================
        const capitalizeWords = (str) => {
          if (!str) return '';
          return str.toLowerCase().replace(/\b\w/g, char => char.toUpperCase());
        };

        const processPastedData = (pastedText, headers) => {
          return pastedText
            .trim()
            .split(/\r?\n/)
            .map(rowText => {
              const cells = rowText.split('\t');
              const rowObject = {};
              headers.forEach((header, index) => {
                if (cells[index]) {
                  rowObject[header] = cells[index].trim();
                }
              });
              return rowObject;
            });
        };

        const replacePlaceholders = (templateBody, data) => {
          const getOficinaVirtual = (eps) => {
            const e = (eps || "").toUpperCase();
            if (e.includes("NUEVA EPS")) return `<a href='https://portal.nuevaeps.com.co/Portal/home.jspx' target='_blank' rel='noopener noreferrer'>NUEVA EPS</a>`;
            if (e.includes("SALUD TOTAL")) return `<a href='https://saludtotal.com.co/' target='_blank' rel='noopener noreferrer'>SALUD TOTAL</a>`;
            return eps;
          };

          const fullData = { ...data, Oficina_Virtual_EPS: getOficinaVirtual(data.EPS) };

          return templateBody.replace(/\{\{(\w+)\}\}/g, (match, key) => {
            // Ensure data[key] exists and is not null/undefined before returning
            return fullData[key] !== null && fullData[key] !== undefined ? fullData[key] : match;
          });
        };

        const exportDetailedReport = (finalData, trackingData, archivedData) => {
          try {
            const masterDataMap = new Map();

            [...finalData, ...trackingData, ...archivedData].forEach(row => {
              if (row && row.No_Orden) { // Added check for row existence
                const key = String(row.No_Orden).trim(); // Ensure key is a string
                if (key) { // Ensure key is not empty
                    const existing = masterDataMap.get(key) || {};
                    masterDataMap.set(key, { ...existing, ...row });
                }
              }
            });
            
            const masterData = Array.from(masterDataMap.values());

            if (masterData.length === 0) {
              alert("No hay datos consolidados para exportar.");
              return;
            }

            const wb = XLSX.utils.book_new();
            
            // Add sheets only if data exists
            if (finalData.length > 0) {
              const ws1 = XLSX.utils.json_to_sheet(finalData);
              XLSX.utils.book_append_sheet(wb, ws1, "Casos en Revisi√≥n");
            }
            
            if (trackingData.length > 0) {
              const ws2 = XLSX.utils.json_to_sheet(trackingData);
              XLSX.utils.book_append_sheet(wb, ws2, "Seguimiento Activo");
            }

            if (archivedData.length > 0) {
              const ws3 = XLSX.utils.json_to_sheet(archivedData);
              XLSX.utils.book_append_sheet(wb, ws3, "Seguimiento Archivado");
            }
            
            // Always add Maestro Consolidado if masterData exists
            const ws4 = XLSX.utils.json_to_sheet(masterData);
            XLSX.utils.book_append_sheet(wb, ws4, "Maestro Consolidado");

            XLSX.writeFile(wb, `Sigweb_Reporte_Detallado_${new Date().toISOString().slice(0, 10)}.xlsx`);
          } catch (error) {
            console.error("Fall√≥ la exportaci√≥n del reporte Excel:", error);
            alert("Ocurri√≥ un error al generar el reporte detallado.");
          }
        };

        // =================================================================================
        // INLINED: services/templateService.ts
        // =================================================================================
        const TEMPLATE_STORAGE_KEY = 'sigweb_emailTemplates';

        const loadTemplates = () => {
          try {
            const storedTemplates = localStorage.getItem(TEMPLATE_STORAGE_KEY);
            if (storedTemplates) {
              const parsed = JSON.parse(storedTemplates);
              if (Array.isArray(parsed) && parsed.length > 0 && parsed[0].id && parsed[0].name) {
                return parsed;
              }
            }
          } catch (error) {
            console.error("Fall√≥ la carga de plantillas desde localStorage, se usar√°n las predeterminadas.", error);
            localStorage.removeItem(TEMPLATE_STORAGE_KEY);
          }
          return defaultTemplates;
        };

        const saveTemplates = (templates) => {
          try {
            localStorage.setItem(TEMPLATE_STORAGE_KEY, JSON.stringify(templates));
          } catch (error) {
            console.error("Fall√≥ el guardado de plantillas en localStorage", error);
          }
        };


        // =================================================================================
        // INLINED: services/googleSheetService.ts
        // =================================================================================
        const fetchData = async (url) => {
            console.log("Fetching data from:", url); // Debug log
            const response = await fetch(`${url}?action=getData`);
            console.log("Fetch response status:", response.status); // Debug log
            if (!response.ok) {
                const errorText = await response.text();
                console.error("Network response was not ok:", errorText); // Debug log
                throw new Error(`La respuesta de la red no fue correcta: ${response.statusText} - ${errorText}`);
            }
            const data = await response.json();
            console.log("Fetched data:", data); // Debug log
            return {
                finalData: data.finalData || [],
                trackingData: data.trackingData || [],
                archivedData: data.archivedData || [],
                masterTrackingOrders: data.masterTrackingOrders || [],
            };
        };

        const saveData = async (url, requestBody) => {
            console.log("Saving data to:", url); // Debug log
            console.log("Save request body:", JSON.stringify(requestBody)); // Debug log
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    mode: 'no-cors', 
                    headers: {
                        'Content-Type': 'text/plain', // Required for no-cors with Apps Script text payload
                    },
                    body: JSON.stringify(requestBody), // Send the whole object including action and payload
                });
                // In no-cors mode, we CANNOT read the response status or body. 
                // We assume success if no network error is thrown.
                console.log("Save request sent (no-cors). Assuming success."); // Debug log
                return { status: 'success', message: 'Datos enviados al servidor (no-cors).' };
            } catch (error) {
                console.error("Error during save fetch:", error); // Debug log
                throw error; // Re-throw the error to be caught by handleSave
            }
        };


        // =================================================================================
        // INLINED: components/Spinner.tsx
        // =================================================================================
        const Spinner = () => {
          return (
            <div
              className="inline-block h-8 w-8 animate-spin rounded-full border-4 border-solid border-primary border-r-transparent align-[-0.125em] motion-reduce:animate-[spin_1.5s_linear_infinite]"
              role="status"
            >
              <span className="!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]">
                Cargando...
              </span>
            </div>
          );
        };


        // =================================================================================
        // INLINED: components/Notification.tsx
        // =================================================================================
        const Notification = ({ message, type, onClose }) => {
          const typeClasses = {
            success: 'bg-green-600',
            error: 'bg-red-600',
            warning: 'bg-yellow-500',
            info: 'bg-blue-600',
          };
          // Automatically close after a delay if onClose is provided
          useEffect(() => {
            if (onClose) {
              const timer = setTimeout(() => {
                onClose();
              }, 5000); // Default 5 seconds
              return () => clearTimeout(timer);
            }
          }, [onClose]);

          return (
            <div className={`fixed top-5 right-5 z-[100] p-4 rounded-lg shadow-lg text-white ${typeClasses[type]} flex items-center gap-4`}>
              <span>{message}</span>
              {onClose && <button onClick={onClose} className="text-xl font-bold">&times;</button>}
            </div>
          );
        };

        // =================================================================================
        // INLINED: components/Header.tsx
        // =================================================================================
        const Header = ({ onSave, onManageTemplates, onReconfigure }) => {
          return (
            <header className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 pb-4 border-b border-border-color">
              <div>
                <h1 className="text-3xl font-bold text-white">
                  GESTION NEGACIONES EJE CAFETERO
                </h1>
                <p className="text-text-secondary">Sistema Integrado de Gesti√≥n de Flujos de Trabajo</p>
              </div>
              <div className="flex flex-wrap gap-2">
                <button onClick={onManageTemplates} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors">
                  Gestionar Plantillas
                </button>
                <button onClick={onReconfigure} className="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg transition-colors flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0L8.21 5.15a1.5 1.5 0 01-1.25.82l-2.09.28c-1.68.23-2.34 2.26-1.09 3.42l1.52 1.48a1.5 1.5 0 01-.42 2.1l-1.83 1.25c-1.38.94-.92 3.01.7 3.42l2.05.51a1.5 1.5 0 011.1.98l.8 2.07c.43 1.12 2.29 1.12 2.72 0l.8-2.07a1.5 1.5 0 011.1-.98l2.05-.51c1.62-.4 2.08-2.48.7-3.42l-1.83-1.25a1.5 1.5 0 01-.42-2.1l1.52-1.48c1.25-1.16.59-3.19-1.09-3.42L13 5.97a1.5 1.5 0 01-1.25-.82l-.3-1.98zM10 13a3 3 0 100-6 3 3 0 000 6z" clipRule="evenodd" />
                    </svg>
                    Reconfigurar Conexi√≥n
                </button>
                <button onClick={onSave} className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M5.5 16.5a2.5 2.5 0 01-5 0V4.414a1.5 1.5 0 01.44-1.06L4.354.439A1.5 1.5 0 015.414 0H12.5a2.5 2.5 0 012.5 2.5v2" />
                        <path d="M5.5 16.5h8a2.5 2.5 0 002.5-2.5V8.5h-13v5.5a2.5 2.5 0 002.5 2.5z" />
                        <path d="M10.5 10a.5.5 0 01.5-.5h2a.5.5 0 010 1h-2a.5.5 0 01-.5-.5z" />
                    </svg>
                    Guardar en la Nube
                </button>
              </div>
            </header>
          );
        };
        

        // =================================================================================
        // INLINED: components/Dashboard.tsx
        // =================================================================================
        const DashboardCard = ({ title, value, icon }) => (
          <div className="bg-surface p-4 rounded-lg border border-border-color flex items-center">
            <div className="text-3xl text-primary mr-4">{icon}</div>
            <div>
              <h4 className="text-sm font-semibold text-text-secondary uppercase tracking-wider">{title}</h4>
              <p className="text-2xl font-bold text-text-primary">{value}</p>
            </div>
          </div>
        );

        const Dashboard = ({ reviewCount, trackingCount, archivedCount, editsCount }) => (
          <section id="dashboard" className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
            <DashboardCard title="Casos en Revisi√≥n" value={reviewCount} icon={'üìã'} />
            <DashboardCard title="Seguimiento Activo" value={trackingCount} icon={'‚è≥'} />
            <DashboardCard title="Casos Archivados" value={archivedCount} icon={'üóÑÔ∏è'} />
            <DashboardCard title="Ediciones en Sesi√≥n" value={editsCount} icon={'‚úèÔ∏è'} />
          </section>
        );


        // =================================================================================
        // INLINED: components/DataInputArea.tsx
        // =================================================================================
        function DataInputArea({
          id,
          title,
          headers,
          data,
          onDataChange,
          onProcess,
          processButtonText = "Procesar Datos",
          inputType = "paste", // "paste" or "file"
        }) {
          
          const handlePaste = useCallback((e) => {
            e.preventDefault();
            const pastedText = e.clipboardData.getData('text/plain');
            const newRows = processPastedData(pastedText, headers);

            // Ensure data is always an array before filtering
            const currentData = Array.isArray(data) ? data : [];
            const updatedData = [...currentData.filter(row => Object.values(row).some(val => val)), ...newRows];
            
            // Add empty rows only if it's the paste input type
            if (inputType === 'paste') {
                const emptyRowCount = updatedData.filter(row => !Object.values(row).some(val => val)).length;
                if (emptyRowCount < 5) {
                    for (let i = 0; i < (5 - emptyRowCount); i++) {
                        updatedData.push({});
                    }
                }
            }

            onDataChange(updatedData);
          }, [data, headers, onDataChange, inputType]);

          const handleCellChange = (rowIndex, header, value) => {
             // Ensure data is always an array
            const currentData = Array.isArray(data) ? data : [];
            const newData = [...currentData];
            // Ensure the row exists before trying to update it
            if(newData[rowIndex]){
                newData[rowIndex] = { ...newData[rowIndex], [header]: value };
            } else {
                 // Optionally handle cases where rowIndex might be out of bounds, though less likely with current logic
                 console.warn(`Attempted to edit non-existent row at index ${rowIndex}`);
                 return; // Prevent further processing if row doesn't exist
            }
            
            // Add empty rows only if it's the paste input type
             if (inputType === 'paste') {
                const emptyRowCount = newData.filter(row => !Object.values(row).some(val => val)).length;
                if (emptyRowCount < 5) {
                    newData.push({});
                }
            }

            onDataChange(newData);
          };
          
          const handleFileChange = (e) => {
              const file = e.target.files[0];
              if (!file) return;

              const reader = new FileReader();
              reader.onload = (event) => {
                  try {
                      const fileData = new Uint8Array(event.target.result);
                      const workbook = XLSX.read(fileData, { type: 'array', cellDates: true });
                      const sheetName = workbook.SheetNames[0];
                      const worksheet = workbook.Sheets[sheetName];
                      // Use header: 1 to get header row, raw: false for formatted values, defval: '' for empty cells
                      const json_data = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: false, defval: '' });

                      if (json_data.length < 2) {
                          alert("El archivo Excel parece estar vac√≠o o no tiene encabezados.");
                          return;
                      }

                      const excelHeaders = json_data[0].map(h => String(h).trim()); // Get headers from the first row
                      const jsonDataObjects = XLSX.utils.sheet_to_json(worksheet, { raw: false, defval: '' }); // Convert rest to objects

                      const normalizeHeaders = (d) => {
                           // Keep your existing keyMap for normalization
                          const keyMap = {
                              'Fecha Neg.': 'Fecha_Neg', 'No. Orden': 'No_Orden', 'No. C√©dula': 'No_Cedula',
                              'Entidad Ejecutora': 'Entidad_Ejecutora', 'Motivo Negaci√≥n': 'Motivo_Negacion',
                              'Usuario Emiti√≥': 'Usuario_Emitio', 'Observaci√≥n Auditor': 'Observacion_Auditor',
                              'Observaci√≥n Ejecutivo': 'Observacion_Ejecutivo', 'Antig√ºedad': 'Antiguedad',
                              'Tel√©fono': 'Telefono', 'Direcci√≥n': 'Direccion', 'Tipo Usuario': 'Tipo_Usuario',
                              'Notificaci√≥n': 'Notificacion', 'Gesti√≥n': 'Gestion_Negacion',
                              'Observaci√≥n Alternativa': 'Observacion_Alternativa', 'Nit Prestador': 'Nit_Prestador',
                              'Fecha Complementariedad': 'Fecha_Complementariedad', 'Tiempo de Gestion': 'Tiempo_de_Gestion'
                          };
                           // Map Excel dates (assuming they are serial numbers or specific string formats)
                          const excelDateToJSDate = (serialOrString) => {
                              if (typeof serialOrString === 'number') {
                                  // Handle Excel serial date number
                                  const utc_days = Math.floor(serialOrString - 25569);
                                  const utc_value = utc_days * 86400;                                     
                                  const date_info = new Date(utc_value * 1000);
                                  // Adjust for timezone offset
                                  const fractional_day = serialOrString - Math.floor(serialOrString) + 0.0000001;
                                  let total_seconds = Math.floor(86400 * fractional_day);
                                  const seconds = total_seconds % 60;
                                  total_seconds -= seconds;
                                  const hours = Math.floor(total_seconds / (60 * 60));
                                  const minutes = Math.floor(total_seconds / 60) % 60;
                                  
                                  // Create date object adjusted for local timezone
                                  return new Date(date_info.getFullYear(), date_info.getMonth(), date_info.getDate(), hours, minutes, seconds);

                              } else if (typeof serialOrString === 'string') {
                                  // Attempt to parse common string date formats if necessary
                                  // Example: Adjust if your Excel dates are like 'DD/MM/YYYY'
                                  // const parts = serialOrString.match(/(\d{1,2})[/|-](\d{1,2})[/|-](\d{4})/);
                                  // if (parts) return new Date(parts[3], parts[2] - 1, parts[1]);
                                  
                                  // For ISO-like strings or directly parsable formats
                                  const parsedDate = new Date(serialOrString);
                                  if (!isNaN(parsedDate)) return parsedDate;
                              }
                              return null; // Return null if conversion fails
                          };

                          return d.map(row => {
                              const newRow = {};
                              for (const key in row) {
                                  const trimmedKey = String(key).trim(); // Ensure key is trimmed string
                                  const newKey = keyMap[trimmedKey] || trimmedKey.replace(/ /g, '_'); // Normalize or replace spaces
                                  
                                  // Check if the key indicates a date column
                                  const isDateColumn = ['Fecha_Neg', 'Fecha_Complementariedad'].includes(newKey); // Add other date columns if needed

                                  if (isDateColumn) {
                                      const jsDate = excelDateToJSDate(row[key]);
                                      if (jsDate && !isNaN(jsDate)) {
                                          // Format as YYYY-MM-DD
                                          newRow[newKey] = jsDate.toISOString().slice(0, 10);
                                      } else {
                                          newRow[newKey] = ''; // Assign empty string if date conversion failed
                                          console.warn(`Could not parse date for column ${newKey}:`, row[key]);
                                      }
                                  } else {
                                      // Assign value directly for non-date columns, ensuring it's a string
                                      newRow[newKey] = row[key] !== null && row[key] !== undefined ? String(row[key]) : '';
                                  }
                              }
                              // Ensure all PORTAL_HEADERS are present, even if empty
                              PORTAL_HEADERS.forEach(header => {
                                  if (!(header in newRow)) {
                                      newRow[header] = '';
                                  }
                              });
                              return newRow;
                          });
                      };

                      const normalizedData = normalizeHeaders(jsonDataObjects);
                      onDataChange(normalizedData);
                      e.target.value = null; 
                  } catch (error) {
                      console.error("Error processing Excel file:", error);
                      alert("Hubo un error al procesar el archivo Excel. Aseg√∫rate de que el formato y las columnas son correctos.");
                      onDataChange([]); // Clear data on error
                  }
              };
              reader.onerror = (error) => {
                   console.error("Error reading file:", error);
                   alert("Hubo un error al leer el archivo.");
                   onDataChange([]); // Clear data on error
              };
              reader.readAsArrayBuffer(file);
          };

          const clearTable = () => {
            onDataChange(inputType === 'paste' ? Array(5).fill({}) : []);
          }
          
          // Ensure 'data' is always an array for rendering
          const renderData = Array.isArray(data) ? data : (inputType === 'paste' ? Array(5).fill({}) : []);


          return (
            <section id={id} className="space-y-4">
              <h2 className="text-2xl font-bold text-primary border-b border-border-color pb-2">{title}</h2>
              
              {inputType === 'file' && (
                 <div className="flex items-center gap-4">
                    <label htmlFor={`${id}-file-upload`} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors cursor-pointer">
                        Subir Archivo Excel
                    </label>
                    <input 
                        id={`${id}-file-upload`}
                        type="file"
                        className="hidden"
                        accept=".xlsx, .xls, .csv" // Added CSV support
                        onChange={handleFileChange}
                    />
                    <span className="text-text-secondary">{renderData.length > 0 ? `${renderData.length} fila(s) cargada(s)` : 'Ning√∫n archivo seleccionado'}</span>
                </div>
              )}

              <div className="table-container max-h-72 overflow-auto border border-border-color rounded-lg">
                <table className="w-full text-sm text-left text-text-secondary">
                  <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                    <tr>
                      {headers.map(header => (
                        <th key={header} scope="col" className="px-4 py-3 whitespace-nowrap">{header.replace(/_/g, ' ')}</th>
                      ))}
                    </tr>
                  </thead>
                   {/* Add check to ensure renderData is an array before mapping */}
                  <tbody onPaste={inputType === 'paste' ? handlePaste : undefined}>
                    {Array.isArray(renderData) && renderData.map((row, rowIndex) => (
                      <tr key={rowIndex} className="border-b border-border-color hover:bg-highlight">
                        {headers.map(header => (
                          <td
                            key={`${rowIndex}-${header}`}
                            className="px-4 py-2 border-r border-border-color focus:bg-primary focus:text-black outline-none"
                            contentEditable={inputType === 'paste'}
                            onBlur={inputType === 'paste' ? (e) => handleCellChange(rowIndex, header, e.currentTarget.innerText) : undefined}
                            suppressContentEditableWarning={true}
                          >
                            {/* Ensure row is an object and header exists before accessing */}
                            {(typeof row === 'object' && row !== null && row[header] !== undefined) ? String(row[header]) : ''}
                          </td>
                        ))}
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
              <div className="flex gap-4">
                <button 
                    onClick={onProcess} 
                    disabled={renderData.length === 0 || (inputType === 'paste' && renderData.every(row => !Object.values(row).some(val => val)))} // Disable if no data
                    className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed"
                 >
                  {processButtonText}
                </button>
                <button onClick={clearTable} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                  Limpiar Tabla
                </button>
              </div>
            </section>
          );
        }

        // =================================================================================
        // INLINED: components/ReviewArea.tsx
        // =================================================================================
        const ReviewArea = ({
          data,
          templates,
          updateRow,
          incrementEdits,
          onSendToTracking,
          onPreview,
          onExportForMailMerge,
          onClearReviewData,
          sortConfig,
          setSortConfig,
        }) => {
          const [selectedRows, setSelectedRows] = useState(new Set());
          const [filter, setFilter] = useState('');
          
          const REVIEW_HEADERS = [
              { key: 'Fecha_Neg', label: 'Fecha Neg.' },
              { key: 'No_Orden', label: 'No. Orden' },
              { key: 'No_Cedula', label: 'No. C√©dula' },
              { key: 'Nombre', label: 'Nombre' },
              { key: 'EPS', label: 'EPS' },
              { key: 'Programa', label: 'Programa', compact: true },
              { key: 'Motivo_Negacion', label: 'Motivo Neg.', compact: true },
              { key: 'Descripcion_PDF', label: 'Descripci√≥n', compact: true },
              { key: 'Justificacion_PDF', label: 'Justificaci√≥n', compact: true },
              { key: 'Fundamento_Legal_PDF', label: 'Fund. Legal', compact: true },
          ];
          
          // Ensure 'data' is always an array before filtering/sorting
          const currentData = Array.isArray(data) ? data : [];

          const filteredData = useMemo(() => {
            if (!filter) return currentData;
            const lowercasedFilter = filter.toLowerCase();
            return currentData.filter(row =>
              row && typeof row === 'object' && // Ensure row is a valid object
              Object.values(row).some(value =>
                String(value).toLowerCase().includes(lowercasedFilter)
              )
            );
          }, [currentData, filter]); // Depend on currentData

          const handleSelectRow = (noOrden) => {
            const key = String(noOrden); // Ensure key is string for Set consistency
            const newSelection = new Set(selectedRows);
            if (newSelection.has(key)) {
              newSelection.delete(key);
            } else {
              newSelection.add(key);
            }
            setSelectedRows(newSelection);
          };

          const handleSelectAll = (e) => {
            if (e.target.checked) {
              const allOrderNumbers = filteredData
                .map(row => row ? String(row.No_Orden) : null) // Get No_Orden as string, handle potential null rows
                .filter(Boolean); // Remove nulls/undefined
              setSelectedRows(new Set(allOrderNumbers));
            } else {
              setSelectedRows(new Set());
            }
          };

          const handleCellBlur = (noOrden, key, value) => {
             // Find row using string comparison for No_Orden
            const originalRow = currentData.find(r => r && String(r.No_Orden) === String(noOrden));
            if (originalRow && originalRow[key] !== value) {
              updateRow(noOrden, { [key]: value }); // Pass original noOrden (might be number or string)
              incrementEdits();
            }
          };
          
          const handleSelectChange = (noOrden, value) => {
            const changes = { Tipo_Carta: value };
            const template = templates.find(t => t.id === value);
            if (!template || !template.name.toUpperCase().includes('COMPLEMENTARIEDAD')) {
                changes.Radicado_Comp = '';
            }
             // Pass original noOrden (might be number or string)
            updateRow(noOrden, changes);
          };

          const requestSort = (key) => {
            let direction = 'ascending';
            if (sortConfig.key === key && sortConfig.direction === 'ascending') {
                direction = 'descending';
            }
            setSortConfig({ key, direction });
          };
          
          const getSortIndicator = (key) => {
            if (sortConfig.key !== key) return null;
            return sortConfig.direction === 'ascending' ? ' ‚ñ≤' : ' ‚ñº';
          };

          return (
            <section id="area3" className="space-y-4">
              <h2 className="text-2xl font-bold text-primary border-b border-border-color pb-2">√Årea 3: Revisi√≥n Final y Exportaci√≥n</h2>
              <div className="action-bar bg-highlight p-4 rounded-lg flex flex-wrap items-center gap-4">
                <input
                  type="text"
                  placeholder="Buscar en tabla de revisi√≥n..."
                  className="bg-surface border border-border-color rounded-md px-3 py-2 text-text-primary placeholder-text-secondary w-full sm:w-auto"
                  value={filter}
                  onChange={(e) => setFilter(e.target.value)}
                />
                <span className="text-text-primary">{selectedRows.size} fila(s) seleccionada(s)</span>
              </div>

              <div className="table-container max-h-[700px] overflow-auto border border-border-color rounded-lg">
                <table className="w-full text-sm text-left text-text-secondary table-auto">
                  <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                    <tr>
                      <th className="px-4 py-3"><input type="checkbox" onChange={handleSelectAll} checked={filteredData.length > 0 && selectedRows.size === filteredData.length} /></th>
                      <th className="px-4 py-3">üëÅÔ∏è</th>
                       {REVIEW_HEADERS.map(({ key, label, compact }) => (
                        <th key={key} onClick={() => requestSort(key)} className={`px-4 py-3 cursor-pointer ${compact ? 'max-w-[150px]' : ''}`}>
                            {label}{getSortIndicator(key)}
                        </th>
                      ))}
                      <th className="px-4 py-3">Tipo de Carta</th>
                    </tr>
                  </thead>
                  <tbody>
                   {/* Check filteredData exists and is an array */}
                    {Array.isArray(filteredData) && filteredData.map((row) => {
                       // Add a check to ensure 'row' is a valid object before proceeding
                      if (!row || typeof row !== 'object' || !row.No_Orden) {
                        console.warn("Skipping invalid row in ReviewArea render:", row);
                        return null; // Skip rendering this row
                      }
                      
                      const noOrdenKey = String(row.No_Orden); // Use string key for Set lookup
                      const template = templates.find(t => t.id === row.Tipo_Carta);
                      const isComplementariedad = template && template.name.toUpperCase().includes('COMPLEMENTARIEDAD');
                      const requiresRadicado = isComplementariedad;
                      
                      return (
                         // Use original No_Orden (might be number or string) for handlers, use string key for Set
                        <tr key={noOrdenKey} className={`border-b border-border-color hover:bg-highlight ${isComplementariedad ? 'bg-indigo-900/50' : ''}`}>
                          <td className="px-4 py-2"><input type="checkbox" checked={selectedRows.has(noOrdenKey)} onChange={() => handleSelectRow(noOrdenKey)} /></td>
                          <td className="px-4 py-2 text-lg cursor-pointer" onClick={() => onPreview(row)}>üëÅÔ∏è</td>
                          {REVIEW_HEADERS.map(({ key, compact }) => (
                            <td key={key} 
                                className={`px-4 py-2 border-r border-border-color focus:bg-primary focus:text-black outline-none ${compact ? 'max-w-[150px] overflow-hidden text-ellipsis whitespace-nowrap' : ''}`}
                                contentEditable
                                onBlur={(e) => handleCellBlur(row.No_Orden, key, e.currentTarget.innerText)} // Pass original No_Orden
                                suppressContentEditableWarning={true}
                            >
                                {row[key] !== null && row[key] !== undefined ? String(row[key]) : ''} 
                            </td>
                          ))}
                          <td className="px-4 py-2">
                            <div className="flex flex-col gap-1">
                              <select 
                                value={row.Tipo_Carta || ''}
                                onChange={(e) => handleSelectChange(row.No_Orden, e.target.value)} // Pass original No_Orden
                                className="bg-surface border border-border-color rounded-md px-2 py-1 text-text-primary w-full"
                              >
                                <option value="">-- Seleccionar --</option>
                                {templates.map(t => <option key={t.id} value={t.id}>{t.name}</option>)}
                              </select>
                              {requiresRadicado && (
                                <input
                                  type="text"
                                  placeholder="Radicado..."
                                  value={row.Radicado_Comp || ''}
                                  onChange={(e) => updateRow(row.No_Orden, { Radicado_Comp: e.target.value })} // Pass original No_Orden
                                  className="bg-surface border border-border-color rounded-md px-2 py-1 text-text-primary w-full mt-1"
                                />
                              )}
                            </div>
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
              <div className="flex flex-wrap gap-4">
                <button 
                    onClick={() => onSendToTracking(Array.from(selectedRows))} // Pass the Set values (which are string keys)
                    disabled={selectedRows.size === 0} // Disable if no rows selected
                    className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed"
                >
                    Enviar a Seguimiento
                </button>
                 <button 
                    onClick={() => onExportForMailMerge(currentData)} // Export based on currentData
                    disabled={currentData.length === 0} // Disable if no data
                    className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed"
                >
                    Exportar para Env√≠o Masivo
                </button>
                <button 
                    onClick={onClearReviewData}
                    className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors"
                >
                    Limpiar Tabla de Revisi√≥n
                </button>
              </div>
            </section>
          );
        };
        

        // =================================================================================
        // INLINED: components/TrackingArea.tsx
        // =================================================================================
        const TrackingTable = ({ data, isArchived, onUpdate, onArchive, filter }) => {
            
          const [selectedRows, setSelectedRows] = useState(new Set());
          
          const statusClasses = {
            'Pendiente': 'bg-yellow-600/20',
            'En Gesti√≥n': 'bg-blue-600/20',
            'Finalizado': 'bg-green-600/20',
          };
          
          // Ensure data is always an array
          const currentData = Array.isArray(data) ? data : [];

          const filteredData = useMemo(() => {
            if (!filter) return currentData;
            const lowercasedFilter = filter.toLowerCase();
            return currentData.filter(row =>
              row && typeof row === 'object' && // Ensure row is valid
              Object.values(row).some(value =>
                String(value).toLowerCase().includes(lowercasedFilter)
              )
            );
          }, [currentData, filter]); // Depend on currentData

          const handleSelectRow = (index) => {
            const newSelection = new Set(selectedRows);
            if (newSelection.has(index)) {
              newSelection.delete(index);
            } else {
              newSelection.add(index);
            }
            setSelectedRows(newSelection);
          };
          
          const handleSelectAll = (e) => {
            if (e.target.checked) {
               // Use indices of the currently filtered data
              setSelectedRows(new Set(filteredData.map((row) => currentData.indexOf(row)).filter(index => index !== -1)));
            } else {
              setSelectedRows(new Set());
            }
          };
          
          const handleBulkArchive = () => {
            if (selectedRows.size > 0) {
              onArchive(Array.from(selectedRows)); // Pass indices
              setSelectedRows(new Set());
            }
          };

          return (
            <div className="space-y-4">
              <div className="flex justify-end">
                   {selectedRows.size > 0 && (
                       <button
                           onClick={handleBulkArchive}
                           className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors"
                       >
                           {isArchived ? `Restaurar ${selectedRows.size} Seleccionados` : `Archivar ${selectedRows.size} Seleccionados`}
                       </button>
                   )}
              </div>
              <div className="table-container max-h-[400px] overflow-auto border border-border-color rounded-lg">
                <table className="w-full text-sm text-left text-text-secondary">
                  <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                    <tr>
                      <th className="px-4 py-3"><input type="checkbox" onChange={handleSelectAll} checked={filteredData.length > 0 && selectedRows.size === filteredData.length}/></th>
                      <th className="px-4 py-3">Fecha Ing.</th>
                      <th className="px-4 py-3">No. Orden</th>
                      <th className="px-4 py-3">Nombre</th>
                      <th className="px-4 py-3">EPS</th>
                      <th className="px-4 py-3">Radicado</th>
                      <th className="px-4 py-3">Estado</th>
                      <th className="px-4 py-3">Notas</th>
                      <th className="px-4 py-3">Acci√≥n</th>
                    </tr>
                  </thead>
                  <tbody>
                    {Array.isArray(filteredData) && filteredData.map((row) => {
                      // Find the original index in the full 'currentData' array
                       const originalIndex = currentData.findIndex(item => item === row);
                       // Skip if row is invalid or not found (shouldn't happen with findIndex but good practice)
                       if (!row || typeof row !== 'object' || originalIndex === -1) return null; 

                      return (
                      <tr key={originalIndex} className={`border-b border-border-color hover:bg-highlight transition-colors ${isArchived ? 'bg-archive/50 text-text-secondary' : statusClasses[row.Estado] || ''}`}>
                        <td className="px-4 py-2"><input type="checkbox" checked={selectedRows.has(originalIndex)} onChange={() => handleSelectRow(originalIndex)} /></td>
                        <td className="px-4 py-2">{row.Fecha_Ing || ''}</td>
                        <td className="px-4 py-2">{row.No_Orden || ''}</td>
                        <td className="px-4 py-2">{row.Nombre || ''}</td>
                        <td className="px-4 py-2">{row.EPS || ''}</td>
                        <td className="px-4 py-2">{row.Radicado || ''}</td>
                        <td className="px-4 py-2">
                          <select
                            value={row.Estado || TRACKING_STATUSES[0]} // Default to first status if undefined
                            onChange={e => onUpdate(originalIndex, { ...row, Estado: e.target.value })}
                            className="bg-surface border border-border-color rounded-md px-2 py-1 text-text-primary"
                          >
                            {TRACKING_STATUSES.map(s => <option key={s} value={s}>{s}</option>)}
                          </select>
                        </td>
                         {/* Ensure innerText exists before updating state */}
                        <td 
                            className="px-4 py-2 outline-none focus:bg-primary focus:text-black" 
                            contentEditable 
                            onBlur={e => {
                                const newNotes = e.currentTarget.innerText;
                                if(row.Notas !== newNotes){ // Only update if changed
                                    onUpdate(originalIndex, { ...row, Notas: newNotes });
                                }
                            }} 
                            suppressContentEditableWarning={true}
                         >
                             {row.Notas || ''}
                         </td>
                        <td className="px-4 py-2 text-lg cursor-pointer" onClick={() => onArchive([originalIndex])}>{isArchived ? '‚ôªÔ∏è' : 'üóÑÔ∏è'}</td>
                      </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </div>
          );
        };

        const TrackingArea = ({ trackingData, archivedData, updateTrackingData, archiveItems }) => {
          const [showArchived, setShowArchived] = useState(false);
          const [filter, setFilter] = useState('');
           // Ensure data props are arrays
          const currentTrackingData = Array.isArray(trackingData) ? trackingData : [];
          const currentArchivedData = Array.isArray(archivedData) ? archivedData : [];


          return (
            <section id="area4" className="space-y-4">
              <h2 className="text-2xl font-bold text-primary border-b border-border-color pb-2">√Årea 4: Seguimiento</h2>
              <div className="action-bar bg-highlight p-4 rounded-lg flex flex-wrap items-center gap-4">
                <input
                  type="text"
                  placeholder="Buscar en seguimiento..."
                  className="bg-surface border border-border-color rounded-md px-3 py-2 text-text-primary placeholder-text-secondary w-full sm:w-auto"
                  value={filter}
                  onChange={e => setFilter(e.target.value)}
                />
                <button onClick={() => setShowArchived(!showArchived)} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">
                  {showArchived ? 'Ocultar' : 'Mostrar'} Archivados ({currentArchivedData.length})
                </button>
              </div>

              <h3 className="text-xl font-semibold text-white">Casos Activos ({currentTrackingData.length})</h3>
              <TrackingTable
                data={currentTrackingData} // Pass guaranteed array
                isArchived={false}
                onUpdate={(index, row) => updateTrackingData(index, row, false)}
                onArchive={(indices) => archiveItems(indices, false)}
                filter={filter}
              />

              {showArchived && (
                <div className="mt-8">
                  <h3 className="text-xl font-semibold text-white">Casos Archivados ({currentArchivedData.length})</h3>
                  <TrackingTable
                    data={currentArchivedData} // Pass guaranteed array
                    isArchived={true}
                    onUpdate={(index, row) => updateTrackingData(index, row, true)}
                    onArchive={(indices) => archiveItems(indices, true)}
                    filter={filter}
                  />
                </div>
              )}
            </section>
          );
        };

        // =================================================================================
        // INLINED: components/SetupModal.tsx
        // =================================================================================
        const SetupModal = ({ onSave, onClose, initialUrl = '' }) => {
          const [url, setUrl] = useState(initialUrl);
          const [isVerifying, setIsVerifying] = useState(false);

          const handleSave = async () => {
            if (!url || !url.startsWith('https://script.google.com/macros/s/')) { // Added check for empty url
                alert("Por favor, introduce una URL v√°lida de Google Apps Script.");
                return;
            }
            setIsVerifying(true);
            // Wrap onSave in try/catch to handle potential errors during verification
             try {
                await onSave(url);
                // If onSave completes without error, verification is assumed successful
            } catch (error) {
                // Error handling is likely done within onSave/handleSetScriptUrl already
                console.error("Verification failed:", error); 
            } finally {
                setIsVerifying(false); // Ensure verifying state is reset even if error occurs
            }
          };

          return (
            <div className="fixed inset-0 bg-background bg-opacity-90 flex justify-center items-center z-[200] p-4"> {/* Increased z-index */}
              <div className="bg-surface rounded-lg shadow-xl w-full max-w-lg border border-border-color p-8 space-y-6">
                <div className="text-center">
                    <h2 className="text-2xl font-bold text-primary">Configuraci√≥n de Conexi√≥n</h2>
                    <p className="text-text-secondary mt-2">
                        Proporciona la URL de Google Apps Script implementada como aplicaci√≥n web.
                    </p>
                </div>
                <div>
                    <label htmlFor="script-url" className="block text-sm font-medium text-text-primary mb-1">
                        URL del Script
                    </label>
                    <input
                        id="script-url"
                        type="url"
                        value={url}
                        onChange={(e) => setUrl(e.target.value)}
                        placeholder="https://script.google.com/macros/s/..."
                        className="w-full bg-background border border-border-color rounded-md px-3 py-2 text-text-primary placeholder-text-secondary focus:ring-primary focus:border-primary"
                    />
                </div>
                <div className="flex justify-end gap-4">
                    <button
                        onClick={onClose}
                        disabled={isVerifying} // Disable cancel while verifying
                        className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed"
                    >
                        Cancelar
                    </button>
                    <button
                        onClick={handleSave}
                        disabled={isVerifying || !url} // Disable if verifying or url is empty
                        className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed"
                    >
                        {isVerifying ? <Spinner /> : 'Guardar y Verificar'} {/* Show spinner */}
                    </button>
                </div>
              </div>
            </div>
          );
        };

        // =================================================================================
        // INLINED: components/TemplateManagerModal.tsx
        // =================================================================================
        const TemplateManagerModal = ({ templates, onClose, onSave, onReset }) => {
          const [currentTemplates, setCurrentTemplates] = useState(() => Array.isArray(templates) ? templates : []); // Ensure initial state is array
          const [editingTemplate, setEditingTemplate] = useState(null);

          const handleSave = () => {
            onSave(currentTemplates);
            onClose();
          };

          const handleAddNew = () => {
            setEditingTemplate({ id: `tpl_${Date.now()}`, name: '', body: '' });
          };
          
          const handleEdit = (template) => {
            setEditingTemplate({ ...template }); // Create a copy for editing
          };

          const handleDelete = (idToDelete) => {
            if (window.confirm('¬øEst√°s seguro de que quieres eliminar esta plantilla?')) {
              setCurrentTemplates(current => current.filter(t => t.id !== idToDelete)); // Use functional update
            }
          };
          
          const handleSaveTemplateEdit = () => {
            if (!editingTemplate || !editingTemplate.name || !editingTemplate.body) {
              alert('El nombre y el cuerpo de la plantilla no pueden estar vac√≠os.');
              return;
            }

            setCurrentTemplates(current => {
                const existingIndex = current.findIndex(t => t.id === editingTemplate.id);
                if (existingIndex > -1) {
                    // Update existing
                    const updated = [...current];
                    updated[existingIndex] = editingTemplate;
                    return updated;
                } else {
                    // Add new
                    return [...current, editingTemplate];
                }
            });
            setEditingTemplate(null); // Close editor
          };
          
          // Ensure currentTemplates is always an array for rendering
          const renderTemplates = Array.isArray(currentTemplates) ? currentTemplates : [];


          return (
            <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[150] p-4"> {/* Increased z-index */}
              <div className="bg-surface rounded-lg shadow-xl w-full max-w-4xl border border-border-color flex flex-col max-h-[90vh]">
                <div className="p-6 border-b border-border-color flex justify-between items-center">
                  <h3 className="text-xl font-bold text-primary">Gestionar Plantillas de Correo</h3>
                  <button onClick={onClose} className="text-text-secondary text-2xl hover:text-text-primary">&times;</button>
                </div>
                
                <div className="p-6 overflow-y-auto space-y-6 flex-grow"> {/* Added flex-grow */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6 h-full"> {/* Added h-full */}
                    <div className="flex flex-col"> {/* Added flex container */}
                      <h4 className="text-lg font-semibold mb-2">Plantillas Actuales</h4>
                      <ul className="space-y-2 border border-border-color rounded-lg p-2 overflow-y-auto flex-grow"> {/* Added flex-grow */}
                         {/* Check renderTemplates is array before mapping */}
                        {Array.isArray(renderTemplates) && renderTemplates.map(template => (
                          <li key={template.id} className="flex justify-between items-center p-2 bg-highlight rounded">
                            <span className="text-text-primary truncate" title={template.name}>{template.name}</span> {/* Added truncate */}
                            <div className="space-x-2 flex-shrink-0"> {/* Added flex-shrink-0 */}
                              <button onClick={() => handleEdit(template)} className="text-sm bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded">Editar</button>
                              <button onClick={() => handleDelete(template.id)} className="text-sm bg-danger hover:bg-danger-hover px-2 py-1 rounded">Borrar</button>
                            </div>
                          </li>
                        ))}
                         {renderTemplates.length === 0 && <li className="text-text-secondary text-center p-4">No hay plantillas personalizadas.</li>}
                      </ul>
                    </div>
                    
                    <div className="flex flex-col"> {/* Added flex container */}
                      <h4 className="text-lg font-semibold mb-2">{editingTemplate ? (editingTemplate.id.startsWith('tpl_') ? 'Editar Plantilla' : 'Crear Nueva Plantilla') : 'Crear Nueva Plantilla'}</h4>
                      {editingTemplate ? (
                        <div className="space-y-4 p-4 border border-border-color rounded-lg bg-highlight flex flex-col flex-grow"> {/* Added flex */}
                           <input
                            type="text"
                            placeholder="Nombre de la Plantilla"
                            value={editingTemplate.name || ''}
                            onChange={(e) => setEditingTemplate(prev => ({ ...prev, name: e.target.value }))}
                            className="w-full bg-background border border-border-color rounded-md px-3 py-2"
                          />
                          <textarea
                            placeholder="Cuerpo de la Plantilla (HTML permitido)..."
                            value={editingTemplate.body || ''}
                            onChange={(e) => setEditingTemplate(prev => ({ ...prev, body: e.target.value }))}
                            className="w-full bg-background border border-border-color rounded-md px-3 py-2 resize-y flex-grow" // Added flex-grow
                          />
                           <p className="text-xs text-text-secondary flex-shrink-0">Marcadores: {`{{Columna}}`} (e.j: {`{{Nombre}}`}, {`{{No_Orden}}`})</p> {/* Added flex-shrink-0 */}
                          <div className="flex gap-2 flex-shrink-0"> {/* Added flex-shrink-0 */}
                            <button onClick={handleSaveTemplateEdit} className="bg-green-600 hover:bg-green-700 px-3 py-1 rounded text-sm">Guardar Cambios</button>
                            <button onClick={() => setEditingTemplate(null)} className="bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded text-sm">Cancelar</button>
                          </div>
                        </div>
                      ) : (
                        <button onClick={handleAddNew} className="w-full bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg">
                          A√±adir Nueva Plantilla
                        </button>
                      )}
                    </div>
                  </div>
                </div>

                <div className="p-4 bg-header flex justify-between items-center rounded-b-lg flex-shrink-0"> {/* Added flex-shrink-0 */}
                   <button onClick={onReset} className="bg-danger hover:bg-danger-hover text-white font-bold py-2 px-4 rounded-lg">
                    Restaurar Predeterminadas
                  </button>
                  <div className="flex gap-4">
                    <button onClick={onClose} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">
                        Cancelar
                    </button>
                    <button onClick={handleSave} className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">
                        Guardar y Cerrar
                    </button>
                  </div>
                </div>
              </div>
            </div>
          );
        };

        // =================================================================================
        // INLINED: components/PreviewModal.tsx
        // =================================================================================
        const PreviewModal = ({ data, template, onClose }) => {
           // Ensure data is an object before proceeding
          if (!data || typeof data !== 'object') {
             console.error("Invalid data provided to PreviewModal:", data);
             return null; // Don't render if data is invalid
          }
          const bodyContent = template && template.body ? replacePlaceholders(template.body, data) : '<p><i>Selecciona un tipo de carta en el √Årea 3 para ver la vista previa.</i></p>';
          const fullBody = bodyContent + COMMON_EMAIL_BODY + SIGNATURE;

          const copyToClipboard = () => {
             // Create a temporary element to parse HTML and get text content
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = fullBody;
            // Get text content, trying different properties for browser compatibility
            const textContent = tempDiv.textContent || tempDiv.innerText || "";

            navigator.clipboard.writeText(textContent.trim()) // Trim whitespace
              .then(() => alert('¬°Contenido de texto copiado al portapapeles!'))
              .catch(err => {
                   console.error('Failed to copy text content:', err);
                   alert('Fall√≥ al copiar el contenido de texto.');
               });
          };
          
          const copyHtmlToClipboard = () => {
               try {
                  // Use Clipboard API with HTML type
                  const blob = new Blob([fullBody], { type: 'text/html' });
                  const item = new ClipboardItem({ 'text/html': blob });
                  navigator.clipboard.write([item])
                     .then(() => alert('¬°Contenido HTML copiado al portapapeles!'))
                     .catch(err => {
                          console.error('Failed to copy HTML content:', err);
                          alert('Fall√≥ al copiar el contenido HTML (tu navegador podr√≠a no soportarlo).');
                      });
               } catch (error) {
                  console.error('Error copying HTML:', error);
                  alert('Error al intentar copiar HTML (ClipboardItem puede no ser soportado).');
               }
           };

          return (
            <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[150] p-4"> {/* Increased z-index */}
              <div className="bg-surface rounded-lg shadow-xl w-full max-w-3xl border border-border-color flex flex-col max-h-[90vh]"> {/* Added max-h */}
                <div className="p-6 border-b border-border-color flex justify-between items-center">
                  <h3 className="text-xl font-bold text-primary">Vista Previa del Correo para Orden: {data.No_Orden || 'N/A'}</h3>
                   <button onClick={onClose} className="text-text-secondary text-2xl hover:text-text-primary">&times;</button>
                </div>
                {/* Use iframe to render HTML correctly */}
                <iframe 
                  srcDoc={fullBody}
                  className="p-1 flex-grow overflow-y-auto bg-white" // Use p-1 instead of p-6 for iframe, added flex-grow
                  sandbox="allow-same-origin" // Basic sandboxing for security
                  style={{border: 'none', minHeight: '300px'}} // Ensure minimum height
                  title="Vista Previa Email"
                />
                <div className="p-4 bg-header flex justify-end gap-4 rounded-b-lg flex-shrink-0"> {/* Added flex-shrink-0 */}
                   <button onClick={copyHtmlToClipboard} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors" title="Copiar como HTML formateado para pegar en correos">
                     Copiar HTML
                   </button>
                  <button onClick={copyToClipboard} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors" title="Copiar solo el texto sin formato">
                    Copiar Texto
                  </button>
                  <button onClick={onClose} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    Cerrar
                  </button>
                </div>
              </div>
            </div>
          );
        };
        

        // =================================================================================
        // INLINED: App.tsx (The main application component)
        // =================================================================================
        const App = () => {
          // Initialize state with empty arrays or appropriate defaults
          const [state, setState] = useState({
            finalData: [],
            trackingData: [],
            archivedData: [],
            portalData: [],
            pdfData: Array(5).fill({}),
            templates: [],
            scriptUrl: null,
            isSetupNeeded: false,
            isReconfiguring: false,
            isLoading: true,
            isSaving: false,
            isTemplateManagerOpen: false,
            previewData: null,
            notification: null,
            editsCount: 0,
            onlineStatus: true,
            masterTrackingOrders: new Set(),
          });

          const [sortConfig, setSortConfig] = useState({
            key: 'No_Orden',
            direction: 'ascending',
          });

          const hideNotification = useCallback(() => {
             setState((prev) => ({ ...prev, notification: null }));
          }, []); // Empty dependency array as it doesn't depend on external vars

          const showNotification = useCallback((message, type = 'info', duration = 5000) => {
             // Clear existing notification timeout if any
             if (state.notification && state.notification.timeoutId) {
                clearTimeout(state.notification.timeoutId);
             }
             const timeoutId = setTimeout(hideNotification, duration);
             setState((prev) => ({ ...prev, notification: { message, type, timeoutId } }));
          }, [hideNotification, state.notification]); // Depend on hideNotification and state.notification

          const handleSetScriptUrl = useCallback(async (url) => {
             console.log("Attempting to set script URL and fetch initial data..."); // Debug log
            setState((prev) => ({ ...prev, isLoading: true }));
            try {
              const data = await fetchData(url); // fetchData defined earlier
              localStorage.setItem('sigweb_scriptUrl', url);
              setState((prev) => ({
                ...prev,
                 // Ensure fetched data are arrays, default to empty if not
                finalData: Array.isArray(data.finalData) ? data.finalData : [],
                trackingData: Array.isArray(data.trackingData) ? data.trackingData : [],
                archivedData: Array.isArray(data.archivedData) ? data.archivedData : [],
                masterTrackingOrders: new Set(Array.isArray(data.masterTrackingOrders) ? data.masterTrackingOrders.map(String) : []), // Ensure Set contains strings
                scriptUrl: url,
                isSetupNeeded: false,
                isReconfiguring: false,
                isLoading: false,
              }));
              showNotification('¬°Conexi√≥n exitosa y datos cargados!', 'success');
              console.log("Initial data fetched successfully."); // Debug log
            } catch (error) {
              console.error("Error setting script URL or fetching data:", error); // Log the actual error
              showNotification(
                `Fall√≥ la conexi√≥n: ${error.message}. Revisa la URL y permisos del script.`, // Show more specific error
                'error',
                 10000 // Show error longer
              );
              setState((prev) => ({ ...prev, isLoading: false, isSetupNeeded: true })); // Go back to setup on error
            }
          }, [showNotification]); // Add showNotification dependency


          useEffect(() => {
             console.log("App component mounted. Checking for script URL..."); // Debug log
            const url = localStorage.getItem('sigweb_scriptUrl');
            const loadedTemplates = loadTemplates(); // loadTemplates defined earlier
            setState((prev) => ({ ...prev, templates: loadedTemplates }));

            if (url) {
                console.log("Found script URL in localStorage:", url); // Debug log
                handleSetScriptUrl(url);
            } else {
                console.log("No script URL found. Setup needed."); // Debug log
                setState((prev) => ({ ...prev, isSetupNeeded: true, isLoading: false }));
            }

            // Online/Offline handling
            const updateOnlineStatus = () => {
                const isOnline = navigator.onLine;
                console.log("Network status changed:", isOnline ? "Online" : "Offline"); // Debug log
                setState(prev => ({ ...prev, onlineStatus: isOnline }));
                if (!isOnline) {
                    showNotification("Est√°s desconectado. El guardado est√° deshabilitado.", "warning", 10000);
                } else {
                     // Optionally show a "back online" message
                     // showNotification("Est√°s conectado de nuevo.", "info");
                }
            };

            window.addEventListener('online', updateOnlineStatus);
            window.addEventListener('offline', updateOnlineStatus);
            // Initial check
            updateOnlineStatus();

            return () => { // Cleanup listeners on component unmount
                console.log("App component unmounting. Removing listeners."); // Debug log
                window.removeEventListener('online', updateOnlineStatus);
                window.removeEventListener('offline', updateOnlineStatus);
                 // Clear any pending notification timeouts
                if (state.notification && state.notification.timeoutId) {
                    clearTimeout(state.notification.timeoutId);
                }
            };
            // Run only on mount and unmount
          }, [handleSetScriptUrl, showNotification]); // Added dependencies


          const incrementEdits = useCallback(() => {
            setState((prev) => ({ ...prev, editsCount: prev.editsCount + 1 }));
          },[]); // No dependencies needed

          const handleSave = useCallback(async () => {
             console.log("Save button clicked."); // Debug log
            if (!state.scriptUrl) {
              showNotification('No se puede guardar. La URL del script no est√° configurada.', 'error');
              return;
            }
            if (!state.onlineStatus) {
                showNotification('No se puede guardar mientras est√°s desconectado.', 'error');
                return;
            }
             if (state.finalData.length === 0 && state.trackingData.length === 0 && state.archivedData.length === 0) {
                 showNotification('No hay datos nuevos o modificados para guardar.', 'info');
                 return;
             }
            setState((prev) => ({ ...prev, isSaving: true }));
            console.log("Attempting to save data..."); // Debug log
            try {
              await saveData(state.scriptUrl, { // saveData defined earlier
                action: 'saveData', 
                payload: {
                    finalData: state.finalData,
                    trackingData: state.trackingData,
                    archivedData: state.archivedData,
                }
              });
              
              // IMPORTANT: Assume save was successful (due to no-cors limitations)
              // Update master tracking set LOCALLY with orders from finalData that were just sent
              const newOrders = new Set(state.masterTrackingOrders);
              state.finalData.forEach(row => {
                  if (row && row.No_Orden) { // Check row and No_Orden exist
                     newOrders.add(String(row.No_Orden).trim())
                  }
              });

              showNotification('¬°Datos enviados a la nube! (Verifica la hoja "TOTAL" para confirmar)', 'success');
              console.log("Save request sent successfully."); // Debug log
              // Clear local finalData and reset edits count after sending
              setState((prev) => ({ 
                  ...prev, 
                  editsCount: 0, 
                  masterTrackingOrders: newOrders, 
                  finalData: [] // Clear the review area data after successful send
               })); 
            } catch (error) {
              console.error("Error during save:", error); // Log the actual error
              showNotification(`Fall√≥ el guardado de datos: ${error.message}`, 'error');
            } finally {
              setState((prev) => ({ ...prev, isSaving: false }));
              console.log("Save process finished."); // Debug log
            }
          }, [state.scriptUrl, state.onlineStatus, state.finalData, state.trackingData, state.archivedData, state.masterTrackingOrders, showNotification]); // Added dependencies


          const processPortalData = useCallback(() => {
              console.log("Processing portal data..."); // Debug log
               // Ensure portalData is an array
              const currentPortalData = Array.isArray(state.portalData) ? state.portalData : [];
              if(currentPortalData.length === 0){
                   showNotification("No hay datos cargados desde el archivo para procesar.", "warning");
                   return;
              }
              
              // Filter out rows that already exist based on masterTrackingOrders Set
              const newRows = currentPortalData.filter(row => {
                  // Ensure row and No_Orden exist before checking the Set
                   const orderKey = row && row.No_Orden ? String(row.No_Orden).trim() : null;
                   return orderKey && !state.masterTrackingOrders.has(orderKey);
              });

              const duplicates = currentPortalData.length - newRows.length;
              console.log(`Found ${newRows.length} new rows, skipped ${duplicates} duplicates.`); // Debug log

              const processedData = newRows
                  // Ensure row is valid before mapping
                  .filter(row => row && row.No_Orden && String(row.No_Orden).trim()) 
                  .map((row) => ({
                      ...row, // Keep all data
                      Nombre: capitalizeWords(row.Nombre || ''), // Apply specific formatting
                      EPS: (row.EPS || '').toUpperCase(),
                      // Ensure required fields for Area 3 have defaults if missing from Excel
                      Descripcion_PDF: row.Descripcion_PDF || '(pendiente)',
                      Justificacion_PDF: row.Justificacion_PDF || '(pendiente)',
                      Fundamento_Legal_PDF: row.Fundamento_Legal_PDF || '(pendiente)',
                      Tipo_Carta: row.Tipo_Carta || '',
                      Radicado_Comp: row.Radicado_Comp || '',
                  }));

              // Update finalData with only the NEW processed rows, clear portalData
              setState((prev) => ({ ...prev, finalData: processedData, portalData: [] })); 
              
              let message = `${processedData.length} nuevas filas procesadas y listas en √Årea 3.`;
              if (duplicates > 0) {
                  message += ` ${duplicates} fila(s) ya existentes fueron omitidas.`;
              }
              showNotification(message, processedData.length > 0 ? 'success' : 'info'); // Use 'info' if only duplicates found

          }, [state.portalData, state.masterTrackingOrders, showNotification]); // Dependencies


          const mergePdfData = useCallback(() => {
             console.log("Merging PDF data..."); // Debug log
             // Ensure pdfData is an array
             const currentPdfData = Array.isArray(state.pdfData) ? state.pdfData : [];
             if(currentPdfData.every(row => !Object.values(row).some(val => val))){
                 showNotification("No hay datos en el √Årea 2 para combinar.", "warning");
                 return;
             }

            const pdfMap = new Map();
            currentPdfData
              .filter(row => row && row['Archivo (No. Orden)'] && String(row['Archivo (No. Orden)']).trim()) // Ensure row and key exist
              .forEach(row => {
                 const key = String(row['Archivo (No. Orden)']).trim();
                 if(key){ // Ensure key is not empty
                    pdfMap.set(key, {
                      Descripcion_PDF: row['Descripci√≥n'] || '', // Use bracket notation for keys with spaces
                      Justificacion_PDF: row['Justificaci√≥n'] || '',
                      Fundamento_Legal_PDF: row['Fundamento Legal'] || '',
                    });
                 }
              });
              
            console.log(`Created PDF map with ${pdfMap.size} entries.`); // Debug log

            // Ensure finalData is an array
            const currentFinalData = Array.isArray(state.finalData) ? state.finalData : [];
            let mergeCount = 0;
            const mergedData = currentFinalData.map(finalRow => {
              // Ensure finalRow and No_Orden exist
              const orderKey = finalRow && finalRow.No_Orden ? String(finalRow.No_Orden).trim() : null;
              if (orderKey) {
                  const pdfMatch = pdfMap.get(orderKey);
                  if (pdfMatch) {
                      mergeCount++;
                      return { ...finalRow, ...pdfMatch };
                  }
              }
              return finalRow; // Return original row if no match or invalid
            });

            setState((prev) => ({ ...prev, finalData: mergedData, pdfData: Array(5).fill({}) }));
            showNotification(`${mergeCount} fila(s) actualizadas con datos del PDF en el √Årea 3.`, 'success');
            console.log(`Merged PDF data into ${mergeCount} rows.`); // Debug log
          }, [state.pdfData, state.finalData, showNotification]); // Dependencies


          const updateFinalDataRow = useCallback((noOrden, partialUpdate) => {
             // Ensure noOrden is a string for comparison
             const keyToUpdate = String(noOrden);
            setState((prev) => {
                // Ensure finalData is an array
               const currentFinalData = Array.isArray(prev.finalData) ? prev.finalData : [];
               const newData = currentFinalData.map(row => 
                  (row && String(row.No_Orden) === keyToUpdate) ? { ...row, ...partialUpdate } : row
               );
               return { ...prev, finalData: newData };
            });
            // Increment edits count immediately without waiting for state update
            incrementEdits(); 
          }, [incrementEdits]); // Dependency on incrementEdits


          const handleClearReviewData = useCallback(() => {
            if (window.confirm("¬øLimpiar la tabla de Revisi√≥n (√Årea 3)?\n\nEsto NO borrar√° datos de la hoja 'TOTAL' en Google Sheets.")) {
                setState(prev => ({ ...prev, finalData: [] })); // Only clear local state
                showNotification("Tabla de Revisi√≥n limpiada.", "info");
            }
          }, [showNotification]); // Dependency


          const handleSendToTracking = useCallback((selectedOrderKeys) => { // Receive Set keys (strings)
            console.log("Sending selected items to tracking:", selectedOrderKeys); // Debug log
             // Ensure finalData is an array
            const currentFinalData = Array.isArray(state.finalData) ? state.finalData : [];

            const itemsToSend = currentFinalData
              .filter(row => row && selectedOrderKeys.includes(String(row.No_Orden))) // Filter using string keys
              .filter(row => {
                const template = state.templates.find((t) => t.id === row.Tipo_Carta);
                return (
                  template &&
                  template.name.toUpperCase().includes('COMPLEMENTARIEDAD') &&
                  row.Radicado_Comp &&
                  String(row.Radicado_Comp).trim() !== ''
                );
              });

            if (itemsToSend.length === 0) {
              showNotification("No hay √≠tems seleccionados que cumplan los criterios (Tipo 'COMPLEMENTARIEDAD' con 'Radicado') para enviar a seguimiento.", 'warning');
              return;
            }
             console.log(`${itemsToSend.length} items meet criteria for tracking.`); // Debug log

            setState(prev => {
                // Ensure trackingData and finalData are arrays
               const currentTrackingData = Array.isArray(prev.trackingData) ? prev.trackingData : [];
               let newTrackingData = [...currentTrackingData];
               let newFinalData = Array.isArray(prev.finalData) ? [...prev.finalData] : [];
               let addedCount = 0;
               let updatedCount = 0;

               itemsToSend.forEach(item => {
                 const itemOrderKey = String(item.No_Orden);
                 const existingIndex = newTrackingData.findIndex(t => t && String(t.No_Orden) === itemOrderKey);
                 if (existingIndex !== -1) {
                   if (window.confirm(`El caso ${itemOrderKey} ya est√° en seguimiento activo. ¬øActualizar Radicado?`)) {
                     newTrackingData[existingIndex] = { ...newTrackingData[existingIndex], Radicado: item.Radicado_Comp }; // Update existing
                     updatedCount++;
                   }
                 } else {
                   newTrackingData.push({ // Add new
                     Fecha_Ing: item.Fecha_Neg || new Date().toISOString().slice(0,10), // Use Neg date or today
                     No_Orden: item.No_Orden,
                     Nombre: item.Nombre || '',
                     EPS: item.EPS || '',
                     Radicado: item.Radicado_Comp, // Already validated not empty
                     Estado: 'Pendiente',
                     Notas: '',
                   });
                   addedCount++;
                 }
               });
               
               // Remove sent items from finalData
               const itemsSentOrderKeys = itemsToSend.map(i => String(i.No_Orden));
               newFinalData = newFinalData.filter(f => f && !itemsSentOrderKeys.includes(String(f.No_Orden)));

               if(addedCount > 0 || updatedCount > 0){
                   showNotification(`${addedCount} nuevo(s) enviado(s), ${updatedCount} actualizado(s) en Seguimiento Activo.`, 'success');
               }

               return { ...prev, trackingData: newTrackingData, finalData: newFinalData };
            });

          }, [state.templates, showNotification]); // Dependencies


          const exportForMailMerge = useCallback((dataToExport) => {
              // Ensure data is an array
              const currentData = Array.isArray(dataToExport) ? dataToExport : [];
              if (!currentData || currentData.length === 0) {
                  showNotification("No hay datos en revisi√≥n (√Årea 3) para exportar.", "warning");
                  return;
              }
              console.log(`Exporting ${currentData.length} rows for mail merge.`); // Debug log
              try {
                  const exportable = currentData.map(row => ({
                      // Ensure all keys exist, default to empty string
                      "Fecha": row.Fecha_Neg || '', 
                      "Orden": row.No_Orden || '',
                      "Cedula": row.No_Cedula || '',
                      "Nombre": row.Nombre || '',
                      "EPS": row.EPS || '',
                      "Programa": row.Programa || '',
                      "Email": row.Email || '',
                      "Motivo": row.Motivo_Negacion || '',
                      "Desc": row.Descripcion_PDF || '',
                      "Just": row.Justificacion_PDF || '',
                      "Fund": row.Fundamento_Legal_PDF || '',
                      "Carta": state.templates.find(t => t.id === row.Tipo_Carta)?.name || "NO_SELECCIONADA",
                      "Radicado": row.Radicado_Comp || ''
                  }));
                  const ws = XLSX.utils.json_to_sheet(exportable);
                  const wb = XLSX.utils.book_new();
                  XLSX.utils.book_append_sheet(wb, ws, "DatosParaEnvio");
                  XLSX.writeFile(wb, "Sigweb_Procesado_MailMerge.xlsx");
                  showNotification("Archivo 'Sigweb_Procesado_MailMerge.xlsx' generado.", "success");
              } catch (error) {
                   console.error("Error exporting for mail merge:", error);
                   showNotification("Error al generar el archivo para env√≠o masivo.", "error");
              }
          }, [state.templates, showNotification]); // Dependencies


          const updateTrackingData = useCallback((index, updatedRow, isArchived) => {
             // Ensure index is a valid number
             if (typeof index !== 'number' || index < 0) {
                 console.error("Invalid index provided to updateTrackingData:", index);
                 return;
             }
            const dataKey = isArchived ? 'archivedData' : 'trackingData';
            setState(prev => {
                // Ensure the target array exists and is an array
               const currentData = Array.isArray(prev[dataKey]) ? [...prev[dataKey]] : [];
               if(index < currentData.length) { // Check if index is within bounds
                  currentData[index] = updatedRow;
                  console.log(`Updated item at index ${index} in ${dataKey}`); // Debug log
                  return { ...prev, [dataKey]: currentData, editsCount: prev.editsCount + 1 }; // Increment edits count on change
               } else {
                   console.error(`Index ${index} out of bounds for ${dataKey}`);
                   return prev; // Return previous state if index is invalid
               }
            });
          }, []); // No external dependencies needed


          const archiveItems = useCallback((indicesToMove, fromArchived) => {
             // Ensure indicesToMove is an array of numbers
             if (!Array.isArray(indicesToMove) || indicesToMove.some(isNaN)){
                 console.error("Invalid indices provided to archiveItems:", indicesToMove);
                 return;
             }
             console.log(`${fromArchived ? 'Unarchiving' : 'Archiving'} indices:`, indicesToMove); // Debug log
            const sourceKey = fromArchived ? 'archivedData' : 'trackingData';
            const targetKey = fromArchived ? 'trackingData' : 'archivedData';

            setState(prev => {
                // Ensure source and target data are arrays
               const sourceData = Array.isArray(prev[sourceKey]) ? [...prev[sourceKey]] : [];
               const targetData = Array.isArray(prev[targetKey]) ? [...prev[targetKey]] : [];
               
               const itemsToMove = [];
               const remainingSource = [];

               // Separate items to move and items to keep, handling potential sparse arrays or invalid indices
               sourceData.forEach((item, index) => {
                   if (indicesToMove.includes(index)) {
                       if (item) itemsToMove.push(item); // Only move valid items
                   } else {
                        if(item) remainingSource.push(item); // Keep valid items
                   }
               });
               
               console.log(`Moving ${itemsToMove.length} items from ${sourceKey} to ${targetKey}.`); // Debug log

               return {
                 ...prev,
                 [sourceKey]: remainingSource,
                 [targetKey]: [...targetData, ...itemsToMove], // Append moved items
                 editsCount: prev.editsCount + itemsToMove.length // Increment edits for each moved item
               };
            });
          }, []); // No external dependencies

          const handleSaveTemplates = useCallback((newTemplates) => {
            // Ensure newTemplates is an array
            const templatesToSave = Array.isArray(newTemplates) ? newTemplates : [];
            setState((prev) => ({ ...prev, templates: templatesToSave }));
            saveTemplates(templatesToSave); // saveTemplates defined earlier
            showNotification('Plantillas de correo guardadas localmente.', 'success');
          }, [showNotification]); // Dependency

          const handleResetTemplates = useCallback(() => {
            if (window.confirm('¬øRestaurar plantillas predeterminadas? Se perder√°n las personalizadas.')) {
              handleSaveTemplates(defaultTemplates); // Use defaultTemplates constant
            }
          }, [handleSaveTemplates]); // Dependency

          // Memoized sorted data for Area 3
          const sortedFinalData = useMemo(() => {
             // Ensure finalData is an array
            let sortableItems = Array.isArray(state.finalData) ? [...state.finalData] : []; 
            if (sortConfig.key) {
                sortableItems.sort((a, b) => {
                     // Handle potential null/undefined rows during sort
                    if (!a || !b) return 0; 
                    // Safely access sort key, default to empty string if missing
                    const aVal = a[sortConfig.key] !== undefined && a[sortConfig.key] !== null ? String(a[sortConfig.key]) : '';
                    const bVal = b[sortConfig.key] !== undefined && b[sortConfig.key] !== null ? String(b[sortConfig.key]) : '';
                    
                    // LocaleCompare for potentially better string sorting
                    const comparison = aVal.localeCompare(bVal, undefined, { numeric: true, sensitivity: 'base' });

                    return sortConfig.direction === 'ascending' ? comparison : -comparison;
                });
            }
            return sortableItems;
          }, [state.finalData, sortConfig]); // Dependencies

          // ================== Render Logic ==================

          if (state.isLoading && !state.isSetupNeeded) { // Show loader only if not in initial setup
            return <div className="fixed inset-0 bg-background/90 flex items-center justify-center z-[300]"><Spinner /> <span className="ml-4 text-xl">Cargando Datos Iniciales...</span></div>;
          }

          // Show Setup Modal if needed or reconfiguring
          if (state.isSetupNeeded || state.isReconfiguring) {
            return <SetupModal 
                onSave={handleSetScriptUrl} 
                onClose={() => {
                    // Only close if not in initial setup, otherwise keep showing it
                    if(!state.isSetupNeeded) {
                       setState(prev => ({ ...prev, isReconfiguring: false }));
                    } else {
                         alert("Debes configurar la URL del script para continuar.");
                    }
                }} 
                initialUrl={state.scriptUrl || ''} 
             />;
          }

          // Main App Render
          return (
            <div className="p-4 sm:p-8 bg-background min-h-screen">
              {/* Notification Area */}
              {state.notification && (
                <Notification
                  message={state.notification.message}
                  type={state.notification.type}
                  onClose={hideNotification} 
                />
              )}
              {/* Offline Indicator */}
              {!state.onlineStatus && (
                   <div className="bg-yellow-600 text-white text-center p-2 fixed top-0 left-0 w-full z-[100]">
                     ‚ö† Est√°s desconectado. El guardado en la nube est√° deshabilitado.
                   </div>
              )}

              <main className={`max-w-screen-2xl mx-auto bg-surface p-4 sm:p-6 rounded-xl border border-border-color space-y-8 ${!state.onlineStatus ? 'pt-10' : ''}`}> {/* Add padding top if offline banner shows */}
                <Header 
                    onSave={handleSave} 
                    onManageTemplates={() => setState(prev => ({ ...prev, isTemplateManagerOpen: true }))}
                    onReconfigure={() => setState(prev => ({ ...prev, isReconfiguring: true }))}
                />
                <Dashboard
                  reviewCount={Array.isArray(state.finalData) ? state.finalData.length : 0}
                  trackingCount={Array.isArray(state.trackingData) ? state.trackingData.length : 0}
                  archivedCount={Array.isArray(state.archivedData) ? state.archivedData.length : 0}
                  editsCount={state.editsCount}
                />
                <div className="text-right">
                       <button
                           onClick={() => exportDetailedReport(state.finalData, state.trackingData, state.archivedData)}
                           className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors"
                       >
                           Descargar Reporte Detallado
                       </button>
                </div>

                <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                  {/* Area 1: File Upload */}
                  <DataInputArea
                    id="portal-area"
                    title="√Årea 1: Cargar Excel del Portal"
                    headers={PORTAL_HEADERS}
                    data={state.portalData} // Bind to portalData
                    onDataChange={(newData) => setState(prev => ({ ...prev, portalData: newData }))}
                    onProcess={processPortalData} // Use specific processor
                    processButtonText="Procesar Datos del Archivo"
                    inputType="file" 
                  />
                  {/* Area 2: Paste PDF Data */}
                  <DataInputArea
                    id="pdf-area"
                    title="√Årea 2: Pegar Datos del Extractor PDF"
                    headers={PDF_HEADERS}
                    data={state.pdfData} // Bind to pdfData
                    onDataChange={(newData) => setState(prev => ({ ...prev, pdfData: newData }))}
                    onProcess={mergePdfData} // Use specific processor
                    processButtonText="Combinar con Datos del PDF"
                    inputType="paste"
                  />
                </div>
                 {/* Area 3: Review */}
                <ReviewArea
                  data={sortedFinalData} // Use memoized sorted data
                  templates={state.templates}
                  updateRow={updateFinalDataRow}
                  incrementEdits={incrementEdits}
                  onSendToTracking={handleSendToTracking}
                  onPreview={(row) => setState(prev => ({ ...prev, previewData: row }))}
                  onExportForMailMerge={exportForMailMerge}
                  onClearReviewData={handleClearReviewData}
                  sortConfig={sortConfig}
                  setSortConfig={setSortConfig}
                />
                 {/* Area 4: Tracking */}
                <TrackingArea
                  trackingData={state.trackingData}
                  archivedData={state.archivedData}
                  updateTrackingData={updateTrackingData}
                  archiveItems={archiveItems}
                />
                
                {/* Saving Indicator */}
                {state.isSaving && <div className="fixed inset-0 bg-background/80 flex items-center justify-center z-[300]"><Spinner /> <span className="ml-4 text-xl">Guardando Datos...</span></div>}
              </main>

              {/* Template Manager Modal */}
              {state.isTemplateManagerOpen && (
                <TemplateManagerModal
                  templates={state.templates}
                  onClose={() => setState(prev => ({...prev, isTemplateManagerOpen: false}))}
                  onSave={handleSaveTemplates}
                  onReset={handleResetTemplates}
                />
              )}
               {/* Preview Modal */}
              {state.previewData && (
                <PreviewModal
                  data={state.previewData}
                  template={state.templates.find(t => t.id === state.previewData?.Tipo_Carta)} // Safely find template
                  onClose={() => setState(prev => ({...prev, previewData: null}))}
                />
              )}
            </div>
          );
        };

        // =================================================================================
        // INLINED: index.tsx (Render the application)
        // =================================================================================
        const rootElement = document.getElementById('root');
        if (!rootElement) {
          console.error("Fatal Error: Root element 'root' not found in HTML."); // Log error
          // Optionally display a message to the user in the body
          document.body.innerHTML = '<div style="color: red; padding: 20px;">Error Cr√≠tico: No se encontr√≥ el elemento ra√≠z de la aplicaci√≥n.</div>';
        } else {
            try {
               const root = ReactDOM.createRoot(rootElement);
               root.render(<React.StrictMode><App /></React.StrictMode>); // Added StrictMode for development checks
            } catch(error) {
                console.error("Error rendering React application:", error);
                 rootElement.innerHTML = '<div style="color: red; padding: 20px;">Error Cr√≠tico: Fall√≥ al iniciar la aplicaci√≥n React.</div>';
            }
        }

    </script>
</body>
</html>
