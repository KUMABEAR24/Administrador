<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta http-equiv="Content-Security-Policy"
          content="default-src 'self' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://unpkg.com https://esm.sh;
                   script-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://unpkg.com https://esm.sh;
                   style-src 'self' 'unsafe-inline';">

    <title>GESTION NEGACIONES EJE CAFETERO</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'primary': '#4e9fef',
              'background': '#1e1e1e',
              'surface': '#2d2d2d',
              'text-primary': '#d4d4d4',
              'text-secondary': '#a0a0a0',
              'border-color': '#444',
              'header': '#3a3a3a',
              'highlight': '#252526',
              'warning': '#6e550c',
              'archive': '#3a3a3a',
              'success': '#28a745',
              'danger': '#a02d2d',
              'danger-hover': '#c0392b',
              'btn-primary': '#0e639c',
              'btn-primary-hover': '#1a73e8',
            },
            animation: {
              'flash-success': 'flash-success 1s ease-out',
            },
            keyframes: {
              'flash-success': {
                'from': { backgroundColor: '#28a745' },
                'to': { backgroundColor: 'transparent' },
              }
            }
          }
        }
      }
    </script>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client"
      }
    }
    </script>
</head>

<body class="bg-background text-text-primary">
    <div id="root"></div>

    <script type="text/babel" data-presets="react" data-type="module">
        import React, { useState, useEffect, useCallback, useMemo } from 'react';
        import ReactDOM from 'react-dom/client';

        // =================================================================================
        // INLINED: constants.ts
        // =================================================================================
        const PORTAL_HEADERS = [
            "Fecha_Neg", "Sucursal", "No_Orden", "No_Cedula", "Nombre", "Entidad_Ejecutora",
            "Motivo_Negacion", "Usuario_Emitio", "Auditor", "Observacion_Auditor", "Observacion_Ejecutivo",
            "Programa", "Plan", "Antiguedad", "EPS", "Telefono", "Celular", "Direccion", "Email", "Edad",
            "Tipo_Usuario", "Llamada", "Complementariedad", "Notificacion", "Gestion_Negacion", "Alternativa",
            "Observacion_Alternativa", "Monto", "Nit_Prestador", "Fecha_Complementariedad", "Tiempo_de_Gestion", "Regional"
        ];

        const PDF_HEADERS = [
          "Archivo (No. Orden)", "Descripci√≥n", "Justificaci√≥n", "Fundamento Legal", "C√≥digo"
        ];

        const TRACKING_STATUSES = ['Pendiente', 'En Gesti√≥n', 'Finalizado'];

        const COMMON_EMAIL_BODY = `<br><br><b>Si tiene alguna duda puede contactarse por medio de los canales que tenemos disponibles para usted:</b><br>¬∑ Nuestra l√≠nea nacional 018000931666. O con nuestras l√≠neas locales: Cali (602) 489 0073, Bogot√° (601) 743 5485, Medell√≠n (604) 604 4507, Barranquilla (605) 385 3165, Bucaramanga (607) 697 3350, Cartagena (605) 693 9853, Tulu√° (602) 235 9483, Valledupar (605)588 5699, Pereira (606) 340 2635.<br>¬∑ WhatsApp: 317-224-07-94<br><br>Gracias por su Atenci√≥n.`;
        const SIGNATURE = `<br><br>Cordialmente,<br><br><b>Juan Ricardo Morales Agudelo</b><br>Ejecutivo De Atenci√≥n Integral<br>Coomeva Medicina Prepagada<br>Cra. 13 No.11-12 Centro M√©dico Circunvalar<br>Coomeva Medicina Prepagada Pereira, Risaralda<br><br><i>Este correo es generado autom√°ticamente, por favor no responda este mensaje.</i>`;

        const defaultTemplates = [
            { id: 'tpl_neg_gen', name: 'PLANTILLA NEGACION GENERAL', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar informaci√≥n acerca del servicio {{Motivo_Negacion}} que en esta oportunidad no est√° aprobado debido a que corresponde a EXCLUSI√ìN ({{Descripcion_PDF}}), ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>El servicio negado anteriormente; debe tramitarlo a trav√©s su EPS asignada. Adjuntamos soporte de la carta de negaci√≥n.` },
            { id: 'tpl_neg_pert', name: 'PLANTILLA NO PERTINENCIA Y TEMAS ESTETICOS', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar informaci√≥n acerca del servicio {{Motivo_Negacion}} que en esta oportunidad No est√° aprobado debido a que corresponde a NO PERTINENCIA ({{Descripcion_PDF}}), ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>` },
            { id: 'tpl_comp_coinc', name: 'COMPLEMENTARIEDAD RED COINCIDENTE', body: `Apreciado Usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y el de su familia. Por medio de este correo queremos brindar informaci√≥n acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no fue aprobado, debido a que ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>Sin embargo, est√° en gesti√≥n a trav√©s de su EPS ({{EPS}}) con el n√∫mero de radicado ({{Radicado_Comp}}), puede realizar seguimiento mediante la oficina virtual de la EPS ({{Oficina_Virtual_EPS}}).<br><br>Adicional estaremos haciendo seguimiento al radicado y una vez se encuentre gestionado por la EPS, le notificaremos por medio de correo electr√≥nico.` },
            { id: 'tpl_comp_no_coinc', name: 'COMPLEMENTARIEDAD RED NO COINCIDENTE', body: `Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar informaci√≥n acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no est√° aprobado, debido a que corresponde a ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>El prestador actual solicitado, no tiene convenio con la EPS, por lo que los costos adicionales del servicio o insumo estar√°n a cargo del paciente. Sin embargo; se radica la solicitud ante su EPS con el n√∫mero ({{Radicado_Comp}}) por favor realizar seguimiento mediante la oficina virtual de la EPS ({{Oficina_Virtual_EPS}}).` },
            { id: 'tpl_comp_ayudas', name: 'COMPLEMENTARIEDAD AYUDAS DIAGNOSTICAS', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar informaci√≥n acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no est√° aprobado debido a que corresponde a ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>Sin embargo, se encuentra en gesti√≥n a trav√©s de su EPS con el n√∫mero de radicado ({{Radicado_Comp}}), por favor realizar seguimiento mediante la oficina virtual. ({{Oficina_Virtual_EPS}}).` },
        ];


        // =================================================================================
        // INLINED: services/utilityService.ts
        // =================================================================================
        const capitalizeWords = (str) => {
          if (!str) return '';
          return str.toLowerCase().replace(/\b\w/g, char => char.toUpperCase());
        };

        const processPastedData = (pastedText, headers) => {
          return pastedText
            .trim()
            .split(/\r?\n/)
            .map(rowText => {
              const cells = rowText.split('\t');
              const rowObject = {};
              headers.forEach((header, index) => {
                if (cells[index]) {
                  rowObject[header] = cells[index].trim();
                } else {
                  rowObject[header] = ''; // Ensure all headers exist even if cell is empty
                }
              });
              return rowObject;
            });
        };


        const replacePlaceholders = (templateBody, data) => {
          const getOficinaVirtual = (eps) => {
            const e = (eps || "").toUpperCase();
            if (e.includes("NUEVA EPS")) return `<a href='https://portal.nuevaeps.com.co/Portal/home.jspx' target='_blank' rel='noopener noreferrer'>NUEVA EPS</a>`;
            if (e.includes("SALUD TOTAL")) return `<a href='https://saludtotal.com.co/' target='_blank' rel='noopener noreferrer'>SALUD TOTAL</a>`;
            return eps || ''; // Return empty string if eps is null/undefined
          };

          // Ensure data is an object, default to empty object if not
          const safeData = (typeof data === 'object' && data !== null) ? data : {};
          const fullData = { ...safeData, Oficina_Virtual_EPS: getOficinaVirtual(safeData.EPS) };

          // Ensure templateBody is a string
          const safeTemplateBody = typeof templateBody === 'string' ? templateBody : '';

          return safeTemplateBody.replace(/\{\{(\w+)\}\}/g, (match, key) => {
            // Ensure fullData[key] exists and is not null/undefined before returning, otherwise return empty string
            return fullData[key] !== null && fullData[key] !== undefined ? String(fullData[key]) : ''; // Convert to string
          });
        };


        const exportDetailedReport = (finalData, trackingData, archivedData) => {
          try {
            const masterDataMap = new Map();

            // Ensure all inputs are arrays before spreading
            const safeFinalData = Array.isArray(finalData) ? finalData : [];
            const safeTrackingData = Array.isArray(trackingData) ? trackingData : [];
            const safeArchivedData = Array.isArray(archivedData) ? archivedData : [];

            [...safeFinalData, ...safeTrackingData, ...safeArchivedData].forEach(row => {
              if (row && row.No_Orden) { // Added check for row existence
                const key = String(row.No_Orden).trim(); // Ensure key is a string
                if (key) { // Ensure key is not empty
                  const existing = masterDataMap.get(key) || {};
                  // Merge preserving existing values, then overriding with row values
                  const mergedRow = { ...existing, ...row };
                  masterDataMap.set(key, mergedRow);
                }
              }
            });

            const masterData = Array.from(masterDataMap.values());

            if (masterData.length === 0) {
              alert("No hay datos consolidados para exportar.");
              return;
            }

            const wb = XLSX.utils.book_new();

            // Add sheets only if data exists
            if (safeFinalData.length > 0) {
              const ws1 = XLSX.utils.json_to_sheet(safeFinalData);
              XLSX.utils.book_append_sheet(wb, ws1, "Casos en Revisi√≥n");
            }

            if (safeTrackingData.length > 0) {
              const ws2 = XLSX.utils.json_to_sheet(safeTrackingData);
              XLSX.utils.book_append_sheet(wb, ws2, "Seguimiento Activo");
            }

            if (safeArchivedData.length > 0) {
              const ws3 = XLSX.utils.json_to_sheet(safeArchivedData);
              XLSX.utils.book_append_sheet(wb, ws3, "Seguimiento Archivado");
            }

            // Always add Maestro Consolidado if masterData exists
            const ws4 = XLSX.utils.json_to_sheet(masterData);
            XLSX.utils.book_append_sheet(wb, ws4, "Maestro Consolidado");

            XLSX.writeFile(wb, `Sigweb_Reporte_Detallado_${new Date().toISOString().slice(0, 10)}.xlsx`);
          } catch (error) {
            console.error("Fall√≥ la exportaci√≥n del reporte Excel:", error);
            alert("Ocurri√≥ un error al generar el reporte detallado.");
          }
        };


        // =================================================================================
        // INLINED: services/templateService.ts
        // =================================================================================
        const TEMPLATE_STORAGE_KEY = 'sigweb_emailTemplates';

        const loadTemplates = () => {
          try {
            const storedTemplates = localStorage.getItem(TEMPLATE_STORAGE_KEY);
            if (storedTemplates) {
              const parsed = JSON.parse(storedTemplates);
              // Add more robust validation
              if (Array.isArray(parsed) && parsed.every(t => t && typeof t.id === 'string' && typeof t.name === 'string' && typeof t.body === 'string')) {
                 // Check if default templates are missing and add them if necessary
                 const loadedIds = new Set(parsed.map(t => t.id));
                 const missingDefaults = defaultTemplates.filter(dt => !loadedIds.has(dt.id));
                 if (missingDefaults.length > 0) {
                     console.log("Adding missing default templates to loaded templates.");
                     const combined = [...parsed, ...missingDefaults];
                     saveTemplates(combined); // Save the combined list back
                     return combined;
                 }
                 return parsed;
              } else {
                 console.warn("Stored templates data is invalid. Using defaults.");
                 localStorage.removeItem(TEMPLATE_STORAGE_KEY); // Remove invalid data
              }
            }
          } catch (error) {
            console.error("Fall√≥ la carga de plantillas desde localStorage, se usar√°n las predeterminadas.", error);
            localStorage.removeItem(TEMPLATE_STORAGE_KEY); // Remove potentially corrupted data
          }
           // If loading failed or no stored templates, return defaults and save them
           console.log("Using default templates.");
           saveTemplates(defaultTemplates);
           return [...defaultTemplates]; // Return a copy
        };


        const saveTemplates = (templates) => {
          try {
            // Ensure templates is an array before saving
            if (!Array.isArray(templates)) {
              console.error("Attempted to save non-array templates data.");
              return;
            }
            // Ensure basic structure integrity before saving
            if (!templates.every(t => t && typeof t.id === 'string' && typeof t.name === 'string' && typeof t.body === 'string')) {
               console.error("Attempted to save templates with invalid structure.");
               return;
            }
            localStorage.setItem(TEMPLATE_STORAGE_KEY, JSON.stringify(templates));
          } catch (error) {
            console.error("Fall√≥ el guardado de plantillas en localStorage", error);
             // Potentially notify user if storage is full or saving fails critically
             alert("Error: No se pudieron guardar las plantillas localmente. El almacenamiento podr√≠a estar lleno o deshabilitado.");
          }
        };


        // =================================================================================
        // INLINED: services/googleSheetService.ts
        // =================================================================================
        const fetchData = async (url) => {
            console.log("Fetching data from:", url); // Debug log
            if (!url || typeof url !== 'string') {
               throw new Error("URL inv√°lida proporcionada para fetchData.");
            }
            try {
                const response = await fetch(`${url}?action=getData`);
                console.log("Fetch response status:", response.status); // Debug log
                if (!response.ok) {
                    let errorText = `HTTP error ${response.status}`;
                    try {
                       errorText += ` - ${await response.text()}`;
                    } catch (e) { /* Ignore if reading text fails */ }
                    console.error("Network response was not ok:", errorText); // Debug log
                    throw new Error(`La respuesta de la red no fue correcta: ${errorText}`);
                }
                const data = await response.json();
                console.log("Fetched data:", data); // Debug log
                 // Ensure returned data fields are arrays
                 const finalData = Array.isArray(data.finalData) ? data.finalData : [];
                 const trackingData = Array.isArray(data.trackingData) ? data.trackingData : [];
                 const archivedData = Array.isArray(data.archivedData) ? data.archivedData : [];
                 const masterTrackingOrders = Array.isArray(data.masterTrackingOrders) ? data.masterTrackingOrders : [];

                return { finalData, trackingData, archivedData, masterTrackingOrders };
            } catch (error) {
                 console.error("Fetch data failed:", error);
                 // Improve error message for network issues
                 if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                    throw new Error("Error de red: No se pudo conectar al servidor. Verifica la URL y tu conexi√≥n a internet.");
                 }
                 throw error; // Re-throw other errors
            }
        };


        const saveData = async (url, requestBody) => {
            console.log("Saving data to:", url); // Debug log
             if (!url || typeof url !== 'string') {
               throw new Error("URL inv√°lida proporcionada para saveData.");
            }
             // Basic validation for requestBody structure
             if (!requestBody || typeof requestBody !== 'object' || requestBody.action !== 'saveData' || !requestBody.payload) {
                console.error("Invalid request body for saveData:", requestBody);
                throw new Error("Formato de datos inv√°lido para guardar.");
             }
            console.log("Save request body (stringified):", JSON.stringify(requestBody)); // Debug log

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: {
                        'Content-Type': 'text/plain', // Required for no-cors with Apps Script text payload
                    },
                    body: JSON.stringify(requestBody), // Send the whole object including action and payload
                });
                // In no-cors mode, we CANNOT read the response status or body.
                // We assume success if no network error is thrown.
                console.log("Save request sent (no-cors). Assuming success."); // Debug log
                return { status: 'success', message: 'Datos enviados al servidor (no-cors).' };
            } catch (error) {
                console.error("Error during save fetch:", error); // Debug log
                 // Improve error message for network issues
                 if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                    throw new Error("Error de red: No se pudo conectar al servidor para guardar. Verifica la URL y tu conexi√≥n a internet.");
                 }
                throw error; // Re-throw other errors
            }
        };


        // =================================================================================
        // INLINED: components/Spinner.tsx
        // =================================================================================
        const Spinner = () => {
          return (
            <div
              className="inline-block h-8 w-8 animate-spin rounded-full border-4 border-solid border-primary border-r-transparent align-[-0.125em] motion-reduce:animate-[spin_1.5s_linear_infinite]"
              role="status"
            >
              <span className="!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]">
                Cargando...
              </span>
            </div>
          );
        };


        // =================================================================================
        // INLINED: components/Notification.tsx
        // =================================================================================
        const Notification = ({ message, type = 'info', onClose }) => { // Default type to info
          const typeClasses = {
            success: 'bg-green-600',
            error: 'bg-red-600',
            warning: 'bg-yellow-600 text-black', // Use black text for better contrast on yellow
            info: 'bg-blue-600',
          };
          const [isVisible, setIsVisible] = useState(true);

          const handleClose = useCallback(() => {
              setIsVisible(false);
              if (onClose) {
                  onClose(); // Call the original onClose handler if provided
              }
          }, [onClose]);


          // Automatically close after a delay if onClose is provided
          useEffect(() => {
            if (onClose) { // Only set timeout if onClose is meant to auto-close
              const timer = setTimeout(() => {
                handleClose();
              }, 5000); // Default 5 seconds
              return () => clearTimeout(timer);
            }
          }, [handleClose, onClose]); // Depend on handleClose

           if (!isVisible) return null; // Don't render if not visible

          return (
            <div className={`fixed top-5 right-5 z-[250] p-4 rounded-lg shadow-lg text-white ${typeClasses[type] || typeClasses.info} flex items-center gap-4 animate-fade-in-down`}> {/* Added higher z-index and animation */}
              <span>{message}</span>
              {/* Always show close button */}
              <button onClick={handleClose} className="text-xl font-bold leading-none ml-2">&times;</button>
            </div>
          );
        };


        // =================================================================================
        // INLINED: components/Header.tsx
        // =================================================================================
        const Header = React.memo(({ onSave, onManageTemplates, onReconfigure }) => { // Memoize Header
          console.log("Rendering Header"); // Debug log
          return (
            <header className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 pb-4 border-b border-border-color">
              <div>
                <h1 className="text-3xl font-bold text-white">
                  GESTION NEGACIONES EJE CAFETERO
                </h1>
                <p className="text-text-secondary">Sistema Integrado de Gesti√≥n de Flujos de Trabajo</p>
              </div>
              <div className="flex flex-wrap gap-2">
                <button onClick={onManageTemplates} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors">
                  Gestionar Plantillas
                </button>
                <button onClick={onReconfigure} className="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg transition-colors flex items-center gap-2">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0L8.21 5.15a1.5 1.5 0 01-1.25.82l-2.09.28c-1.68.23-2.34 2.26-1.09 3.42l1.52 1.48a1.5 1.5 0 01-.42 2.1l-1.83 1.25c-1.38.94-.92 3.01.7 3.42l2.05.51a1.5 1.5 0 011.1.98l.8 2.07c.43 1.12 2.29 1.12 2.72 0l.8-2.07a1.5 1.5 0 011.1-.98l2.05-.51c1.62-.4 2.08-2.48.7-3.42l-1.83-1.25a1.5 1.5 0 01-.42-2.1l1.52-1.48c1.25-1.16.59-3.19-1.09-3.42L13 5.97a1.5 1.5 0 01-1.25-.82l-.3-1.98zM10 13a3 3 0 100-6 3 3 0 000 6z" clipRule="evenodd" />
                  </svg>
                  Reconfigurar Conexi√≥n
                </button>
                <button onClick={onSave} className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors flex items-center gap-2">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M5.5 16.5a2.5 2.5 0 01-5 0V4.414a1.5 1.5 0 01.44-1.06L4.354.439A1.5 1.5 0 015.414 0H12.5a2.5 2.5 0 012.5 2.5v2" />
                    <path d="M5.5 16.5h8a2.5 2.5 0 002.5-2.5V8.5h-13v5.5a2.5 2.5 0 002.5 2.5z" />
                    <path d="M10.5 10a.5.5 0 01.5-.5h2a.5.5 0 010 1h-2a.5.5 0 01-.5-.5z" />
                  </svg>
                  Guardar en la Nube
                </button>
              </div>
            </header>
          );
        }); // End of Memoized Header


        // =================================================================================
        // INLINED: components/Dashboard.tsx
        // =================================================================================
        const DashboardCard = React.memo(({ title, value, icon }) => ( // Memoize Card
          <div className="bg-surface p-4 rounded-lg border border-border-color flex items-center">
            <div className="text-3xl text-primary mr-4">{icon}</div>
            <div>
              <h4 className="text-sm font-semibold text-text-secondary uppercase tracking-wider">{title}</h4>
              <p className="text-2xl font-bold text-text-primary">{value}</p>
            </div>
          </div>
        ));

        const Dashboard = React.memo(({ reviewCount, trackingCount, archivedCount, editsCount }) => ( // Memoize Dashboard
          <section id="dashboard" className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
            <DashboardCard title="Casos en Revisi√≥n" value={reviewCount} icon={'üìã'} />
            <DashboardCard title="Seguimiento Activo" value={trackingCount} icon={'‚è≥'} />
            <DashboardCard title="Casos Archivados" value={archivedCount} icon={'üóÑÔ∏è'} />
            <DashboardCard title="Ediciones en Sesi√≥n" value={editsCount} icon={'‚úèÔ∏è'} />
          </section>
        )); // End of Memoized Dashboard


        // =================================================================================
        // INLINED: components/DataInputArea.tsx
        // =================================================================================
        const DataInputArea = React.memo(({ // Memoize DataInputArea
          id,
          title,
          headers,
          data,
          onDataChange,
          onProcess,
          processButtonText = "Procesar Datos",
          inputType = "paste", // "paste" or "file"
        }) => {
          console.log(`Rendering DataInputArea: ${id}`); // Debug log

          const handlePaste = useCallback((e) => {
            e.preventDefault();
            const pastedText = e.clipboardData.getData('text/plain');
            const newRows = processPastedData(pastedText, headers);

            // Ensure data is always an array before filtering
            const currentData = Array.isArray(data) ? data : [];
            // Filter out fully empty objects before adding new rows
            const filteredCurrent = currentData.filter(row => row && Object.values(row).some(val => String(val).trim() !== ''));
            const updatedData = [...filteredCurrent, ...newRows];

            // Add empty rows only if it's the paste input type
            if (inputType === 'paste') {
              const emptyRowCount = updatedData.filter(row => !row || !Object.values(row).some(val => String(val).trim() !== '')).length;
              const targetEmptyRows = 5; // Maintain 5 empty rows for pasting
              if (emptyRowCount < targetEmptyRows) {
                for (let i = 0; i < (targetEmptyRows - emptyRowCount); i++) {
                  updatedData.push({}); // Add empty object placeholders
                }
              }
            }

            onDataChange(updatedData);
          }, [data, headers, onDataChange, inputType]);

          const handleCellChange = useCallback((rowIndex, header, value) => {
             // Ensure data is always an array
            const currentData = Array.isArray(data) ? data : [];
            const newData = [...currentData];
            // Ensure the row exists before trying to update it
            if(newData[rowIndex]){
                // Create a new object for the updated row to ensure immutability
                newData[rowIndex] = { ...newData[rowIndex], [header]: value };
            } else {
                 console.warn(`Attempted to edit non-existent row at index ${rowIndex}`);
                 return; // Prevent further processing if row doesn't exist
            }

            // Add/remove empty rows only if it's the paste input type
             if (inputType === 'paste') {
               const targetEmptyRows = 5;
               // Filter out rows that are completely empty or just whitespace
               const nonEmptyRows = newData.filter(row => row && Object.values(row).some(val => String(val).trim() !== ''));
               const currentEmptyRowCount = newData.length - nonEmptyRows.length;

               // Add empty rows if needed
               if (currentEmptyRowCount < targetEmptyRows) {
                   for (let i = 0; i < (targetEmptyRows - currentEmptyRowCount); i++) {
                       nonEmptyRows.push({});
                   }
               }
               // Trim excess empty rows (leave exactly targetEmptyRows)
               const finalData = [...nonEmptyRows];
               while (finalData.filter(row => !row || !Object.values(row).some(val => String(val).trim() !== '')).length > targetEmptyRows && finalData.length > targetEmptyRows) {
                  const lastEmptyIndex = finalData.findLastIndex(row => !row || !Object.values(row).some(val => String(val).trim() !== ''));
                  if (lastEmptyIndex !== -1) {
                      finalData.splice(lastEmptyIndex, 1);
                  } else {
                      break; // Should not happen if logic is correct
                  }
               }
               onDataChange(finalData);
            } else {
                 onDataChange(newData); // For file input, just update the data
            }
          }, [data, onDataChange, inputType]);


          const handleFileChange = useCallback((e) => {
              const file = e.target.files[0];
              if (!file) return;

              const reader = new FileReader();
              reader.onload = (event) => {
                  try {
                      const fileData = new Uint8Array(event.target.result);
                      const workbook = XLSX.read(fileData, { type: 'array', cellDates: true, dateNF: 'yyyy-mm-dd' }); // Specify date format hint
                      const sheetName = workbook.SheetNames[0];
                      const worksheet = workbook.Sheets[sheetName];

                      // Get headers separately
                      const headerRow = XLSX.utils.sheet_to_json(worksheet, { header: 1, range: 0, raw: false, defval: '' })[0] || [];
                      const excelHeaders = headerRow.map(h => String(h).trim());

                       // Convert data rows, ensuring dates are parsed correctly
                       // Use raw: false initially to get formatted strings
                      const jsonDataObjects = XLSX.utils.sheet_to_json(worksheet, { raw: false, defval: '' });


                      if (jsonDataObjects.length === 0) {
                          alert("El archivo Excel no contiene filas de datos.");
                          return;
                      }

                      const normalizeHeadersAndData = (d, excelHeaderList) => {
                           // Define mappings based on expected Excel headers (case-insensitive)
                           // Use lowercase keys for robust matching
                          const keyMap = {
                              'fecha neg.': 'Fecha_Neg', 'no. orden': 'No_Orden', 'no. c√©dula': 'No_Cedula',
                              'entidad ejecutora': 'Entidad_Ejecutora', 'motivo negaci√≥n': 'Motivo_Negacion',
                              'usuario emiti√≥': 'Usuario_Emitio', 'observaci√≥n auditor': 'Observacion_Auditor',
                              'observaci√≥n ejecutivo': 'Observacion_Ejecutivo', 'antig√ºedad': 'Antiguedad',
                              'tel√©fono': 'Telefono', 'direcci√≥n': 'Direccion', 'tipo usuario': 'Tipo_Usuario',
                              'notificaci√≥n': 'Notificacion', 'gesti√≥n': 'Gestion_Negacion',
                              'observaci√≥n alternativa': 'Observacion_Alternativa', 'nit prestador': 'Nit_Prestador',
                              'fecha complementariedad': 'Fecha_Complementariedad', 'tiempo de gestion': 'Tiempo_de_Gestion',
                              // Add other expected headers from PORTAL_HEADERS in lowercase
                              'sucursal': 'Sucursal', 'nombre': 'Nombre', 'programa': 'Programa', 'plan': 'Plan',
                              'eps': 'EPS', 'celular': 'Celular', 'email': 'Email', 'edad': 'Edad', 'llamada': 'Llamada',
                              'complementariedad': 'Complementariedad', 'alternativa': 'Alternativa', 'monto': 'Monto',
                              'regional': 'Regional'
                          };
                          const dateKeysInternal = new Set(['Fecha_Neg', 'Fecha_Complementariedad']); // Internal keys expected to be dates

                           // Helper to attempt date parsing from various string formats or Excel numbers
                          const parseDateValue = (value) => {
                              if (value === null || value === undefined || String(value).trim() === '') return ''; // Return empty string for empty input
                              if (typeof value === 'number') { // Excel serial date
                                 try {
                                    const jsDate = XLSX.SSF.parse_date_code(value);
                                    if(jsDate) {
                                       // Format consistently as YYYY-MM-DD
                                       const year = jsDate.y;
                                       const month = String(jsDate.m).padStart(2, '0');
                                       const day = String(jsDate.d).padStart(2, '0');
                                       return `${year}-${month}-${day}`;
                                    }
                                 } catch (dateError) {
                                     console.warn("Error parsing Excel date number:", value, dateError);
                                 }
                              } else if (typeof value === 'string') {
                                  // Try common formats like DD/MM/YYYY, MM/DD/YYYY, YYYY-MM-DD etc.
                                  // Simple check for YYYY-MM-DD first
                                  if (/^\d{4}-\d{2}-\d{2}$/.test(value)) return value;

                                  // Attempt parsing other formats (this can be complex, keep it simple for now)
                                  try {
                                      // Handle DD/MM/YYYY specifically if common
                                      const parts = value.match(/(\d{1,2})[/|-](\d{1,2})[/|-](\d{4})/);
                                      if (parts) {
                                          // Assuming DD/MM/YYYY - adjust if MM/DD/YYYY is possible
                                          const year = parseInt(parts[3], 10);
                                          const month = String(parseInt(parts[2], 10)).padStart(2, '0');
                                          const day = String(parseInt(parts[1], 10)).padStart(2, '0');
                                          // Basic validation
                                          if (year > 1900 && parseInt(month, 10) >= 1 && parseInt(month, 10) <= 12 && parseInt(day, 10) >= 1 && parseInt(day, 10) <= 31) {
                                             return `${year}-${month}-${day}`;
                                          }
                                      }
                                      // Generic Date parsing (less reliable for ambiguous formats)
                                      const parsed = new Date(value);
                                      if (!isNaN(parsed)) {
                                          const year = parsed.getFullYear();
                                          const month = String(parsed.getMonth() + 1).padStart(2, '0');
                                          const day = String(parsed.getDate()).padStart(2, '0');
                                          return `${year}-${month}-${day}`;
                                      }
                                  } catch (parseError) {
                                      console.warn("Could not parse date string:", value, parseError);
                                  }
                              }
                              // If parsing fails, return the original value as string
                              console.warn(`Returning original value for date column as string:`, value);
                              return String(value);
                          };


                          return d.map(row => {
                              const newRow = {};
                              // Initialize all PORTAL_HEADERS with empty strings
                              PORTAL_HEADERS.forEach(header => { newRow[header] = ''; });

                              for (const key in row) {
                                  const trimmedKeyLower = String(key).trim().toLowerCase();
                                  const internalKey = keyMap[trimmedKeyLower]; // Find the corresponding internal key

                                  if (internalKey) { // If the Excel header is recognized
                                     if (dateKeysInternal.has(internalKey)) {
                                         newRow[internalKey] = parseDateValue(row[key]);
                                     } else {
                                         // Assign value directly for non-date columns, ensuring it's a string
                                         newRow[internalKey] = row[key] !== null && row[key] !== undefined ? String(row[key]) : '';
                                     }
                                  } else {
                                     // Optionally handle unrecognized columns (e.g., log them)
                                     // console.warn(`Unrecognized column header in Excel: "${key}"`);
                                     // You could store them with a prefix, e.g., newRow[`excel_${key.replace(/ /g, '_')}`] = String(row[key]);
                                  }
                              }
                              return newRow;
                          });
                      };


                      const normalizedData = normalizeHeadersAndData(jsonDataObjects, excelHeaders);
                      onDataChange(normalizedData);
                      e.target.value = null; // Reset file input
                  } catch (error) {
                      console.error("Error processing Excel file:", error);
                      alert("Hubo un error al procesar el archivo Excel. Aseg√∫rate de que el formato y las columnas son correctos.\n" + error.message);
                      onDataChange([]); // Clear data on error
                  }
              };
              reader.onerror = (error) => {
                   console.error("Error reading file:", error);
                   alert("Hubo un error al leer el archivo.");
                   onDataChange([]); // Clear data on error
              };
              reader.readAsArrayBuffer(file);
          }, [onDataChange, headers]); // Include headers in dependencies for processPastedData

          const clearTable = useCallback(() => {
            onDataChange(inputType === 'paste' ? Array(5).fill({}) : []);
          }, [inputType, onDataChange]);

          // Ensure 'data' is always an array for rendering
          const renderData = useMemo(() => Array.isArray(data) ? data : (inputType === 'paste' ? Array(5).fill({}) : []), [data, inputType]);


          return (
            <section id={id} className="space-y-4">
              <h2 className="text-2xl font-bold text-primary border-b border-border-color pb-2">{title}</h2>

              {inputType === 'file' && (
                 <div className="flex items-center gap-4">
                   <label htmlFor={`${id}-file-upload`} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors cursor-pointer">
                       Subir Archivo Excel
                   </label>
                   <input
                       id={`${id}-file-upload`}
                       type="file"
                       className="hidden"
                       accept=".xlsx, .xls, .csv" // Added CSV support
                       onChange={handleFileChange}
                   />
                   <span className="text-text-secondary">{renderData.length > 0 && renderData.some(row => Object.values(row).some(v=>v)) ? `${renderData.filter(row => Object.values(row).some(v=>v)).length} fila(s) cargada(s)` : 'Ning√∫n archivo seleccionado'}</span>
                 </div>
              )}

              <div className="table-container max-h-72 overflow-auto border border-border-color rounded-lg">
                <table className="w-full text-sm text-left text-text-secondary table-fixed"> {/* Use table-fixed */}
                  <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                    <tr>
                      {headers.map(header => (
                        <th key={header} scope="col" className="px-4 py-3 whitespace-nowrap overflow-hidden text-ellipsis w-40">{header.replace(/_/g, ' ')}</th> // Add fixed width
                      ))}
                    </tr>
                  </thead>
                  <tbody onPaste={inputType === 'paste' ? handlePaste : undefined}>
                    {renderData.map((row, rowIndex) => (
                      <tr key={rowIndex} className="border-b border-border-color hover:bg-highlight group">
                        {headers.map(header => (
                          <td
                            key={`${rowIndex}-${header}`}
                            className="px-4 py-2 border-r border-border-color focus:bg-primary focus:text-black outline-none whitespace-nowrap overflow-hidden text-ellipsis w-40 group-focus-within:whitespace-normal group-hover:whitespace-normal" // Adjust width, handle wrap on focus/hover
                            contentEditable={inputType === 'paste'}
                            onBlur={inputType === 'paste' ? (e) => handleCellChange(rowIndex, header, e.currentTarget.innerText) : undefined}
                            suppressContentEditableWarning={true}
                          >
                            {(typeof row === 'object' && row !== null && row[header] !== undefined) ? String(row[header]) : ''}
                          </td>
                        ))}
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
              <div className="flex gap-4">
                <button
                    onClick={onProcess}
                    // Disable if renderData is empty or (if paste type) all rows are effectively empty
                    disabled={renderData.length === 0 || (inputType === 'paste' && renderData.every(row => !row || !Object.values(row).some(val => String(val).trim() !== '')))}
                    className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed"
                 >
                  {processButtonText}
                </button>
                <button onClick={clearTable} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                  Limpiar Tabla
                </button>
              </div>
            </section>
          );
        }); // End of Memoized DataInputArea


        // =================================================================================
        // INLINED: components/ReviewArea.tsx
        // =================================================================================
        const ReviewArea = React.memo(({ // Memoize ReviewArea
          data,
          templates,
          updateRow,
          incrementEdits,
          onSendToTracking,
          onPreview,
          onExportForMailMerge,
          onClearReviewData,
          sortConfig,
          setSortConfig,
        }) => {
          console.log("Rendering ReviewArea"); // Debug log
          const [selectedRows, setSelectedRows] = useState(new Set());
          const [filter, setFilter] = useState('');

          const REVIEW_HEADERS = useMemo(() => [ // Memoize headers array
              { key: 'Fecha_Neg', label: 'Fecha Neg.' },
              { key: 'No_Orden', label: 'No. Orden' },
              { key: 'No_Cedula', label: 'No. C√©dula' },
              { key: 'Nombre', label: 'Nombre' },
              { key: 'EPS', label: 'EPS' },
              { key: 'Programa', label: 'Programa', compact: true },
              { key: 'Motivo_Negacion', label: 'Motivo Neg.', compact: true },
              { key: 'Descripcion_PDF', label: 'Descripci√≥n', compact: true },
              { key: 'Justificacion_PDF', label: 'Justificaci√≥n', compact: true },
              { key: 'Fundamento_Legal_PDF', label: 'Fund. Legal', compact: true },
          ], []);

          // Ensure 'data' is always an array before filtering/sorting
          const currentData = Array.isArray(data) ? data : [];

          const filteredData = useMemo(() => {
            if (!filter) return currentData;
            const lowercasedFilter = filter.toLowerCase();
            return currentData.filter(row =>
              row && typeof row === 'object' && // Ensure row is a valid object
              Object.values(row).some(value =>
                String(value).toLowerCase().includes(lowercasedFilter)
              )
            );
          }, [currentData, filter]); // Depend on currentData


          // Clear selection when filtered data changes drastically
          useEffect(() => {
             setSelectedRows(prevSelected => {
                 const currentKeys = new Set(filteredData.map(r => String(r.No_Orden)));
                 const newSelection = new Set();
                 for (const key of prevSelected) {
                     if (currentKeys.has(key)) {
                         newSelection.add(key);
                     }
                 }
                 return newSelection;
             });
          }, [filteredData]);


          const handleSelectRow = useCallback((noOrden) => {
            const key = String(noOrden); // Ensure key is string for Set consistency
            setSelectedRows(prevSelection => {
               const newSelection = new Set(prevSelection);
               if (newSelection.has(key)) {
                 newSelection.delete(key);
               } else {
                 newSelection.add(key);
               }
               return newSelection;
            });
          }, []); // No external dependencies

          const handleSelectAll = useCallback((e) => {
            if (e.target.checked) {
              const allOrderNumbers = filteredData
                .map(row => row ? String(row.No_Orden) : null) // Get No_Orden as string, handle potential null rows
                .filter(Boolean); // Remove nulls/undefined
              setSelectedRows(new Set(allOrderNumbers));
            } else {
              setSelectedRows(new Set());
            }
          }, [filteredData]); // Depends on filteredData

          const handleCellBlur = useCallback((noOrden, key, value) => {
            // Find row using string comparison for No_Orden IN THE ORIGINAL (unfiltered) data
             const originalRow = currentData.find(r => r && String(r.No_Orden) === String(noOrden));
             if (originalRow && String(originalRow[key] || '') !== value) { // Compare as strings, handle undefined/null
               updateRow(noOrden, { [key]: value }); // Pass original noOrden (might be number or string)
               // incrementEdits() is called within updateFinalDataRow now
             }
          }, [currentData, updateRow]); // Depends on currentData


          const handleSelectChange = useCallback((noOrden, value) => {
            const changes = { Tipo_Carta: value };
            const safeTemplates = Array.isArray(templates) ? templates : []; // Ensure templates is array
            const template = safeTemplates.find(t => t.id === value);
            // Reset Radicado_Comp only if changing *away* from a Complementariedad template or to no template
            if (!template || !template.name.toUpperCase().includes('COMPLEMENTARIEDAD')) {
               changes.Radicado_Comp = '';
            }
             // Pass original noOrden (might be number or string)
            updateRow(noOrden, changes);
            // incrementEdits() is called within updateFinalDataRow now
          }, [templates, updateRow]); // Depends on templates


          const requestSort = useCallback((key) => {
            setSortConfig(currentSortConfig => {
                let direction = 'ascending';
                if (currentSortConfig.key === key && currentSortConfig.direction === 'ascending') {
                  direction = 'descending';
                }
               return { key, direction };
            });
          }, [setSortConfig]); // Depends on setSortConfig

          const getSortIndicator = useCallback((key) => {
            if (sortConfig.key !== key) return null;
            return sortConfig.direction === 'ascending' ? ' ‚ñ≤' : ' ‚ñº';
          }, [sortConfig]); // Depends on sortConfig

          const handleExport = useCallback(() => {
              onExportForMailMerge(currentData); // Export original unfiltered/unsorted data
          }, [onExportForMailMerge, currentData]);


          return (
            <section id="area3" className="space-y-4">
              <h2 className="text-2xl font-bold text-primary border-b border-border-color pb-2">√Årea 3: Revisi√≥n Final y Exportaci√≥n</h2>
              <div className="action-bar bg-highlight p-4 rounded-lg flex flex-wrap items-center gap-4">
                <input
                  type="text"
                  placeholder="Buscar en tabla de revisi√≥n..."
                  className="bg-surface border border-border-color rounded-md px-3 py-2 text-text-primary placeholder-text-secondary w-full sm:w-auto"
                  value={filter}
                  onChange={(e) => setFilter(e.target.value)}
                />
                <span className="text-text-primary">{selectedRows.size} fila(s) seleccionada(s)</span>
              </div>

              <div className="table-container max-h-[70vh] overflow-auto border border-border-color rounded-lg"> {/* Increased max height */}
                <table className="w-full text-sm text-left text-text-secondary table-fixed"> {/* table-fixed */}
                  <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                    <tr>
                      <th className="px-4 py-3 w-10"><input type="checkbox" onChange={handleSelectAll} checked={filteredData.length > 0 && selectedRows.size === filteredData.length && selectedRows.size > 0} /></th> {/* Fixed width */}
                      <th className="px-4 py-3 w-10">üëÅÔ∏è</th> {/* Fixed width */}
                       {REVIEW_HEADERS.map(({ key, label, compact }) => (
                         <th key={key} onClick={() => requestSort(key)} className={`px-4 py-3 cursor-pointer whitespace-nowrap overflow-hidden text-ellipsis ${compact ? 'w-32' : 'w-48'}`}> {/* Widths */}
                             {label}{getSortIndicator(key)}
                         </th>
                       ))}
                      <th className="px-4 py-3 w-56">Tipo de Carta</th> {/* Width */}
                    </tr>
                  </thead>
                  <tbody>
                   {filteredData.map((row) => { // Map over filteredData for rendering
                      if (!row || typeof row !== 'object' || !row.No_Orden) {
                        // This check might be redundant if data source is clean, but safe
                        console.warn("Skipping potentially invalid row in ReviewArea render:", row);
                        return null;
                      }

                      const noOrdenKey = String(row.No_Orden);
                      const safeTemplates = Array.isArray(templates) ? templates : [];
                      const template = safeTemplates.find(t => t.id === row.Tipo_Carta);
                      const isComplementariedad = template && template.name.toUpperCase().includes('COMPLEMENTARIEDAD');
                      const requiresRadicado = isComplementariedad;

                      return (
                        <tr key={noOrdenKey} className={`border-b border-border-color hover:bg-highlight group ${isComplementariedad ? 'bg-indigo-900/50' : ''} ${selectedRows.has(noOrdenKey) ? 'bg-primary/20' : ''}`}>
                          <td className="px-4 py-2 w-10"><input type="checkbox" checked={selectedRows.has(noOrdenKey)} onChange={() => handleSelectRow(noOrdenKey)} /></td>
                          <td className="px-4 py-2 text-lg cursor-pointer w-10 text-center" onClick={() => onPreview(row)}>üëÅÔ∏è</td>
                          {REVIEW_HEADERS.map(({ key, compact }) => (
                            <td key={key}
                                className={`px-4 py-2 border-r border-border-color outline-none whitespace-nowrap overflow-hidden text-ellipsis focus:bg-primary focus:text-black group-focus-within:whitespace-normal group-hover:whitespace-normal ${compact ? 'w-32' : 'w-48'}`}
                                contentEditable
                                onBlur={(e) => handleCellBlur(row.No_Orden, key, e.currentTarget.innerText)}
                                suppressContentEditableWarning={true}
                                // Use dangerouslySetInnerHTML ONLY if you trust the source or sanitize it.
                                // Prefer rendering text directly. If HTML is needed, consider a safe renderer.
                            >
                                {String(row[key] ?? '')} {/* Ensure value is string, default empty */}
                            </td>
                          ))}
                          <td className="px-4 py-2 w-56">
                            <div className="flex flex-col gap-1">
                              <select
                                value={row.Tipo_Carta || ''}
                                onChange={(e) => handleSelectChange(row.No_Orden, e.target.value)}
                                className="bg-surface border border-border-color rounded-md px-2 py-1 text-text-primary w-full text-xs" // smaller text
                              >
                                <option value="">-- Seleccionar --</option>
                                {safeTemplates.map(t => <option key={t.id} value={t.id} title={t.name}>{t.name}</option>)}
                              </select>
                              {requiresRadicado && (
                                <input
                                  type="text"
                                  placeholder="Radicado..."
                                  value={row.Radicado_Comp || ''}
                                  onChange={(e) => updateRow(row.No_Orden, { Radicado_Comp: e.target.value })}
                                  className="bg-surface border border-border-color rounded-md px-2 py-1 text-text-primary w-full mt-1 text-xs" // smaller text
                                />
                              )}
                            </div>
                          </td>
                        </tr>
                      );
                    })}
                     {filteredData.length === 0 && (
                        <tr><td colSpan={REVIEW_HEADERS.length + 3} className="text-center py-4 text-text-secondary italic">No hay casos en revisi√≥n o no coinciden con la b√∫squeda.</td></tr>
                     )}
                  </tbody>
                </table>
              </div>
              <div className="flex flex-wrap gap-4">
                <button
                    onClick={() => onSendToTracking(Array.from(selectedRows))}
                    disabled={selectedRows.size === 0}
                    className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Enviar a Seguimiento ({selectedRows.size})
                </button>
                 <button
                    onClick={handleExport}
                    disabled={currentData.length === 0}
                    className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                 >
                   Exportar para Env√≠o Masivo ({currentData.length})
                 </button>
                <button
                    onClick={onClearReviewData}
                    className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors"
                >
                  Limpiar Tabla de Revisi√≥n
                </button>
              </div>
            </section>
          );
        }); // End of Memoized ReviewArea


        // =================================================================================
        // INLINED: components/TrackingArea.tsx
        // =================================================================================
        const TrackingTable = React.memo(({ data, isArchived, onUpdate, onArchive, filter }) => { // Memoize TrackingTable
            console.log(`Rendering TrackingTable (Archived: ${isArchived})`); // Debug log

          const [selectedRows, setSelectedRows] = useState(new Set());

          const statusClasses = useMemo(() => ({ // Memoize status classes object
            'Pendiente': 'bg-yellow-600/20',
            'En Gesti√≥n': 'bg-blue-600/20',
            'Finalizado': 'bg-green-600/20',
          }), []);

          // Ensure data is always an array
          const currentData = Array.isArray(data) ? data : [];

          const filteredData = useMemo(() => {
            if (!filter) return currentData;
            const lowercasedFilter = filter.toLowerCase();
            return currentData.filter(row =>
              row && typeof row === 'object' && // Ensure row is valid
              Object.values(row).some(value =>
                String(value).toLowerCase().includes(lowercasedFilter)
              )
            );
          }, [currentData, filter]); // Depend on currentData

          // Clear selection when filtered data changes
           useEffect(() => {
               setSelectedRows(prevSelected => {
                   const currentIndices = new Set(filteredData.map(r => currentData.indexOf(r)).filter(i => i !== -1));
                   const newSelection = new Set();
                   for (const index of prevSelected) {
                       if (currentIndices.has(index)) {
                           newSelection.add(index);
                       }
                   }
                   return newSelection;
               });
           }, [filteredData, currentData]);


          const handleSelectRow = useCallback((index) => {
            setSelectedRows(prevSelection => {
               const newSelection = new Set(prevSelection);
               if (newSelection.has(index)) {
                 newSelection.delete(index);
               } else {
                 newSelection.add(index);
               }
               return newSelection;
            });
          }, []); // No external deps

          const handleSelectAll = useCallback((e) => {
            if (e.target.checked) {
               // Use indices of the currently filtered data mapped back to original indices
              setSelectedRows(new Set(filteredData.map((row) => currentData.indexOf(row)).filter(index => index !== -1)));
            } else {
              setSelectedRows(new Set());
            }
          }, [filteredData, currentData]); // Depends on filteredData and currentData

          const handleBulkArchive = useCallback(() => {
            if (selectedRows.size > 0) {
              onArchive(Array.from(selectedRows)); // Pass indices
              setSelectedRows(new Set()); // Clear selection after action
            }
          }, [selectedRows, onArchive]); // Depends on selectedRows

          const handleCellUpdate = useCallback((originalIndex, field, value) => {
               const row = currentData[originalIndex];
               // Only call update if value actually changed
               if (row && String(row[field] || '') !== value) {
                  onUpdate(originalIndex, { ...row, [field]: value });
               }
           }, [currentData, onUpdate]);


          return (
            <div className="space-y-4">
              <div className="flex justify-between items-center">
                   <span className="text-text-secondary text-sm">
                       {selectedRows.size > 0 ? `${selectedRows.size} seleccionado(s)` : ''}
                   </span>
                   {selectedRows.size > 0 && (
                       <button
                           onClick={handleBulkArchive}
                           className={`font-bold py-2 px-4 rounded-lg transition-colors text-white ${isArchived ? 'bg-green-600 hover:bg-green-700' : 'bg-gray-600 hover:bg-gray-700'}`}
                       >
                           {isArchived ? `‚ôªÔ∏è Restaurar (${selectedRows.size})` : `üóÑÔ∏è Archivar (${selectedRows.size})`}
                       </button>
                   )}
              </div>
              <div className="table-container max-h-[40vh] overflow-auto border border-border-color rounded-lg"> {/* Adjusted height */}
                <table className="w-full text-sm text-left text-text-secondary table-fixed"> {/* table-fixed */}
                  <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                    <tr>
                      <th className="px-4 py-3 w-10"><input type="checkbox" onChange={handleSelectAll} checked={filteredData.length > 0 && selectedRows.size === filteredData.length && selectedRows.size > 0}/></th> {/* Width */}
                      <th className="px-4 py-3 w-32">Fecha Ing.</th> {/* Width */}
                      <th className="px-4 py-3 w-32">No. Orden</th> {/* Width */}
                      <th className="px-4 py-3 w-48">Nombre</th> {/* Width */}
                      <th className="px-4 py-3 w-32">EPS</th> {/* Width */}
                      <th className="px-4 py-3 w-32">Radicado</th> {/* Width */}
                      <th className="px-4 py-3 w-36">Estado</th> {/* Width */}
                      <th className="px-4 py-3 flex-1 min-w-[200px]">Notas</th> {/* Flexible width */}
                      <th className="px-4 py-3 w-16">Acci√≥n</th> {/* Width */}
                    </tr>
                  </thead>
                  <tbody>
                   {filteredData.map((row) => {
                       const originalIndex = currentData.indexOf(row);
                       if (!row || typeof row !== 'object' || originalIndex === -1) return null;

                       const rowClasses = `border-b border-border-color hover:bg-highlight transition-colors group ${isArchived ? 'bg-archive/30 text-text-secondary' : statusClasses[row.Estado] || ''} ${selectedRows.has(originalIndex) ? '!bg-primary/30' : ''}`; // Use !important for selection highlight


                      return (
                        <tr key={originalIndex} className={rowClasses}>
                          <td className="px-4 py-2 w-10"><input type="checkbox" checked={selectedRows.has(originalIndex)} onChange={() => handleSelectRow(originalIndex)} /></td>
                          <td className="px-4 py-2 w-32 whitespace-nowrap">{row.Fecha_Ing || ''}</td>
                          <td className="px-4 py-2 w-32 whitespace-nowrap">{row.No_Orden || ''}</td>
                          <td className="px-4 py-2 w-48 whitespace-nowrap overflow-hidden text-ellipsis" title={row.Nombre}>{row.Nombre || ''}</td>
                          <td className="px-4 py-2 w-32 whitespace-nowrap overflow-hidden text-ellipsis" title={row.EPS}>{row.EPS || ''}</td>
                          <td className="px-4 py-2 w-32 whitespace-nowrap overflow-hidden text-ellipsis" title={row.Radicado}>{row.Radicado || ''}</td>
                          <td className="px-4 py-2 w-36">
                            <select
                              value={row.Estado || TRACKING_STATUSES[0]}
                              onChange={e => handleCellUpdate(originalIndex, 'Estado', e.target.value)}
                              className="bg-surface border border-border-color rounded-md px-2 py-1 text-text-primary w-full text-xs" // smaller text
                              disabled={isArchived} // Disable editing in archive
                            >
                              {TRACKING_STATUSES.map(s => <option key={s} value={s}>{s}</option>)}
                            </select>
                          </td>
                          <td
                              className="px-4 py-2 outline-none focus:bg-primary focus:text-black min-w-[200px] group-focus-within:whitespace-normal group-hover:whitespace-normal" // Allow wrap on focus/hover
                              contentEditable={!isArchived} // Disable editing in archive
                              onBlur={e => handleCellUpdate(originalIndex, 'Notas', e.currentTarget.innerText)}
                              suppressContentEditableWarning={true}
                              // Render plain text, avoid dangerouslySetInnerHTML unless absolutely necessary and sanitized
                           >
                                {row.Notas || ''}
                           </td>
                          <td className="px-4 py-2 text-lg cursor-pointer w-16 text-center" onClick={() => onArchive([originalIndex])}>{isArchived ? '‚ôªÔ∏è' : 'üóÑÔ∏è'}</td>
                        </tr>
                      );
                    })}
                     {filteredData.length === 0 && (
                        <tr><td colSpan={9} className="text-center py-4 text-text-secondary italic">
                            {isArchived ? 'No hay casos archivados' : 'No hay casos activos'} {filter ? ' que coincidan con la b√∫squeda.' : '.'}
                        </td></tr>
                     )}
                  </tbody>
                </table>
              </div>
            </div>
          );
        }); // End of Memoized TrackingTable

        const TrackingArea = React.memo(({ trackingData, archivedData, updateTrackingData, archiveItems }) => { // Memoize TrackingArea
          console.log("Rendering TrackingArea"); // Debug log
          const [showArchived, setShowArchived] = useState(false);
          const [filter, setFilter] = useState('');
           // Ensure data props are arrays
          const currentTrackingData = Array.isArray(trackingData) ? trackingData : [];
          const currentArchivedData = Array.isArray(archivedData) ? archivedData : [];


          return (
            <section id="area4" className="space-y-4">
              <h2 className="text-2xl font-bold text-primary border-b border-border-color pb-2">√Årea 4: Seguimiento</h2>
              <div className="action-bar bg-highlight p-4 rounded-lg flex flex-wrap items-center gap-4 justify-between">
                <input
                  type="text"
                  placeholder="Buscar en seguimiento (Activos y Archivados)..."
                  className="bg-surface border border-border-color rounded-md px-3 py-2 text-text-primary placeholder-text-secondary w-full sm:w-1/2 lg:w-1/3"
                  value={filter}
                  onChange={e => setFilter(e.target.value)}
                />
                <button onClick={() => setShowArchived(!showArchived)} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">
                  {showArchived ? 'Ocultar' : 'Mostrar'} Archivados ({currentArchivedData.length})
                </button>
              </div>

              <h3 className="text-xl font-semibold text-white">Casos Activos ({currentTrackingData.length})</h3>
              <TrackingTable
                data={currentTrackingData} // Pass guaranteed array
                isArchived={false}
                onUpdate={updateTrackingData} // Pass the callback directly
                onArchive={archiveItems} // Pass the callback directly
                filter={filter}
              />

              {showArchived && (
                <div className="mt-8">
                  <h3 className="text-xl font-semibold text-white">Casos Archivados ({currentArchivedData.length})</h3>
                  <TrackingTable
                    data={currentArchivedData} // Pass guaranteed array
                    isArchived={true}
                    onUpdate={updateTrackingData} // Pass the callback directly
                    onArchive={archiveItems} // Pass the callback directly
                    filter={filter}
                  />
                </div>
              )}
            </section>
          );
        }); // End of Memoized TrackingArea

        // =================================================================================
        // INLINED: components/SetupModal.tsx
        // =================================================================================
        const SetupModal = ({ onSave, onClose, initialUrl = '' }) => { // Cannot easily memoize modals with internal state like this
          const [url, setUrl] = useState(initialUrl);
          const [isVerifying, setIsVerifying] = useState(false);
          const [errorMsg, setErrorMsg] = useState(''); // State for error message

          const handleSave = async () => {
            setErrorMsg(''); // Clear previous errors
            if (!url || !url.startsWith('https://script.google.com/macros/s/')) {
              setErrorMsg("Por favor, introduce una URL v√°lida de Google Apps Script (debe empezar con https://script.google.com/macros/s/).");
              return;
            }
            setIsVerifying(true);
            try {
                // onSave should throw an error if verification fails
                await onSave(url);
                // No need to explicitly close here, parent component handles it on success via state update
            } catch (error) {
                 console.error("Verification failed:", error);
                 // Display a user-friendly error message from the caught error
                 setErrorMsg(`Fall√≥ la verificaci√≥n: ${error.message}. Revisa la URL y los permisos.`);
            } finally {
                setIsVerifying(false); // Ensure verifying state is reset even if error occurs
            }
          };

          return (
            <div className="fixed inset-0 bg-background bg-opacity-90 flex justify-center items-center z-[200] p-4"> {/* Increased z-index */}
              <div className="bg-surface rounded-lg shadow-xl w-full max-w-lg border border-border-color p-8 space-y-6">
                <div className="text-center">
                  <h2 className="text-2xl font-bold text-primary">Configuraci√≥n de Conexi√≥n</h2>
                  <p className="text-text-secondary mt-2">
                      Proporciona la URL de Google Apps Script implementada como aplicaci√≥n web.
                  </p>
                </div>
                <div>
                  <label htmlFor="script-url" className="block text-sm font-medium text-text-primary mb-1">
                      URL del Script
                  </label>
                  <input
                      id="script-url"
                      type="url"
                      value={url}
                      onChange={(e) => { setUrl(e.target.value); setErrorMsg(''); }} // Clear error on change
                      placeholder="https://script.google.com/macros/s/..."
                      className={`w-full bg-background border rounded-md px-3 py-2 text-text-primary placeholder-text-secondary focus:ring-primary focus:border-primary ${errorMsg ? 'border-danger' : 'border-border-color'}`} // Highlight on error
                      aria-invalid={!!errorMsg}
                      aria-describedby="url-error"
                  />
                  {errorMsg && <p id="url-error" className="text-danger text-sm mt-1">{errorMsg}</p>}
                </div>
                <div className="flex justify-end gap-4">
                  <button
                      onClick={onClose} // Let parent handle close logic
                      disabled={isVerifying}
                      className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                      Cancelar
                  </button>
                  <button
                      onClick={handleSave}
                      disabled={isVerifying || !url}
                      className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed min-w-[150px] flex justify-center items-center" // Ensure button size stays consistent
                  >
                      {isVerifying ? <Spinner /> : 'Guardar y Verificar'}
                  </button>
                </div>
              </div>
            </div>
          );
        };

        // =================================================================================
        // INLINED: components/TemplateManagerModal.tsx
        // =================================================================================
        const TemplateManagerModal = ({ templates, onClose, onSave, onReset }) => { // Cannot easily memoize modals
          const [currentTemplates, setCurrentTemplates] = useState(() => structuredClone(Array.isArray(templates) ? templates : [])); // Deep clone initial templates
          const [editingTemplate, setEditingTemplate] = useState(null); // Holds the template being edited/created

          const handleSaveLocal = useCallback(() => {
            // Add validation before saving if needed
            onSave(currentTemplates); // Pass the current state up
          }, [currentTemplates, onSave]);

          const handleAddNew = useCallback(() => {
            // Create a truly new ID for the new template
            setEditingTemplate({ id: `custom_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`, name: '', body: '' });
          }, []);

          const handleEdit = useCallback((template) => {
             // Create a copy for editing to avoid modifying the list directly
             setEditingTemplate({ ...template });
          }, []);

          const handleDelete = useCallback((idToDelete) => {
            if (window.confirm('¬øEst√°s seguro de que quieres eliminar esta plantilla? Esta acci√≥n no se puede deshacer.')) {
              setCurrentTemplates(current => current.filter(t => t.id !== idToDelete)); // Use functional update
            }
          }, []);

          const handleSaveTemplateEdit = useCallback(() => {
            if (!editingTemplate || !editingTemplate.name.trim() || !editingTemplate.body.trim()) {
              alert('El nombre y el cuerpo de la plantilla no pueden estar vac√≠os.');
              return;
            }

            setCurrentTemplates(current => {
                const updatedTemplates = Array.isArray(current) ? [...current] : []; // Ensure it's an array
                const existingIndex = updatedTemplates.findIndex(t => t.id === editingTemplate.id);
                if (existingIndex > -1) {
                    // Update existing
                    updatedTemplates[existingIndex] = { ...editingTemplate }; // Ensure it's a new object
                } else {
                    // Add new
                    updatedTemplates.push({ ...editingTemplate }); // Ensure it's a new object
                }
                return updatedTemplates;
            });
            setEditingTemplate(null); // Close editor
          }, [editingTemplate]); // Depends on the template being edited


           // Handler for input changes within the editor
           const handleEditorChange = useCallback((field, value) => {
                setEditingTemplate(prev => prev ? ({ ...prev, [field]: value }) : null);
           }, []);


          return (
            <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[150] p-4"> {/* Increased z-index */}
              <div className="bg-surface rounded-lg shadow-xl w-full max-w-4xl border border-border-color flex flex-col max-h-[90vh]">
                <div className="p-6 border-b border-border-color flex justify-between items-center flex-shrink-0"> {/* Header */}
                  <h3 className="text-xl font-bold text-primary">Gestionar Plantillas de Correo</h3>
                  <button onClick={onClose} className="text-text-secondary text-2xl hover:text-text-primary">&times;</button>
                </div>

                <div className="p-6 overflow-y-auto space-y-6 flex-grow"> {/* Content Area */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6 h-full"> {/* Layout */}

                    {/* Left Side: List of Templates */}
                    <div className="flex flex-col h-full">
                      <div className="flex justify-between items-center mb-2">
                         <h4 className="text-lg font-semibold">Plantillas Actuales</h4>
                         <button onClick={handleAddNew} className="bg-green-600 hover:bg-green-700 text-white text-xs font-bold py-1 px-2 rounded disabled:opacity-50" disabled={!!editingTemplate}>
                           + Nueva
                         </button>
                      </div>
                      <ul className="space-y-2 border border-border-color rounded-lg p-2 overflow-y-auto flex-grow bg-background/30">
                        {currentTemplates.map(template => (
                          <li key={template.id} className={`flex justify-between items-center p-2 rounded transition-colors ${editingTemplate?.id === template.id ? 'bg-primary/30 ring-1 ring-primary' : 'bg-highlight hover:bg-highlight/70'}`}>
                            <span className="text-text-primary truncate flex-grow mr-2" title={template.name}>{template.name}</span>
                            <div className="space-x-2 flex-shrink-0">
                              <button onClick={() => handleEdit(template)} className="text-xs bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded disabled:opacity-50" disabled={!!editingTemplate}>Editar</button>
                              <button onClick={() => handleDelete(template.id)} className="text-xs bg-danger hover:bg-danger-hover px-2 py-1 rounded disabled:opacity-50" disabled={!!editingTemplate}>Borrar</button>
                            </div>
                          </li>
                        ))}
                         {currentTemplates.length === 0 && <li className="text-text-secondary text-center p-4 italic">No hay plantillas guardadas.</li>}
                      </ul>
                    </div>

                    {/* Right Side: Editor/Placeholder */}
                    <div className="flex flex-col h-full">
                       <h4 className="text-lg font-semibold mb-2">
                          {editingTemplate ? (currentTemplates.some(t => t.id === editingTemplate.id) ? 'Editar Plantilla' : 'Nueva Plantilla') : 'Editor de Plantilla'}
                       </h4>
                       {editingTemplate ? (
                           <div className="space-y-3 p-4 border border-border-color rounded-lg bg-highlight flex flex-col flex-grow">
                             <input
                               type="text"
                               placeholder="Nombre de la Plantilla"
                               value={editingTemplate.name}
                               onChange={(e) => handleEditorChange('name', e.target.value)}
                               className="w-full bg-background border border-border-color rounded-md px-3 py-2 text-sm flex-shrink-0"
                             />
                             <textarea
                               placeholder="Cuerpo de la Plantilla (HTML permitido)..."
                               value={editingTemplate.body}
                               onChange={(e) => handleEditorChange('body', e.target.value)}
                               className="w-full bg-background border border-border-color rounded-md px-3 py-2 resize-y flex-grow text-sm min-h-[200px]" // Ensure minimum height
                             />
                              <p className="text-xs text-text-secondary flex-shrink-0">Marcadores disponibles: {`{{Columna}}`} (ej: {`{{Nombre}}`}, {`{{No_Orden}}`}, {`{{EPS}}`}, {`{{Oficina_Virtual_EPS}}`}, etc.)</p>
                             <div className="flex gap-2 flex-shrink-0 justify-end">
                               <button onClick={() => setEditingTemplate(null)} className="bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded text-sm">Cancelar</button>
                               <button onClick={handleSaveTemplateEdit} className="bg-success hover:bg-green-700 px-3 py-1 rounded text-sm">Guardar Cambios</button>
                             </div>
                           </div>
                         ) : (
                           <div className="flex items-center justify-center h-full border border-dashed border-border-color rounded-lg bg-background/30 text-text-secondary italic">
                              Selecciona una plantilla para editar o haz clic en "+ Nueva".
                           </div>
                         )}
                    </div>

                  </div>
                </div>

                <div className="p-4 bg-header flex justify-between items-center rounded-b-lg flex-shrink-0"> {/* Footer */}
                   <button onClick={onReset} className="bg-danger hover:bg-danger-hover text-white font-bold py-2 px-4 rounded-lg text-sm" disabled={!!editingTemplate}>
                    Restaurar Predeterminadas
                  </button>
                  <div className="flex gap-4">
                    <button onClick={onClose} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg text-sm" disabled={!!editingTemplate}>
                        Cancelar
                    </button>
                    <button onClick={handleSaveLocal} className="bg-success hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg text-sm" disabled={!!editingTemplate}>
                        Guardar y Cerrar
                    </button>
                  </div>
                </div>
              </div>
            </div>
          );
        };


        // =================================================================================
        // INLINED: components/PreviewModal.tsx
        // =================================================================================
        const PreviewModal = ({ data, template, onClose }) => { // Cannot easily memoize modals
           // Ensure data is an object before proceeding
          if (!data || typeof data !== 'object') {
             console.error("Invalid data provided to PreviewModal:", data);
             // Optionally show an error to the user or close automatically
             // onClose(); // Uncomment to close if data is bad
             return ( // Render a fallback message
                  <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[150] p-4">
                     <div className="bg-surface rounded-lg shadow-xl w-full max-w-lg border border-border-color p-8 text-center">
                         <h3 className="text-xl font-bold text-danger mb-4">Error</h3>
                         <p className="text-text-secondary mb-6">No se pudieron cargar los datos para la vista previa.</p>
                         <button onClick={onClose} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Cerrar</button>
                     </div>
                  </div>
             );
          }

          const bodyContent = template && template.body ? replacePlaceholders(template.body, data) : '<p class="italic text-gray-500">[Selecciona un tipo de carta en el √Årea 3 para ver la vista previa aqu√≠]</p>';
          const fullBody = `<div style="font-family: sans-serif; font-size: 14px; color: #333;">${bodyContent}${COMMON_EMAIL_BODY}${SIGNATURE}</div>`; // Wrap in basic styles for iframe


          const copyToClipboard = useCallback(() => {
             // Create a temporary element to parse HTML and get text content
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = fullBody; // Use fullBody which includes signature etc.
            // Get text content, trying different properties for browser compatibility
            const textContent = tempDiv.textContent || tempDiv.innerText || "";

            navigator.clipboard.writeText(textContent.trim()) // Trim whitespace
              .then(() => alert('¬°Contenido de texto copiado al portapapeles!'))
              .catch(err => {
                   console.error('Failed to copy text content:', err);
                   alert('Fall√≥ al copiar el contenido de texto.');
               });
          }, [fullBody]); // Depends on fullBody


          const copyHtmlToClipboard = useCallback(() => {
               try {
                  // Use Clipboard API with HTML type
                  if (navigator.clipboard && window.ClipboardItem) {
                      const blob = new Blob([fullBody], { type: 'text/html' });
                      const item = new ClipboardItem({ 'text/html': blob });
                      navigator.clipboard.write([item])
                         .then(() => alert('¬°Contenido HTML copiado al portapapeles!'))
                         .catch(err => {
                              console.error('Failed to copy HTML content using ClipboardItem:', err);
                              // Fallback or specific error message
                              alert('Fall√≥ al copiar el contenido HTML (tu navegador podr√≠a no soportarlo completamente). Intenta copiar el texto.');
                         });
                  } else {
                       // Fallback for older browsers (might not copy HTML format correctly)
                       console.warn("ClipboardItem API not supported, attempting fallback text copy.");
                       copyToClipboard(); // Fallback to text copy
                       alert("Se copi√≥ el texto, pero el formato HTML puede no ser compatible con tu navegador.");
                  }
               } catch (error) {
                   console.error('Error copying HTML:', error);
                   alert('Error inesperado al intentar copiar HTML.');
               }
            }, [fullBody, copyToClipboard]); // Depends on fullBody and copyToClipboard fallback


          return (
            <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[150] p-4"> {/* Increased z-index */}
              <div className="bg-surface rounded-lg shadow-xl w-full max-w-3xl border border-border-color flex flex-col max-h-[90vh]"> {/* Added max-h */}
                <div className="p-4 border-b border-border-color flex justify-between items-center flex-shrink-0"> {/* Header */}
                  <h3 className="text-lg font-bold text-primary truncate">Vista Previa: Orden {data.No_Orden || 'N/A'}</h3>
                   <button onClick={onClose} className="text-text-secondary text-2xl hover:text-text-primary ml-4">&times;</button>
                </div>
                {/* Use iframe to render HTML correctly */}
                <iframe
                  srcDoc={`<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{margin: 1rem;}</style></head><body>${fullBody}</body></html>`} // Add basic HTML structure and margin
                  className="flex-grow overflow-y-auto bg-white border-none" // Use border-none
                  sandbox="allow-same-origin" // Basic sandboxing for security
                  title={`Vista Previa Email Orden ${data.No_Orden || 'N/A'}`}
                />
                <div className="p-4 bg-header flex justify-end gap-4 rounded-b-lg flex-shrink-0"> {/* Footer */}
                   <button onClick={copyHtmlToClipboard} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm" title="Copiar como HTML formateado para pegar en correos">
                     Copiar HTML
                   </button>
                  <button onClick={copyToClipboard} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm" title="Copiar solo el texto sin formato">
                    Copiar Texto
                  </button>
                  <button onClick={onClose} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm">
                    Cerrar
                  </button>
                </div>
              </div>
            </div>
          );
        };


        // =================================================================================
        // INLINED: App.tsx (The main application component)
        // =================================================================================
        const App = () => {
          // Initialize state with empty arrays or appropriate defaults
          const [state, setState] = useState({
            finalData: [],
            trackingData: [],
            archivedData: [],
            portalData: [], // State specifically for Area 1 file input
            pdfData: Array(5).fill({}), // State specifically for Area 2 paste input
            templates: [],
            scriptUrl: null,
            isSetupNeeded: false, // True initially if no URL in localStorage
            isReconfiguring: false, // True if user clicks reconfigure button
            isLoading: true, // True during initial data fetch
            isSaving: false, // True while save operation is in progress
            isTemplateManagerOpen: false,
            previewData: null, // Holds the row data for the preview modal
            notification: null, // { message: string, type: 'success'|'error'|'warning'|'info', timeoutId?: number }
            editsCount: 0, // Counter for unsaved changes in Review and Tracking areas
            onlineStatus: true, // Tracks browser online status
            masterTrackingOrders: new Set(), // Holds all known No_Orden strings (from initial load + saves)
          });

          const [sortConfig, setSortConfig] = useState({
            key: 'No_Orden', // Default sort column
            direction: 'ascending', // Default sort direction
          });

          // --- Notification Management ---
          const hideNotification = useCallback(() => {
              // Use functional update to avoid stale state issues if called rapidly
              setState(prev => ({ ...prev, notification: null }));
          }, []); // Empty dependency array as it doesn't depend on external vars

          const showNotification = useCallback((message, type = 'info', duration = 5000) => {
             // Clear existing notification timeout if any to prevent overlaps
             setState(prev => {
                if (prev.notification?.timeoutId) {
                   clearTimeout(prev.notification.timeoutId);
                }
                const timeoutId = setTimeout(hideNotification, duration);
                return { ...prev, notification: { message, type, timeoutId } };
             });
          }, [hideNotification]); // Depend on hideNotification


          // --- Script URL and Initial Data Loading ---
          const handleSetScriptUrl = useCallback(async (url) => {
              console.log("Attempting to set script URL and fetch initial data...");
             setState(prev => ({ ...prev, isLoading: true, isReconfiguring: false })); // Start loading, close reconfigure modal
             try {
               const data = await fetchData(url); // Fetch initial data from Sheets
               localStorage.setItem('sigweb_scriptUrl', url); // Store URL on success
               setState(prev => ({
                 ...prev,
                 finalData: data.finalData, // Already ensured array by fetchData
                 trackingData: data.trackingData, // Already ensured array by fetchData
                 archivedData: data.archivedData, // Already ensured array by fetchData
                 // Initialize master set with all known orders from backend
                 masterTrackingOrders: new Set(data.masterTrackingOrders.map(String)),
                 scriptUrl: url,
                 isSetupNeeded: false, // Setup is complete
                 isLoading: false, // Loading finished
                 editsCount: 0, // Reset edits on successful load
               }));
               showNotification('¬°Conexi√≥n exitosa y datos cargados!', 'success');
               console.log("Initial data fetched successfully.");
             } catch (error) {
               console.error("Error setting script URL or fetching data:", error);
               showNotification(
                 `Fall√≥ la conexi√≥n: ${error.message}. Revisa la URL y permisos del script.`,
                 'error',
                  10000 // Show error longer
               );
               // Keep setup needed true, stop loading, clear URL if it failed
               setState(prev => ({ ...prev, isLoading: false, isSetupNeeded: true, scriptUrl: null }));
               localStorage.removeItem('sigweb_scriptUrl'); // Remove bad URL from storage
               throw error; // Re-throw to prevent modal from closing automatically via handleSave in SetupModal
             }
          }, [showNotification]);


          // --- Effect for Initial Load and Online Status ---
          useEffect(() => {
              console.log("App component mounted. Checking config...");
            const url = localStorage.getItem('sigweb_scriptUrl');
            const loadedTemplates = loadTemplates(); // Load templates from localStorage or defaults
            setState(prev => ({ ...prev, templates: loadedTemplates }));

            if (url) {
                console.log("Found script URL in localStorage:", url);
                handleSetScriptUrl(url).catch(err => {
                    // Catch error here if initial load fails, user is already notified by handleSetScriptUrl
                    console.error("Initial data load failed on mount:", err);
                    // State should already be set to isSetupNeeded: true by handleSetScriptUrl's catch block
                });
            } else {
                console.log("No script URL found. Setup needed.");
                setState(prev => ({ ...prev, isSetupNeeded: true, isLoading: false })); // Need setup, stop loading indicator
            }

            // Online/Offline handling
            const updateOnlineStatus = () => {
                const isOnline = navigator.onLine;
                console.log("Network status changed:", isOnline ? "Online" : "Offline");
                setState(prev => {
                     if (prev.onlineStatus === isOnline) return prev; // Avoid unnecessary state updates
                     if (!isOnline) {
                        showNotification("Est√°s desconectado. El guardado en la nube est√° deshabilitado.", "warning", 10000);
                     } else if (prev.onlineStatus === false && isOnline){ // Only show "back online" if previously offline
                         showNotification("Est√°s conectado de nuevo.", "info");
                     }
                     return { ...prev, onlineStatus: isOnline };
                });
            };


            window.addEventListener('online', updateOnlineStatus);
            window.addEventListener('offline', updateOnlineStatus);
            updateOnlineStatus(); // Initial check

            return () => { // Cleanup listeners on component unmount
                console.log("App component unmounting. Removing listeners.");
                window.removeEventListener('online', updateOnlineStatus);
                window.removeEventListener('offline', updateOnlineStatus);
                 // Clear any pending notification timeouts
                 setState(prev => {
                    if (prev.notification?.timeoutId) {
                       clearTimeout(prev.notification.timeoutId);
                    }
                    return prev; // Return prev state to avoid unnecessary re-render on unmount
                 });
            };
            // Run only on mount and unmount - CAREFUL: handleSetScriptUrl IS a dependency
          }, [handleSetScriptUrl]); // Include handleSetScriptUrl but ensure it's stable via useCallback


          // --- Edit Counter ---
          const incrementEdits = useCallback(() => {
            console.log("Incrementing edits count"); // Debug log
            setState(prev => ({ ...prev, editsCount: prev.editsCount + 1 }));
          },[]); // No dependencies needed


          // --- Save Data ---
          const handleSave = useCallback(async () => {
              console.log("Save button clicked.");
              if (!state.scriptUrl) {
                  showNotification('No se puede guardar. La URL del script no est√° configurada.', 'error');
                  return;
              }
              if (!state.onlineStatus) {
                  showNotification('No se puede guardar mientras est√°s desconectado.', 'error');
                  return;
              }

              // Use safe arrays for checks and payload
              const safeFinalData = Array.isArray(state.finalData) ? state.finalData : [];
              const safeTrackingData = Array.isArray(state.trackingData) ? state.trackingData : [];
              const safeArchivedData = Array.isArray(state.archivedData) ? state.archivedData : [];

              // Check if there's anything new (finalData) or edited (editsCount > 0)
              if (safeFinalData.length === 0 && state.editsCount === 0) {
                   showNotification('No hay datos nuevos o modificados para guardar.', 'info');
                   return;
              }

              setState(prev => ({ ...prev, isSaving: true }));
              console.log("Attempting to save data...");

              try {
                  const payload = {
                      action: 'saveData',
                      payload: {
                          finalData: safeFinalData,
                          trackingData: safeTrackingData,
                          archivedData: safeArchivedData,
                      }
                  };
                  await saveData(state.scriptUrl, payload); // Assume success due to no-cors

                  // Update master tracking set LOCALLY with orders from ALL sections just sent
                  const newOrders = new Set(state.masterTrackingOrders); // Start with existing

                  [...safeFinalData, ...safeTrackingData, ...safeArchivedData].forEach(row => {
                      if (row && row.No_Orden) {
                          newOrders.add(String(row.No_Orden).trim());
                      }
                  });

                  showNotification('¬°Datos enviados a la nube! (Verifica la hoja "TOTAL" para confirmar)', 'success');
                  console.log("Save request sent successfully. Updated masterTrackingOrders locally.");

                  // Clear local finalData and reset edits count after sending
                  setState(prev => ({
                      ...prev,
                      editsCount: 0, // Reset edits since changes were saved
                      masterTrackingOrders: newOrders, // Use the fully updated Set
                      finalData: [] // Clear the review area data after successful send
                  }));
              } catch (error) {
                  console.error("Error during save:", error);
                  showNotification(`Fall√≥ el guardado de datos: ${error.message}`, 'error');
              } finally {
                  setState(prev => ({ ...prev, isSaving: false }));
                  console.log("Save process finished.");
              }
          }, [state.scriptUrl, state.onlineStatus, state.finalData, state.trackingData, state.archivedData, state.masterTrackingOrders, state.editsCount, showNotification]); // Dependencies


          // --- Process Area 1 Data (Excel Upload) ---
          const processPortalData = useCallback(() => {
              console.log("Processing portal data...");
              const currentPortalData = Array.isArray(state.portalData) ? state.portalData.filter(row => row && Object.values(row).some(val => String(val).trim() !== '')) : []; // Filter empty rows from input

              if(currentPortalData.length === 0){
                   showNotification("No hay datos v√°lidos cargados desde el archivo para procesar.", "warning");
                   setState(prev => ({ ...prev, portalData: [] })); // Clear the input area state
                   return;
              }

              // Filter out rows that already exist based on masterTrackingOrders Set
              const newRows = currentPortalData.filter(row => {
                   const orderKey = row && row.No_Orden ? String(row.No_Orden).trim() : null;
                   return orderKey && !state.masterTrackingOrders.has(orderKey);
              });

              const duplicates = currentPortalData.length - newRows.length;
              console.log(`Found ${newRows.length} new rows, skipped ${duplicates} duplicates.`);

              const processedData = newRows
                  .filter(row => row && row.No_Orden && String(row.No_Orden).trim()) // Redundant check, but safe
                  .map((row) => ({
                      ...row, // Keep all data, ensure all PORTAL_HEADERS were added during file parse
                      Nombre: capitalizeWords(row.Nombre || ''), // Apply specific formatting
                      EPS: (row.EPS || '').toUpperCase(),
                      // Default potentially missing PDF fields needed for Area 3
                      Descripcion_PDF: row.Descripcion_PDF || '(pendiente)',
                      Justificacion_PDF: row.Justificacion_PDF || '(pendiente)',
                      Fundamento_Legal_PDF: row.Fundamento_Legal_PDF || '(pendiente)',
                      // Ensure Tipo_Carta and Radicado_Comp exist, even if empty
                      Tipo_Carta: row.Tipo_Carta || '',
                      Radicado_Comp: row.Radicado_Comp || '',
                  }));

              // Append NEW processed rows to existing finalData, clear portalData input
              setState(prev => ({
                    ...prev,
                    // Append new processed rows to whatever is currently in finalData (Area 3)
                    finalData: [...(Array.isArray(prev.finalData) ? prev.finalData : []), ...processedData],
                    portalData: [] // Clear Area 1 input
              }));


              let message = `${processedData.length} nuevas filas procesadas y a√±adidas al √Årea 3.`;
              if (duplicates > 0) {
                  message += ` ${duplicates} fila(s) ya existentes fueron omitidas.`;
              }
              showNotification(message, processedData.length > 0 ? 'success' : 'info'); // Use 'info' if only duplicates found

          }, [state.portalData, state.masterTrackingOrders, state.finalData, showNotification]); // Added state.finalData dependency


           // --- Process Area 2 Data (PDF Paste) ---
           const mergePdfData = useCallback(() => {
               console.log("Merging PDF data...");
               const currentPdfData = Array.isArray(state.pdfData) ? state.pdfData.filter(row => row && Object.values(row).some(val => String(val).trim() !== '')) : []; // Filter empty rows

               if(currentPdfData.length === 0){
                    showNotification("No hay datos v√°lidos en el √Årea 2 para combinar.", "warning");
                     setState(prev => ({ ...prev, pdfData: Array(5).fill({}) })); // Reset paste area
                    return;
               }

             const pdfMap = new Map();
             currentPdfData
               .filter(row => row && row['Archivo (No. Orden)'] && String(row['Archivo (No. Orden)']).trim())
               .forEach(row => {
                  const key = String(row['Archivo (No. Orden)']).trim();
                  if(key){
                    pdfMap.set(key, {
                      Descripcion_PDF: String(row['Descripci√≥n'] || '').trim(),
                      Justificacion_PDF: String(row['Justificaci√≥n'] || '').trim(),
                      Fundamento_Legal_PDF: String(row['Fundamento Legal'] || '').trim(),
                    });
                  }
               });

             console.log(`Created PDF map with ${pdfMap.size} entries.`);

             // Ensure finalData is an array
             const currentFinalData = Array.isArray(state.finalData) ? state.finalData : [];
             let mergeCount = 0;
             const mergedData = currentFinalData.map(finalRow => {
               const orderKey = finalRow && finalRow.No_Orden ? String(finalRow.No_Orden).trim() : null;
               if (orderKey) {
                  const pdfMatch = pdfMap.get(orderKey);
                  // Merge ONLY if PDF data is not empty/placeholder and different from current
                  if (pdfMatch && (
                      (pdfMatch.Descripcion_PDF && pdfMatch.Descripcion_PDF !== '(pendiente)' && pdfMatch.Descripcion_PDF !== finalRow.Descripcion_PDF) ||
                      (pdfMatch.Justificacion_PDF && pdfMatch.Justificacion_PDF !== '(pendiente)' && pdfMatch.Justificacion_PDF !== finalRow.Justificacion_PDF) ||
                      (pdfMatch.Fundamento_Legal_PDF && pdfMatch.Fundamento_Legal_PDF !== '(pendiente)' && pdfMatch.Fundamento_Legal_PDF !== finalRow.Fundamento_Legal_PDF)
                     ))
                  {
                      mergeCount++;
                      // Create a new object with merged data, prioritizing non-empty PDF data
                      return {
                          ...finalRow,
                          Descripcion_PDF: (pdfMatch.Descripcion_PDF && pdfMatch.Descripcion_PDF !== '(pendiente)') ? pdfMatch.Descripcion_PDF : finalRow.Descripcion_PDF,
                          Justificacion_PDF: (pdfMatch.Justificacion_PDF && pdfMatch.Justificacion_PDF !== '(pendiente)') ? pdfMatch.Justificacion_PDF : finalRow.Justificacion_PDF,
                          Fundamento_Legal_PDF: (pdfMatch.Fundamento_Legal_PDF && pdfMatch.Fundamento_Legal_PDF !== '(pendiente)') ? pdfMatch.Fundamento_Legal_PDF : finalRow.Fundamento_Legal_PDF,
                      };
                  }
               }
               return finalRow; // Return original row if no match or no update needed
             });

             // Only update state and increment edits if merges actually happened
             if (mergeCount > 0) {
                 setState(prev => ({
                     ...prev,
                     finalData: mergedData,
                     pdfData: Array(5).fill({}), // Reset paste area
                     editsCount: prev.editsCount + mergeCount // Increment edits for merged rows
                 }));
                 showNotification(`${mergeCount} fila(s) actualizadas con datos del PDF en el √Årea 3.`, 'success');
                 console.log(`Merged PDF data into ${mergeCount} rows.`);
             } else {
                 setState(prev => ({ ...prev, pdfData: Array(5).fill({}) })); // Still reset paste area
                 showNotification('No se encontraron coincidencias o datos nuevos para combinar desde el PDF.', 'info');
                 console.log('No PDF data merged.');
             }


           }, [state.pdfData, state.finalData, showNotification]); // Dependencies


          // --- Update Row in Area 3 (Review Area) ---
          const updateFinalDataRow = useCallback((noOrden, partialUpdate) => {
              const keyToUpdate = String(noOrden);
             setState(prev => {
                const currentFinalData = Array.isArray(prev.finalData) ? prev.finalData : [];
                let rowUpdated = false;
                const newData = currentFinalData.map(row => {
                  if (row && String(row.No_Orden) === keyToUpdate) {
                      // Check if any value in partialUpdate is actually different
                      const isChanged = Object.keys(partialUpdate).some(updateKey => String(row[updateKey] ?? '') !== String(partialUpdate[updateKey] ?? ''));
                      if (isChanged) {
                         rowUpdated = true;
                         return { ...row, ...partialUpdate }; // Create new object only if changed
                      }
                  }
                  return row; // Return original object reference if no change
                });

                // Only update state and increment edits if a row was actually changed
                if (rowUpdated) {
                   console.log(`Updating finalData row ${keyToUpdate}`);
                   return { ...prev, finalData: newData, editsCount: prev.editsCount + 1 };
                } else {
                   return prev; // No change, return previous state
                }
             });
          }, []); // Removed incrementEdits dependency as it's handled internally


          // --- Clear Area 3 Data ---
          const handleClearReviewData = useCallback(() => {
            // Check if there's data to clear
            if (!Array.isArray(state.finalData) || state.finalData.length === 0) {
                 showNotification("La tabla de Revisi√≥n ya est√° vac√≠a.", "info");
                 return;
            }
            if (window.confirm("¬øEst√°s seguro de que quieres limpiar toda la tabla de Revisi√≥n (√Årea 3)?\nLos datos no guardados se perder√°n.\n\nEsto NO afecta los datos en Google Sheets.")) {
                setState(prev => ({ ...prev, finalData: [] })); // Only clear local state
                showNotification("Tabla de Revisi√≥n limpiada.", "info");
                // Note: editsCount is NOT reset here, as clearing is an action itself that might need saving if other areas were edited. It resets on successful save.
            }
          }, [showNotification, state.finalData]);


          // --- Send to Area 4 (Tracking) ---
          const handleSendToTracking = useCallback((selectedOrderKeys) => { // Receive array of string keys
             console.log("Attempting to send items to tracking:", selectedOrderKeys);
            const currentFinalData = Array.isArray(state.finalData) ? state.finalData : [];
            const safeTemplates = Array.isArray(state.templates) ? state.templates : [];

            const itemsToSend = currentFinalData
              .filter(row => row && selectedOrderKeys.includes(String(row.No_Orden)))
              .filter(row => { // Filter based on criteria
                const template = safeTemplates.find((t) => t.id === row.Tipo_Carta);
                const hasComplementariedadTemplate = template && template.name.toUpperCase().includes('COMPLEMENTARIEDAD');
                const hasRadicado = row.Radicado_Comp && String(row.Radicado_Comp).trim() !== '';
                if (hasComplementariedadTemplate && !hasRadicado) {
                   console.warn(`Row ${row.No_Orden} has Complementariedad template but no Radicado. Skipping.`);
                   showNotification(`El caso ${row.No_Orden} tiene plantilla de Complementariedad pero falta el n√∫mero de Radicado. No se enviar√° a seguimiento.`, 'warning');
                }
                return hasComplementariedadTemplate && hasRadicado; // Must meet both
              });


            if (itemsToSend.length === 0) {
              showNotification("No hay √≠tems seleccionados que cumplan los criterios (Tipo 'COMPLEMENTARIEDAD' con 'Radicado') para enviar a seguimiento.", 'warning');
              return;
            }
             console.log(`${itemsToSend.length} items meet criteria for tracking.`);

            setState(prev => {
               const currentTrackingData = Array.isArray(prev.trackingData) ? prev.trackingData : [];
               let newTrackingData = [...currentTrackingData];
               let newFinalData = Array.isArray(prev.finalData) ? [...prev.finalData] : [];
               let addedCount = 0;
               let updatedCount = 0;
               let skippedCount = 0;
               const itemsActuallyMovedKeys = new Set(); // Track keys of items successfully moved/updated

               itemsToSend.forEach(item => {
                 const itemOrderKey = String(item.No_Orden);
                 const existingIndex = newTrackingData.findIndex(t => t && String(t.No_Orden) === itemOrderKey);

                 if (existingIndex !== -1) { // Item already exists in tracking
                    // Optional: Confirm update only if Radicado is different
                    if (newTrackingData[existingIndex].Radicado !== item.Radicado_Comp) {
                       if (window.confirm(`El caso ${itemOrderKey} ya est√° en seguimiento activo con Radicado "${newTrackingData[existingIndex].Radicado}".\n¬øActualizar a "${item.Radicado_Comp}"?`)) {
                         // Create a new object for the updated tracking item
                         newTrackingData[existingIndex] = { ...newTrackingData[existingIndex], Radicado: item.Radicado_Comp };
                         updatedCount++;
                         itemsActuallyMovedKeys.add(itemOrderKey);
                       } else {
                          skippedCount++; // User chose not to update
                       }
                    } else {
                         skippedCount++; // Already exists with same Radicado
                         console.log(`Skipping ${itemOrderKey}, already in tracking with same Radicado.`);
                    }
                 } else { // Item is new to tracking
                   newTrackingData.push({
                     Fecha_Ing: item.Fecha_Neg || new Date().toISOString().slice(0,10),
                     No_Orden: item.No_Orden,
                     Nombre: item.Nombre || '',
                     EPS: item.EPS || '',
                     Radicado: item.Radicado_Comp,
                     Estado: TRACKING_STATUSES[0], // Default state
                     Notas: '',
                   });
                   addedCount++;
                   itemsActuallyMovedKeys.add(itemOrderKey);
                 }
               });

               // Remove ONLY the successfully moved/updated items from finalData
               newFinalData = newFinalData.filter(f => !(f && itemsActuallyMovedKeys.has(String(f.No_Orden))));

               let summaryMessage = "";
               if (addedCount > 0) summaryMessage += `${addedCount} nuevo(s) enviado(s) a Seguimiento. `;
               if (updatedCount > 0) summaryMessage += `${updatedCount} actualizado(s) en Seguimiento. `;
               if (skippedCount > 0) summaryMessage += `${skippedCount} omitido(s) (ya exist√≠an o no se actualiz√≥).`;

               if(addedCount > 0 || updatedCount > 0){
                   showNotification(summaryMessage.trim(), 'success');
                   // Increment edits count for the items moved/updated
                   return { ...prev, trackingData: newTrackingData, finalData: newFinalData, editsCount: prev.editsCount + addedCount + updatedCount };
               } else {
                   showNotification(summaryMessage.trim() || "No se realizaron cambios en Seguimiento.", 'info');
                   return { ...prev, finalData: newFinalData }; // Still update finalData if skips occurred but no moves/updates
               }
            });

          }, [state.templates, state.finalData, state.trackingData, showNotification]); // Dependencies


          // --- Export Area 3 Data for Mail Merge ---
          const exportForMailMerge = useCallback((dataToExport) => {
              const currentData = Array.isArray(dataToExport) ? dataToExport : [];
              if (currentData.length === 0) {
                  showNotification("No hay datos en revisi√≥n (√Årea 3) para exportar.", "warning");
                  return;
              }
              console.log(`Exporting ${currentData.length} rows for mail merge.`);
              try {
                  const safeTemplates = Array.isArray(state.templates) ? state.templates : [];
                  const exportable = currentData.map(row => {
                      const templateName = safeTemplates.find(t => t.id === row?.Tipo_Carta)?.name || "NO_SELECCIONADA";
                      // Select and rename columns for the export
                      return {
                          "Fecha": row?.Fecha_Neg || '',
                          "Orden": row?.No_Orden || '',
                          "Cedula": row?.No_Cedula || '',
                          "Nombre": row?.Nombre || '',
                          "EPS": row?.EPS || '',
                          "Programa": row?.Programa || '',
                          "Email": row?.Email || '',
                          "Motivo": row?.Motivo_Negacion || '',
                          "Desc_PDF": row?.Descripcion_PDF || '',
                          "Just_PDF": row?.Justificacion_PDF || '',
                          "Fund_PDF": row?.Fundamento_Legal_PDF || '',
                          "Tipo_Carta_Seleccionada": templateName,
                          "Radicado_Complementariedad": row?.Radicado_Comp || ''
                          // Add any other columns needed for mail merge here
                      };
                  });
                  const ws = XLSX.utils.json_to_sheet(exportable);
                  const wb = XLSX.utils.book_new();
                  XLSX.utils.book_append_sheet(wb, ws, "DatosParaEnvio");
                  XLSX.writeFile(wb, `Sigweb_Procesado_MailMerge_${new Date().toISOString().slice(0, 10)}.xlsx`);
                  showNotification("Archivo para Env√≠o Masivo generado.", "success");
              } catch (error) {
                   console.error("Error exporting for mail merge:", error);
                   showNotification("Error al generar el archivo para env√≠o masivo.", "error");
              }
          }, [state.templates, showNotification]); // Dependencies


          // --- Update Row in Area 4 (Tracking/Archived) ---
          const updateTrackingData = useCallback((index, updatedRow, isArchived) => {
              if (typeof index !== 'number' || index < 0) {
                 console.error("Invalid index provided to updateTrackingData:", index);
                 return;
              }
            const dataKey = isArchived ? 'archivedData' : 'trackingData';
            setState(prev => {
               const currentData = Array.isArray(prev[dataKey]) ? prev[dataKey] : [];
               if(index < currentData.length) {
                   // Avoid mutation: create a new array with the updated item
                   const newData = [...currentData];
                   newData[index] = updatedRow; // Place the already updated row object
                   console.log(`Updated item at index ${index} in ${dataKey}`);
                   // Increment edits count only if it's not already saving (prevents double counting during save process)
                   const newEditsCount = prev.isSaving ? prev.editsCount : prev.editsCount + 1;
                   return { ...prev, [dataKey]: newData, editsCount: newEditsCount };
               } else {
                   console.error(`Index ${index} out of bounds for ${dataKey}`);
                   return prev;
               }
            });
          }, []); // No external dependencies, relies on functional update


          // --- Archive/Unarchive Items in Area 4 ---
          const archiveItems = useCallback((indicesToMove, fromArchived) => {
              if (!Array.isArray(indicesToMove) || indicesToMove.some(isNaN) || indicesToMove.length === 0){
                 console.warn("Invalid or empty indices provided to archiveItems:", indicesToMove);
                 return;
              }
              console.log(`${fromArchived ? 'Unarchiving' : 'Archiving'} indices:`, indicesToMove);
            const sourceKey = fromArchived ? 'archivedData' : 'trackingData';
            const targetKey = fromArchived ? 'trackingData' : 'archivedData';

            setState(prev => {
               const sourceData = Array.isArray(prev[sourceKey]) ? prev[sourceKey] : [];
               const targetData = Array.isArray(prev[targetKey]) ? [...prev[targetKey]] : []; // Start target as copy

               const itemsToMove = [];
               const remainingSourceIndices = new Set(); // Keep track of indices *not* moved

               sourceData.forEach((item, index) => {
                   if (!indicesToMove.includes(index)) {
                       remainingSourceIndices.add(index);
                   }
               });

               // Build the new source array based on remaining indices
               const newSourceData = Array.from(remainingSourceIndices).map(index => sourceData[index]);

               // Find the items to move based on the provided indices
               indicesToMove.forEach(index => {
                  if(index >= 0 && index < sourceData.length && sourceData[index]){
                     itemsToMove.push(sourceData[index]); // Get the actual items to move
                  }
               });


               if (itemsToMove.length === 0) {
                    console.warn("No valid items found for the given indices to move.");
                    return prev; // No changes if no valid items were found
               }

               console.log(`Moving ${itemsToMove.length} items from ${sourceKey} to ${targetKey}.`);

               // Append moved items to the target array
               const newTargetData = [...targetData, ...itemsToMove];


               return {
                 ...prev,
                 [sourceKey]: newSourceData, // Updated source (items removed)
                 [targetKey]: newTargetData, // Updated target (items added)
                 // Increment edits count only if not currently saving
                 editsCount: prev.isSaving ? prev.editsCount : prev.editsCount + itemsToMove.length
               };
            });
          }, []); // No external dependencies


          // --- Template Management Callbacks ---
          const handleSaveTemplates = useCallback((newTemplates) => {
            const templatesToSave = Array.isArray(newTemplates) ? newTemplates : defaultTemplates;
            setState(prev => ({ ...prev, templates: templatesToSave }));
            saveTemplates(templatesToSave);
            showNotification('Plantillas de correo guardadas localmente.', 'success');
          }, [showNotification]);

          const handleResetTemplates = useCallback(() => {
            if (window.confirm('¬øEst√°s seguro de que quieres restaurar las plantillas predeterminadas?\n\nTodas las plantillas personalizadas se perder√°n.')) {
              handleSaveTemplates([...defaultTemplates]); // Save a copy of defaults
            }
          }, [handleSaveTemplates]);

          // --- Memoized Sorted Data for Review Area ---
          const sortedFinalData = useMemo(() => {
            let sortableItems = Array.isArray(state.finalData) ? [...state.finalData] : [];
            if (sortConfig.key) {
                sortableItems.sort((a, b) => {
                    if (!a || !b) return 0;
                    const aVal = a[sortConfig.key] ?? ''; // Use nullish coalescing for cleaner default
                    const bVal = b[sortConfig.key] ?? '';
                    const comparison = String(aVal).localeCompare(String(bVal), undefined, { numeric: true, sensitivity: 'base' });
                    return sortConfig.direction === 'ascending' ? comparison : -comparison;
                });
            }
            return sortableItems;
          }, [state.finalData, sortConfig]);

          // --- Close Setup Modal Callback ---
           const handleCloseSetupModal = useCallback(() => {
                // Only allow closing if it's NOT the initial setup OR if a URL is now present
                if (!state.isSetupNeeded || state.scriptUrl) {
                    setState(prev => ({ ...prev, isReconfiguring: false }));
                } else {
                    alert("Debes configurar y verificar la URL del script para poder usar la aplicaci√≥n.");
                }
           }, [state.isSetupNeeded, state.scriptUrl]);


          // ================== Render Logic ==================

          if (state.isLoading && !state.isSetupNeeded) { // Show loader only if not in initial setup and still loading
            return <div className="fixed inset-0 bg-background/90 flex items-center justify-center z-[300]"><Spinner /> <span className="ml-4 text-xl">Cargando Datos Iniciales...</span></div>;
          }

          // Show Setup Modal if needed (initial setup OR reconfiguring)
          if (state.isSetupNeeded || state.isReconfiguring) {
            return <SetupModal
                onSave={handleSetScriptUrl} // This now handles closing the modal on success
                onClose={handleCloseSetupModal} // Special close handler
                initialUrl={state.scriptUrl || ''}
             />;
          }

          // Main App Render (only if setup is complete and not loading)
          return (
            <div className="p-4 sm:p-8 bg-background min-h-screen">
              {/* Notification Area */}
              {state.notification && (
                <Notification
                  message={state.notification.message}
                  type={state.notification.type}
                  onClose={hideNotification} // Pass hideNotification to allow manual close
                />
              )}
              {/* Offline Indicator */}
              {!state.onlineStatus && (
                   <div className="bg-yellow-600 text-black text-center p-2 fixed top-0 left-0 w-full z-[100] shadow"> {/* Black text */}
                    ‚ö† Est√°s desconectado. El guardado en la nube est√° deshabilitado.
                   </div>
              )}

              <main className={`max-w-screen-2xl mx-auto bg-surface p-4 sm:p-6 rounded-xl border border-border-color space-y-8 ${!state.onlineStatus ? 'pt-12 sm:pt-16' : ''}`}> {/* Adjusted padding */}
                <Header
                    onSave={handleSave}
                    onManageTemplates={() => setState(prev => ({ ...prev, isTemplateManagerOpen: true }))}
                    onReconfigure={() => setState(prev => ({ ...prev, isReconfiguring: true }))}
                />
                <Dashboard
                  reviewCount={Array.isArray(state.finalData) ? state.finalData.length : 0}
                  trackingCount={Array.isArray(state.trackingData) ? state.trackingData.length : 0}
                  archivedCount={Array.isArray(state.archivedData) ? state.archivedData.length : 0}
                  editsCount={state.editsCount} // Display number of unsaved edits
                />
                <div className="text-right">
                       <button
                           onClick={() => exportDetailedReport(state.finalData, state.trackingData, state.archivedData)}
                           className="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm" // Changed color
                       >
                           Descargar Reporte Detallado Excel
                       </button>
                </div>

                <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                  <DataInputArea
                    id="portal-area"
                    title="√Årea 1: Cargar Excel del Portal"
                    headers={PORTAL_HEADERS}
                    data={state.portalData}
                    onDataChange={(newData) => setState(prev => ({ ...prev, portalData: newData }))}
                    onProcess={processPortalData}
                    processButtonText="Procesar y A√±adir a Revisi√≥n"
                    inputType="file"
                  />
                  <DataInputArea
                    id="pdf-area"
                    title="√Årea 2: Pegar Datos del Extractor PDF"
                    headers={PDF_HEADERS}
                    data={state.pdfData}
                    onDataChange={(newData) => setState(prev => ({ ...prev, pdfData: newData }))}
                    onProcess={mergePdfData}
                    processButtonText="Combinar PDF con Revisi√≥n"
                    inputType="paste"
                  />
                </div>
                <ReviewArea
                  data={sortedFinalData} // Use memoized sorted data from state.finalData
                  templates={state.templates}
                  updateRow={updateFinalDataRow} // Callback to update state.finalData
                  incrementEdits={incrementEdits} // Callback to update state.editsCount (now called internally by updateFinalDataRow)
                  onSendToTracking={handleSendToTracking} // Callback to move items from finalData to trackingData
                  onPreview={(row) => setState(prev => ({ ...prev, previewData: row }))} // Set state for preview modal
                  onExportForMailMerge={exportForMailMerge} // Callback to export finalData subset
                  onClearReviewData={handleClearReviewData} // Callback to clear finalData
                  sortConfig={sortConfig} // Current sort state
                  setSortConfig={setSortConfig} // Callback to update sort state
                />
                <TrackingArea
                  trackingData={state.trackingData}
                  archivedData={state.archivedData}
                  updateTrackingData={updateTrackingData} // Callback to update tracking/archived state
                  archiveItems={archiveItems} // Callback to move items between tracking/archived
                />

                {/* Saving Indicator */}
                {state.isSaving && <div className="fixed inset-0 bg-background/80 flex items-center justify-center z-[300]"><Spinner /> <span className="ml-4 text-xl">Guardando Datos en la Nube...</span></div>}
              </main>

              {/* Template Manager Modal */}
              {state.isTemplateManagerOpen && (
                <TemplateManagerModal
                  templates={state.templates}
                  onClose={() => setState(prev => ({...prev, isTemplateManagerOpen: false}))}
                  onSave={handleSaveTemplates} // Saves to state and localStorage
                  onReset={handleResetTemplates} // Resets state and localStorage to defaults
                />
              )}
               {/* Preview Modal */}
              {state.previewData && (
                <PreviewModal
                  data={state.previewData}
                  template={Array.isArray(state.templates) ? state.templates.find(t => t.id === state.previewData?.Tipo_Carta) : null}
                  onClose={() => setState(prev => ({...prev, previewData: null}))}
                />
              )}
            </div>
          );
        };

        // =================================================================================
        // INLINED: index.tsx (Render the application)
        // =================================================================================
        const rootElement = document.getElementById('root');
        if (!rootElement) {
          console.error("Fatal Error: Root element 'root' not found in HTML.");
          document.body.innerHTML = '<div style="color: red; padding: 20px; font-family: sans-serif; background-color: #333;">Error Cr√≠tico: No se encontr√≥ el elemento ra√≠z de la aplicaci√≥n (#root). Verifica el HTML.</div>';
        } else {
            try {
               const root = ReactDOM.createRoot(rootElement);
               // Render without StrictMode for now to avoid potential double-render issues with effects if not needed
               // root.render(<React.StrictMode><App /></React.StrictMode>);
               root.render(<App />);
            } catch(error) {
                console.error("Error rendering React application:", error);
                 rootElement.innerHTML = `<div style="color: orange; padding: 20px; font-family: sans-serif; background-color: #333;">Error Cr√≠tico al iniciar la aplicaci√≥n React:<pre>${error.stack || error.message}</pre></div>`;
            }
        }

    </script>
</body>
</html>
