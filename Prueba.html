<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta http-equiv="Content-Security-Policy"
          content="default-src 'self' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://unpkg.com https://esm.sh;
                   script-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://unpkg.com https://esm.sh;
                   style-src 'self' 'unsafe-inline';">

    <title>GESTION NEGACIONES EJE CAFETERO</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'primary': '#4e9fef',
              'background': '#1e1e1e',
              'surface': '#2d2d2d',
              'text-primary': '#d4d4d4',
              'text-secondary': '#a0a0a0',
              'border-color': '#444',
              'header': '#3a3a3a',
              'highlight': '#252526',
              'warning': '#6e550c',
              'archive': '#3a3a3a',
              'success': '#28a745',
              'danger': '#a02d2d',
              'danger-hover': '#c0392b',
              'btn-primary': '#0e639c',
              'btn-primary-hover': '#1a73e8',
            },
            animation: {
              'flash-success': 'flash-success 1s ease-out',
            },
            keyframes: {
              'flash-success': {
                'from': { backgroundColor: '#28a745' },
                'to': { backgroundColor: 'transparent' },
              }
            }
          }
        }
      }
    </script>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client"
      }
    }
    </script>
</head>

<body class="bg-background text-text-primary">
    <div id="root"></div>

    <script type="text/babel" data-presets="react" data-type="module">
        import React, { useState, useEffect, useCallback, useMemo } from 'react';
        import ReactDOM from 'react-dom/client';

        // =================================================================================
        // INLINED: constants.ts
        // =================================================================================
        const PORTAL_HEADERS = [
            "Fecha_Neg", "Sucursal", "No_Orden", "No_Cedula", "Nombre", "Entidad_Ejecutora",
            "Motivo_Negacion", "Usuario_Emitio", "Auditor", "Observacion_Auditor", "Observacion_Ejecutivo",
            "Programa", "Plan", "Antiguedad", "EPS", "Telefono", "Celular", "Direccion", "Email", "Edad",
            "Tipo_Usuario", "Llamada", "Complementariedad", "Notificacion", "Gestion_Negacion", "Alternativa",
            "Observacion_Alternativa", "Monto", "Nit_Prestador", "Fecha_Complementariedad", "Tiempo_de_Gestion", "Regional"
        ];

        const PDF_HEADERS = [
          "Archivo (No. Orden)", "Descripción", "Justificación", "Fundamento Legal", "Código"
        ];

        const TRACKING_STATUSES = ['Pendiente', 'En Gestión', 'Finalizado'];

        const COMMON_EMAIL_BODY = `<br><br><b>Si tiene alguna duda puede contactarse por medio de los canales que tenemos disponibles para usted:</b><br>· Nuestra línea nacional 018000931666. O con nuestras líneas locales: Cali (602) 489 0073, Bogotá (601) 743 5485, Medellín (604) 604 4507, Barranquilla (605) 385 3165, Bucaramanga (607) 697 3350, Cartagena (605) 693 9853, Tuluá (602) 235 9483, Valledupar (605)588 5699, Pereira (606) 340 2635.<br>· WhatsApp: 317-224-07-94<br><br>Gracias por su Atención.`;
        const SIGNATURE = `<br><br>Cordialmente,<br><br><b>Juan Ricardo Morales Agudelo</b><br>Ejecutivo De Atención Integral<br>Coomeva Medicina Prepagada<br>Cra. 13 No.11-12 Centro Médico Circunvalar<br>Coomeva Medicina Prepagada Pereira, Risaralda<br><br><i>Este correo es generado automáticamente, por favor no responda este mensaje.</i>`;

        const defaultTemplates = [
            { id: 'tpl_neg_gen', name: 'PLANTILLA NEGACION GENERAL', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar información acerca del servicio {{Motivo_Negacion}} que en esta oportunidad no está aprobado debido a que corresponde a EXCLUSIÓN ({{Descripcion_PDF}}), ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>El servicio negado anteriormente; debe tramitarlo a través su EPS asignada. Adjuntamos soporte de la carta de negación.` },
            { id: 'tpl_neg_pert', name: 'PLANTILLA NO PERTINENCIA Y TEMAS ESTETICOS', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar información acerca del servicio {{Motivo_Negacion}} que en esta oportunidad No está aprobado debido a que corresponde a NO PERTINENCIA ({{Descripcion_PDF}}), ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>` },
            { id: 'tpl_comp_coinc', name: 'COMPLEMENTARIEDAD RED COINCIDENTE', body: `Apreciado Usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y el de su familia. Por medio de este correo queremos brindar información acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no fue aprobado, debido a que ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>Sin embargo, está en gestión a través de su EPS ({{EPS}}) con el número de radicado ({{Radicado_Comp}}), puede realizar seguimiento mediante la oficina virtual de la EPS ({{Oficina_Virtual_EPS}}).<br><br>Adicional estaremos haciendo seguimiento al radicado y una vez se encuentre gestionado por la EPS, le notificaremos por medio de correo electrónico.` },
            { id: 'tpl_comp_no_coinc', name: 'COMPLEMENTARIEDAD RED NO COINCIDENTE', body: `Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar información acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no está aprobado, debido a que corresponde a ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>El prestador actual solicitado, no tiene convenio con la EPS, por lo que los costos adicionales del servicio o insumo estarán a cargo del paciente. Sin embargo; se radica la solicitud ante su EPS con el número ({{Radicado_Comp}}) por favor realizar seguimiento mediante la oficina virtual de la EPS ({{Oficina_Virtual_EPS}}).` },
            { id: 'tpl_comp_ayudas', name: 'COMPLEMENTARIEDAD AYUDAS DIAGNOSTICAS', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar información acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no está aprobado debido a que corresponde a ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>Sin embargo, se encuentra en gestión a través de su EPS con el número de radicado ({{Radicado_Comp}}), por favor realizar seguimiento mediante la oficina virtual. ({{Oficina_Virtual_EPS}}).` },
        ];


        // =================================================================================
        // INLINED: services/utilityService.ts
        // =================================================================================
        const capitalizeWords = (str) => {
          if (!str) return '';
          return str.toLowerCase().replace(/\b\w/g, char => char.toUpperCase());
        };

        const processPastedData = (pastedText, headers) => {
          return pastedText
            .trim()
            .split(/\r?\n/)
            .map(rowText => {
              const cells = rowText.split('\t');
              const rowObject = {};
              headers.forEach((header, index) => {
                if (cells[index]) {
                  rowObject[header] = cells[index].trim();
                } else {
                  rowObject[header] = ''; // Ensure all headers exist even if cell is empty
                }
              });
              return rowObject;
            });
        };


        const replacePlaceholders = (templateBody, data) => {
          const getOficinaVirtual = (eps) => {
            const e = (eps || "").toUpperCase();
            if (e.includes("NUEVA EPS")) return `<a href='https://portal.nuevaeps.com.co/Portal/home.jspx' target='_blank' rel='noopener noreferrer'>NUEVA EPS</a>`;
            if (e.includes("SALUD TOTAL")) return `<a href='https://saludtotal.com.co/' target='_blank' rel='noopener noreferrer'>SALUD TOTAL</a>`;
            return eps || ''; // Return empty string if eps is null/undefined
          };

          // Ensure data is an object, default to empty object if not
          const safeData = (typeof data === 'object' && data !== null) ? data : {};
          const fullData = { ...safeData, Oficina_Virtual_EPS: getOficinaVirtual(safeData.EPS) };

          // Ensure templateBody is a string
          const safeTemplateBody = typeof templateBody === 'string' ? templateBody : '';

          return safeTemplateBody.replace(/\{\{(\w+)\}\}/g, (match, key) => {
            // Ensure fullData[key] exists and is not null/undefined before returning, otherwise return empty string
            return fullData[key] !== null && fullData[key] !== undefined ? String(fullData[key]) : ''; // Convert to string
          });
        };


        const exportDetailedReport = (finalData, trackingData, archivedData) => {
          try {
            const masterDataMap = new Map();

            // Ensure all inputs are arrays before spreading
            const safeFinalData = Array.isArray(finalData) ? finalData : [];
            const safeTrackingData = Array.isArray(trackingData) ? trackingData : [];
            const safeArchivedData = Array.isArray(archivedData) ? archivedData : [];

            [...safeFinalData, ...safeTrackingData, ...safeArchivedData].forEach(row => {
              if (row && row.No_Orden) { // Added check for row existence
                const key = String(row.No_Orden).trim(); // Ensure key is a string
                if (key) { // Ensure key is not empty
                  const existing = masterDataMap.get(key) || {};
                  // Merge preserving existing values, then overriding with row values
                  const mergedRow = { ...existing, ...row };
                  masterDataMap.set(key, mergedRow);
                }
              }
            });

            const masterData = Array.from(masterDataMap.values());

            if (masterData.length === 0) {
              alert("No hay datos consolidados para exportar.");
              return;
            }

            const wb = XLSX.utils.book_new();

            // Add sheets only if data exists
            if (safeFinalData.length > 0) {
              const ws1 = XLSX.utils.json_to_sheet(safeFinalData);
              XLSX.utils.book_append_sheet(wb, ws1, "Casos en Revisión");
            }

            if (safeTrackingData.length > 0) {
              const ws2 = XLSX.utils.json_to_sheet(safeTrackingData);
              XLSX.utils.book_append_sheet(wb, ws2, "Seguimiento Activo");
            }

            if (safeArchivedData.length > 0) {
              const ws3 = XLSX.utils.json_to_sheet(safeArchivedData);
              XLSX.utils.book_append_sheet(wb, ws3, "Seguimiento Archivado");
            }

            // Always add Maestro Consolidado if masterData exists
            const ws4 = XLSX.utils.json_to_sheet(masterData);
            XLSX.utils.book_append_sheet(wb, ws4, "Maestro Consolidado");

            XLSX.writeFile(wb, `Sigweb_Reporte_Detallado_${new Date().toISOString().slice(0, 10)}.xlsx`);
          } catch (error) {
            console.error("Falló la exportación del reporte Excel:", error);
            alert("Ocurrió un error al generar el reporte detallado.");
          }
        };


        // =================================================================================
        // INLINED: services/templateService.ts
        // =================================================================================
        const TEMPLATE_STORAGE_KEY = 'sigweb_emailTemplates';

        const loadTemplates = () => {
          try {
            const storedTemplates = localStorage.getItem(TEMPLATE_STORAGE_KEY);
            if (storedTemplates) {
              const parsed = JSON.parse(storedTemplates);
              // Add more robust validation
              if (Array.isArray(parsed) && parsed.every(t => t && typeof t.id === 'string' && typeof t.name === 'string' && typeof t.body === 'string')) {
                 // Check if default templates are missing and add them if necessary
                 const loadedIds = new Set(parsed.map(t => t.id));
                 const missingDefaults = defaultTemplates.filter(dt => !loadedIds.has(dt.id));
                 if (missingDefaults.length > 0) {
                     console.log("Adding missing default templates to loaded templates.");
                     const combined = [...parsed, ...missingDefaults];
                     saveTemplates(combined); // Save the combined list back
                     return combined;
                 }
                 return parsed;
              } else {
                 console.warn("Stored templates data is invalid. Using defaults.");
                 localStorage.removeItem(TEMPLATE_STORAGE_KEY); // Remove invalid data
              }
            }
          } catch (error) {
            console.error("Falló la carga de plantillas desde localStorage, se usarán las predeterminadas.", error);
            localStorage.removeItem(TEMPLATE_STORAGE_KEY); // Remove potentially corrupted data
          }
           // If loading failed or no stored templates, return defaults and save them
           console.log("Using default templates.");
           saveTemplates(defaultTemplates);
           return [...defaultTemplates]; // Return a copy
        };


        const saveTemplates = (templates) => {
          try {
            // Ensure templates is an array before saving
            if (!Array.isArray(templates)) {
              console.error("Attempted to save non-array templates data.");
              return;
            }
            // Ensure basic structure integrity before saving
            if (!templates.every(t => t && typeof t.id === 'string' && typeof t.name === 'string' && typeof t.body === 'string')) {
               console.error("Attempted to save templates with invalid structure.");
               return;
            }
            localStorage.setItem(TEMPLATE_STORAGE_KEY, JSON.stringify(templates));
          } catch (error) {
            console.error("Falló el guardado de plantillas en localStorage", error);
             // Potentially notify user if storage is full or saving fails critically
             alert("Error: No se pudieron guardar las plantillas localmente. El almacenamiento podría estar lleno o deshabilitado.");
          }
        };


        // =================================================================================
        // INLINED: services/googleSheetService.ts
        // =================================================================================
        const fetchData = async (url) => {
            console.log("Fetching data from:", url); // Debug log
            if (!url || typeof url !== 'string') {
               throw new Error("URL inválida proporcionada para fetchData.");
            }
            try {
                const response = await fetch(`${url}?action=getData`);
                console.log("Fetch response status:", response.status); // Debug log
                if (!response.ok) {
                    let errorText = `HTTP error ${response.status}`;
                    try {
                       errorText += ` - ${await response.text()}`;
                    } catch (e) { /* Ignore if reading text fails */ }
                    console.error("Network response was not ok:", errorText); // Debug log
                    throw new Error(`La respuesta de la red no fue correcta: ${errorText}`);
                }
                const data = await response.json();
                console.log("Fetched data:", data); // Debug log
                 // Ensure returned data fields are arrays
                 const finalData = Array.isArray(data.finalData) ? data.finalData : [];
                 const trackingData = Array.isArray(data.trackingData) ? data.trackingData : [];
                 const archivedData = Array.isArray(data.archivedData) ? data.archivedData : [];
                 const masterTrackingOrders = Array.isArray(data.masterTrackingOrders) ? data.masterTrackingOrders : [];

                return { finalData, trackingData, archivedData, masterTrackingOrders };
            } catch (error) {
                 console.error("Fetch data failed:", error);
                 // Improve error message for network issues
                 if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                    throw new Error("Error de red: No se pudo conectar al servidor. Verifica la URL y tu conexión a internet.");
                 }
                 throw error; // Re-throw other errors
            }
        };


        const saveData = async (url, requestBody) => {
            console.log("Saving data to:", url); // Debug log
             if (!url || typeof url !== 'string') {
               throw new Error("URL inválida proporcionada para saveData.");
            }
             // Basic validation for requestBody structure
             if (!requestBody || typeof requestBody !== 'object' || requestBody.action !== 'saveData' || !requestBody.payload) {
                console.error("Invalid request body for saveData:", requestBody);
                throw new Error("Formato de datos inválido para guardar.");
             }
            console.log("Save request body (stringified):", JSON.stringify(requestBody)); // Debug log

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: {
                        'Content-Type': 'text/plain', // Required for no-cors with Apps Script text payload
                    },
                    body: JSON.stringify(requestBody), // Send the whole object including action and payload
                });
                // In no-cors mode, we CANNOT read the response status or body.
                // We assume success if no network error is thrown.
                console.log("Save request sent (no-cors). Assuming success."); // Debug log
                return { status: 'success', message: 'Datos enviados al servidor (no-cors).' };
            } catch (error) {
                console.error("Error during save fetch:", error); // Debug log
                 // Improve error message for network issues
                 if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                    throw new Error("Error de red: No se pudo conectar al servidor para guardar. Verifica la URL y tu conexión a internet.");
                 }
                throw error; // Re-throw other errors
            }
        };


        // =================================================================================
        // INLINED: components/Spinner.tsx
        // =================================================================================
        const Spinner = () => {
          return (
            <div
              className="inline-block h-8 w-8 animate-spin rounded-full border-4 border-solid border-primary border-r-transparent align-[-0.125em] motion-reduce:animate-[spin_1.5s_linear_infinite]"
              role="status"
            >
              <span className="!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]">
                Cargando...
              </span>
            </div>
          );
        };


        // =================================================================================
        // INLINED: components/Notification.tsx
        // =================================================================================
        const Notification = ({ message, type = 'info', onClose }) => { // Default type to info
          const typeClasses = {
            success: 'bg-green-600',
            error: 'bg-red-600',
            warning: 'bg-yellow-600 text-black', // Use black text for better contrast on yellow
            info: 'bg-blue-600',
          };
          const [isVisible, setIsVisible] = useState(true);

          const handleClose = useCallback(() => {
              setIsVisible(false);
              if (onClose) {
                  onClose(); // Call the original onClose handler if provided
              }
          }, [onClose]);


          // Automatically close after a delay if onClose is provided
          useEffect(() => {
            if (onClose) { // Only set timeout if onClose is meant to auto-close
              const timer = setTimeout(() => {
                handleClose();
              }, 5000); // Default 5 seconds
              return () => clearTimeout(timer);
            }
          }, [handleClose, onClose]); // Depend on handleClose

           if (!isVisible) return null; // Don't render if not visible

          return (
            <div className={`fixed top-5 right-5 z-[250] p-4 rounded-lg shadow-lg text-white ${typeClasses[type] || typeClasses.info} flex items-center gap-4 animate-fade-in-down`}> {/* Added higher z-index and animation */}
              <span>{message}</span>
              {/* Always show close button */}
              <button onClick={handleClose} className="text-xl font-bold leading-none ml-2">&times;</button>
            </div>
          );
        };


        // =================================================================================
        // INLINED: components/Header.tsx
        // =================================================================================
        const Header = React.memo(({ onSave, onManageTemplates, onReconfigure }) => { // Memoize Header
          console.log("Rendering Header"); // Debug log
          return (
            <header className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 pb-4 border-b border-border-color">
              <div>
                <h1 className="text-3xl font-bold text-white">
                  GESTION NEGACIONES EJE CAFETERO
                </h1>
                <p className="text-text-secondary">Sistema Integrado de Gestión de Flujos de Trabajo</p>
              </div>
              <div className="flex flex-wrap gap-2">
                <button onClick={onManageTemplates} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors">
                  Gestionar Plantillas
                </button>
                <button onClick={onReconfigure} className="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg transition-colors flex items-center gap-2">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0L8.21 5.15a1.5 1.5 0 01-1.25.82l-2.09.28c-1.68.23-2.34 2.26-1.09 3.42l1.52 1.48a1.5 1.5 0 01-.42 2.1l-1.83 1.25c-1.38.94-.92 3.01.7 3.42l2.05.51a1.5 1.5 0 011.1.98l.8 2.07c.43 1.12 2.29 1.12 2.72 0l.8-2.07a1.5 1.5 0 011.1-.98l2.05-.51c1.62-.4 2.08-2.48.7-3.42l-1.83-1.25a1.5 1.5 0 01-.42-2.1l1.52-1.48c1.25-1.16.59-3.19-1.09-3.42L13 5.97a1.5 1.5 0 01-1.25-.82l-.3-1.98zM10 13a3 3 0 100-6 3 3 0 000 6z" clipRule="evenodd" />
                  </svg>
                  Reconfigurar Conexión
                </button>
                <button onClick={onSave} className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors flex items-center gap-2">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M5.5 16.5a2.5 2.5 0 01-5 0V4.414a1.5 1.5 0 01.44-1.06L4.354.439A1.5 1.5 0 015.414 0H12.5a2.5 2.5 0 012.5 2.5v2" />
                    <path d="M5.5 16.5h8a2.5 2.5 0 002.5-2.5V8.5h-13v5.5a2.5 2.5 0 002.5 2.5z" />
                    <path d="M10.5 10a.5.5 0 01.5-.5h2a.5.5 0 010 1h-2a.5.5 0 01-.5-.5z" />
                  </svg>
                  Guardar en la Nube
                </button>
              </div>
            </header>
          );
        }); // End of Memoized Header


        // =================================================================================
        // INLINED: components/Dashboard.tsx
        // =================================================================================
        const DashboardCard = React.memo(({ title, value, icon }) => ( // Memoize Card
          <div className="bg-surface p-4 rounded-lg border border-border-color flex items-center">
            <div className="text-3xl text-primary mr-4">{icon}</div>
            <div>
              <h4 className="text-sm font-semibold text-text-secondary uppercase tracking-wider">{title}</h4>
              <p className="text-2xl font-bold text-text-primary">{value}</p>
            </div>
          </div>
        ));

        const Dashboard = React.memo(({ reviewCount, trackingCount, archivedCount, editsCount }) => ( // Memoize Dashboard
          <section id="dashboard" className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
            <DashboardCard title="Casos en Revisión" value={reviewCount} icon={'📋'} />
            <DashboardCard title="Seguimiento Activo" value={trackingCount} icon={'⏳'} />
            <DashboardCard title="Casos Archivados" value={archivedCount} icon={'🗄️'} />
            <DashboardCard title="Ediciones en Sesión" value={editsCount} icon={'✏️'} />
          </section>
        )); // End of Memoized Dashboard


        // =================================================================================
        // INLINED: components/DataInputArea.tsx
        // =================================================================================
        const DataInputArea = React.memo(({ // Memoize DataInputArea
          id,
          title,
          headers,
          data,
          onDataChange,
          onProcess,
          processButtonText = "Procesar Datos",
          inputType = "paste", // "paste" or "file"
        }) => {
          console.log(`Rendering DataInputArea: ${id}`); // Debug log

          const handlePaste = useCallback((e) => {
            e.preventDefault();
            const pastedText = e.clipboardData.getData('text/plain');
            const newRows = processPastedData(pastedText, headers);

            // Ensure data is always an array before filtering
            const currentData = Array.isArray(data) ? data : [];
            // Filter out fully empty objects before adding new rows
            const filteredCurrent = currentData.filter(row => row && Object.values(row).some(val => String(val).trim() !== ''));
            const updatedData = [...filteredCurrent, ...newRows];

            // Add empty rows only if it's the paste input type
            if (inputType === 'paste') {
              const emptyRowCount = updatedData.filter(row => !row || !Object.values(row).some(val => String(val).trim() !== '')).length;
              const targetEmptyRows = 5; // Maintain 5 empty rows for pasting
              if (emptyRowCount < targetEmptyRows) {
                for (let i = 0; i < (targetEmptyRows - emptyRowCount); i++) {
                  updatedData.push({}); // Add empty object placeholders
                }
              }
            }

            onDataChange(updatedData);
          }, [data, headers, onDataChange, inputType]);

          const handleCellChange = useCallback((rowIndex, header, value) => {
             // Ensure data is always an array
            const currentData = Array.isArray(data) ? data : [];
            const newData = [...currentData];
            // Ensure the row exists before trying to update it
            if(newData[rowIndex]){
                // Create a new object for the updated row to ensure immutability
                newData[rowIndex] = { ...newData[rowIndex], [header]: value };
            } else {
                 console.warn(`Attempted to edit non-existent row at index ${rowIndex}`);
                 return; // Prevent further processing if row doesn't exist
            }

            // Add/remove empty rows only if it's the paste input type
             if (inputType === 'paste') {
               const targetEmptyRows = 5;
               // Filter out rows that are completely empty or just whitespace
               const nonEmptyRows = newData.filter(row => row && Object.values(row).some(val => String(val).trim() !== ''));
               const currentEmptyRowCount = newData.length - nonEmptyRows.length;

               // Add empty rows if needed
               if (currentEmptyRowCount < targetEmptyRows) {
                   for (let i = 0; i < (targetEmptyRows - currentEmptyRowCount); i++) {
                       nonEmptyRows.push({});
                   }
               }
               // Trim excess empty rows (leave exactly targetEmptyRows)
               const finalData = [...nonEmptyRows];
               while (finalData.filter(row => !row || !Object.values(row).some(val => String(val).trim() !== '')).length > targetEmptyRows && finalData.length > targetEmptyRows) {
                  const lastEmptyIndex = finalData.findLastIndex(row => !row || !Object.values(row).some(val => String(val).trim() !== ''));
                  if (lastEmptyIndex !== -1) {
                      finalData.splice(lastEmptyIndex, 1);
                  } else {
                      break; // Should not happen if logic is correct
                  }
               }
               onDataChange(finalData);
            } else {
                 onDataChange(newData); // For file input, just update the data
            }
          }, [data, onDataChange, inputType]);


          const handleFileChange = useCallback((e) => {
              const file = e.target.files[0];
              if (!file) return;

              const reader = new FileReader();
              reader.onload = (event) => {
                  try {
                      const fileData = new Uint8Array(event.target.result);
                      const workbook = XLSX.read(fileData, { type: 'array', cellDates: true, dateNF: 'yyyy-mm-dd' }); // Specify date format hint
                      const sheetName = workbook.SheetNames[0];
                      const worksheet = workbook.Sheets[sheetName];

                      // Get headers separately
                      const headerRow = XLSX.utils.sheet_to_json(worksheet, { header: 1, range: 0, raw: false, defval: '' })[0] || [];
                      const excelHeaders = headerRow.map(h => String(h).trim());

                       // Convert data rows, ensuring dates are parsed correctly
                       // Use raw: false initially to get formatted strings
                      const jsonDataObjects = XLSX.utils.sheet_to_json(worksheet, { raw: false, defval: '' });


                      if (jsonDataObjects.length === 0) {
                          alert("El archivo Excel no contiene filas de datos.");
                          return;
                      }

                      const normalizeHeadersAndData = (d, excelHeaderList) => {
                           // Define mappings based on expected Excel headers (case-insensitive)
                           // Use lowercase keys for robust matching
                          const keyMap = {
                              'fecha neg.': 'Fecha_Neg', 'no. orden': 'No_Orden', 'no. cédula': 'No_Cedula',
                              'entidad ejecutora': 'Entidad_Ejecutora', 'motivo negación': 'Motivo_Negacion',
                              'usuario emitió': 'Usuario_Emitio', 'observación auditor': 'Observacion_Auditor',
                              'observación ejecutivo': 'Observacion_Ejecutivo', 'antigüedad': 'Antiguedad',
                              'teléfono': 'Telefono', 'dirección': 'Direccion', 'tipo usuario': 'Tipo_Usuario',
                              'notificación': 'Notificacion', 'gestión': 'Gestion_Negacion',
                              'observación alternativa': 'Observacion_Alternativa', 'nit prestador': 'Nit_Prestador',
                              'fecha complementariedad': 'Fecha_Complementariedad', 'tiempo de gestion': 'Tiempo_de_Gestion',
                              // Add other expected headers from PORTAL_HEADERS in lowercase
                              'sucursal': 'Sucursal', 'nombre': 'Nombre', 'programa': 'Programa', 'plan': 'Plan',
                              'eps': 'EPS', 'celular': 'Celular', 'email': 'Email', 'edad': 'Edad', 'llamada': 'Llamada',
                              'complementariedad': 'Complementariedad', 'alternativa': 'Alternativa', 'monto': 'Monto',
                              'regional': 'Regional'
                          };
                          const dateKeysInternal = new Set(['Fecha_Neg', 'Fecha_Complementariedad']); // Internal keys expected to be dates

                           // Helper to attempt date parsing from various string formats or Excel numbers
                          const parseDateValue = (value) => {
                              if (value === null || value === undefined || String(value).trim() === '') return ''; // Return empty string for empty input
                              if (typeof value === 'number') { // Excel serial date
                                 try {
                                    const jsDate = XLSX.SSF.parse_date_code(value);
                                    if(jsDate) {
                                       // Format consistently as YYYY-MM-DD
                                       const year = jsDate.y;
                                       const month = String(jsDate.m).padStart(2, '0');
                                       const day = String(jsDate.d).padStart(2, '0');
                                       return `${year}-${month}-${day}`;
                                    }
                                 } catch (dateError) {
                                     console.warn("Error parsing Excel date number:", value, dateError);
                                 }
                              } else if (typeof value === 'string') {
                                  // Try common formats like DD/MM/YYYY, MM/DD/YYYY, YYYY-MM-DD etc.
                                  // Simple check for YYYY-MM-DD first
                                  if (/^\d{4}-\d{2}-\d{2}$/.test(value)) return value;

                                  // Attempt parsing other formats (this can be complex, keep it simple for now)
                                  try {
                                      // Handle DD/MM/YYYY specifically if common
                                      const parts = value.match(/(\d{1,2})[/|-](\d{1,2})[/|-](\d{4})/);
                                      if (parts) {
                                          // Assuming DD/MM/YYYY - adjust if MM/DD/YYYY is possible
                                          const year = parseInt(parts[3], 10);
                                          const month = String(parseInt(parts[2], 10)).padStart(2, '0');
                                          const day = String(parseInt(parts[1], 10)).padStart(2, '0');
                                          // Basic validation
                                          if (year > 1900 && parseInt(month, 10) >= 1 && parseInt(month, 10) <= 12 && parseInt(day, 10) >= 1 && parseInt(day, 10) <= 31) {
                                             return `${year}-${month}-${day}`;
                                          }
                                      }
                                      // Generic Date parsing (less reliable for ambiguous formats)
                                      const parsed = new Date(value);
                                      if (!isNaN(parsed)) {
                                          const year = parsed.getFullYear();
                                          const month = String(parsed.getMonth() + 1).padStart(2, '0');
                                          const day = String(parsed.getDate()).padStart(2, '0');
                                          return `${year}-${month}-${day}`;
                                      }
                                  } catch (parseError) {
                                      console.warn("Could not parse date string:", value, parseError);
                                  }
                              }
                              // If parsing fails, return the original value as string
                              console.warn(`Returning original value for date column as string:`, value);
                              return String(value);
                          };


                          return d.map(row => {
                              const newRow = {};
                              // Initialize all PORTAL_HEADERS with empty strings
                              PORTAL_HEADERS.forEach(header => { newRow[header] = ''; });

                              for (const key in row) {
                                  const trimmedKeyLower = String(key).trim().toLowerCase();
                                  const internalKey = keyMap[trimmedKeyLower]; // Find the corresponding internal key

                                  if (internalKey) { // If the Excel header is recognized
                                     if (dateKeysInternal.has(internalKey)) {
                                         newRow[internalKey] = parseDateValue(row[key]);
                                     } else {
                                         // Assign value directly for non-date columns, ensuring it's a string
                                         newRow[internalKey] = row[key] !== null && row[key] !== undefined ? String(row[key]) : '';
                                     }
                                  } else {
                                     // Optionally handle unrecognized columns (e.g., log them)
                                     // console.warn(`Unrecognized column header in Excel: "${key}"`);
                                     // You could store them with a prefix, e.g., newRow[`excel_${key.replace(/ /g, '_')}`] = String(row[key]);
                                  }
                              }
                              return newRow;
                          });
                      };


                      const normalizedData = normalizeHeadersAndData(jsonDataObjects, excelHeaders);
                      onDataChange(normalizedData);
                      e.target.value = null; // Reset file input
                  } catch (error) {
                      console.error("Error processing Excel file:", error);
                      alert("Hubo un error al procesar el archivo Excel. Asegúrate de que el formato y las columnas son correctos.\n" + error.message);
                      onDataChange([]); // Clear data on error
                  }
              };
              reader.onerror = (error) => {
                   console.error("Error reading file:", error);
                   alert("Hubo un error al leer el archivo.");
                   onDataChange([]); // Clear data on error
              };
              reader.readAsArrayBuffer(file);
          }, [onDataChange, headers]); // Include headers in dependencies for processPastedData

          const clearTable = useCallback(() => {
            onDataChange(inputType === 'paste' ? Array(5).fill({}) : []);
          }, [inputType, onDataChange]);

          // Ensure 'data' is always an array for rendering
          const renderData = useMemo(() => Array.isArray(data) ? data : (inputType === 'paste' ? Array(5).fill({}) : []), [data, inputType]);


          return (
            <section id={id} className="space-y-4">
              <h2 className="text-2xl font-bold text-primary border-b border-border-color pb-2">{title}</h2>

              {inputType === 'file' && (
                 <div className="flex items-center gap-4">
                   <label htmlFor={`${id}-file-upload`} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors cursor-pointer">
                       Subir Archivo Excel
                   </label>
                   <input
                       id={`${id}-file-upload`}
                       type="file"
                       className="hidden"
                       accept=".xlsx, .xls, .csv" // Added CSV support
                       onChange={handleFileChange}
                   />
                   <span className="text-text-secondary">{renderData.length > 0 && renderData.some(row => Object.values(row).some(v=>v)) ? `${renderData.filter(row => Object.values(row).some(v=>v)).length} fila(s) cargada(s)` : 'Ningún archivo seleccionado'}</span>
                 </div>
              )}

              <div className="table-container max-h-72 overflow-auto border border-border-color rounded-lg">
                <table className="w-full text-sm text-left text-text-secondary table-fixed"> {/* Use table-fixed */}
                  <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                    <tr>
                      {headers.map(header => (
                        <th key={header} scope="col" className="px-4 py-3 whitespace-nowrap overflow-hidden text-ellipsis w-40">{header.replace(/_/g, ' ')}</th> // Add fixed width
                      ))}
                    </tr>
                  </thead>
                  <tbody onPaste={inputType === 'paste' ? handlePaste : undefined}>
                    {renderData.map((row, rowIndex) => (
                      <tr key={rowIndex} className="border-b border-border-color hover:bg-highlight group">
                        {headers.map(header => (
                          <td
                            key={`${rowIndex}-${header}`}
                            className="px-4 py-2 border-r border-border-color focus:bg-primary focus:text-black outline-none whitespace-nowrap overflow-hidden text-ellipsis w-40 group-focus-within:whitespace-normal group-hover:whitespace-normal" // Adjust width, handle wrap on focus/hover
                            contentEditable={inputType === 'paste'}
                            onBlur={inputType === 'paste' ? (e) => handleCellChange(rowIndex, header, e.currentTarget.innerText) : undefined}
                            suppressContentEditableWarning={true}
                          >
                            {(typeof row === 'object' && row !== null && row[header] !== undefined) ? String(row[header]) : ''}
                          </td>
                        ))}
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
              <div className="flex gap-4">
                <button
                    onClick={onProcess}
                    // Disable if renderData is empty or (if paste type) all rows are effectively empty
                    disabled={renderData.length === 0 || (inputType === 'paste' && renderData.every(row => !row || !Object.values(row).some(val => String(val).trim() !== '')))}
                    className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed"
                 >
                  {processButtonText}
                </button>
                <button onClick={clearTable} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                  Limpiar Tabla
                </button>
              </div>
            </section>
          );
        }); // End of Memoized DataInputArea


        // =================================================================================
        // INLINED: components/ReviewArea.tsx
        // =================================================================================
        const ReviewArea = React.memo(({ // Memoize ReviewArea
          data,
          templates,
          updateRow,
          incrementEdits,
          onSendToTracking,
          onPreview,
          onExportForMailMerge,
          onClearReviewData,
          sortConfig,
          setSortConfig,
        }) => {
          console.log("Rendering ReviewArea"); // Debug log
          const [selectedRows, setSelectedRows] = useState(new Set());
          const [filter, setFilter] = useState('');

          const REVIEW_HEADERS = useMemo(() => [ // Memoize headers array
              { key: 'Fecha_Neg', label: 'Fecha Neg.' },
              { key: 'No_Orden', label: 'No. Orden' },
              { key: 'No_Cedula', label: 'No. Cédula' },
              { key: 'Nombre', label: 'Nombre' },
              { key: 'EPS', label: 'EPS' },
              { key: 'Programa', label: 'Programa', compact: true },
              { key: 'Motivo_Negacion', label: 'Motivo Neg.', compact: true },
              { key: 'Descripcion_PDF', label: 'Descripción', compact: true },
              { key: 'Justificacion_PDF', label: 'Justificación', compact: true },
              { key: 'Fundamento_Legal_PDF', label: 'Fund. Legal', compact: true },
          ], []);

          // Ensure 'data' is always an array before filtering/sorting
          const currentData = Array.isArray(data) ? data : [];

          const filteredData = useMemo(() => {
            if (!filter) return currentData;
            const lowercasedFilter = filter.toLowerCase();
            return currentData.filter(row =>
              row && typeof row === 'object' && // Ensure row is a valid object
              Object.values(row).some(value =>
                String(value).toLowerCase().includes(lowercasedFilter)
              )
            );
          }, [currentData, filter]); // Depend on currentData


          // Clear selection when filtered data changes drastically
          useEffect(() => {
             setSelectedRows(prevSelected => {
                 const currentKeys = new Set(filteredData.map(r => String(r.No_Orden)));
                 const newSelection = new Set();
                 for (const key of prevSelected) {
                     if (currentKeys.has(key)) {
                         newSelection.add(key);
                     }
                 }
                 return newSelection;
             });
          }, [filteredData]);


          const handleSelectRow = useCallback((noOrden) => {
            const key = String(noOrden); // Ensure key is string for Set consistency
            setSelectedRows(prevSelection => {
               const newSelection = new Set(prevSelection);
               if (newSelection.has(key)) {
                 newSelection.delete(key);
               } else {
                 newSelection.add(key);
               }
               return newSelection;
            });
          }, []); // No external dependencies

          const handleSelectAll = useCallback((e) => {
            if (e.target.checked) {
              const allOrderNumbers = filteredData
                .map(row => row ? String(row.No_Orden) : null) // Get No_Orden as string, handle potential null rows
                .filter(Boolean); // Remove nulls/undefined
              setSelectedRows(new Set(allOrderNumbers));
            } else {
              setSelectedRows(new Set());
            }
          }, [filteredData]); // Depends on filteredData

          const handleCellBlur = useCallback((noOrden, key, value) => {
            // Find row using string comparison for No_Orden IN THE ORIGINAL (unfiltered) data
             const originalRow = currentData.find(r => r && String(r.No_Orden) === String(noOrden));
             if (originalRow && String(originalRow[key] || '') !== value) { // Compare as strings, handle undefined/null
               updateRow(noOrden, { [key]: value }); // Pass original noOrden (might be number or string)
               // incrementEdits() is called within updateFinalDataRow now
             }
          }, [currentData, updateRow]); // Depends on currentData


          const handleSelectChange = useCallback((noOrden, value) => {
            const changes = { Tipo_Carta: value };
            const safeTemplates = Array.isArray(templates) ? templates : []; // Ensure templates is array
            const template = safeTemplates.find(t => t.id === value);
            // Reset Radicado_Comp only if changing *away* from a Complementariedad template or to no template
            if (!template || !template.name.toUpperCase().includes('COMPLEMENTARIEDAD')) {
               changes.Radicado_Comp = '';
            }
             // Pass original noOrden (might be number or string)
            updateRow(noOrden, changes);
            // incrementEdits() is called within updateFinalDataRow now
          }, [templates, updateRow]); // Depends on templates


          const requestSort = useCallback((key) => {
            setSortConfig(currentSortConfig => {
                let direction = 'ascending';
                if (currentSortConfig.key === key && currentSortConfig.direction === 'ascending') {
                  direction = 'descending';
                }
               return { key, direction };
            });
          }, [setSortConfig]); // Depends on setSortConfig

          const getSortIndicator = useCallback((key) => {
            if (sortConfig.key !== key) return null;
            return sortConfig.direction === 'ascending' ? ' ▲' : ' ▼';
          }, [sortConfig]); // Depends on sortConfig

          const handleExport = useCallback(() => {
              onExportForMailMerge(currentData); // Export original unfiltered/unsorted data
          }, [onExportForMailMerge, currentData]);


          return (
            <section id="area3" className="space-y-4">
              <h2 className="text-2xl font-bold text-primary border-b border-border-color pb-2">Área 3: Revisión Final y Exportación</h2>
              <div className="action-bar bg-highlight p-4 rounded-lg flex flex-wrap items-center gap-4">
                <input
                  type="text"
                  placeholder="Buscar en tabla de revisión..."
                  className="bg-surface border border-border-color rounded-md px-3 py-2 text-text-primary placeholder-text-secondary w-full sm:w-auto"
                  value={filter}
                  onChange={(e) => setFilter(e.target.value)}
                />
                <span className="text-text-primary">{selectedRows.size} fila(s) seleccionada(s)</span>
              </div>

              <div className="table-container max-h-[70vh] overflow-auto border border-border-color rounded-lg"> {/* Increased max height */}
                <table className="w-full text-sm text-left text-text-secondary table-fixed"> {/* table-fixed */}
                  <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                    <tr>
                      <th className="px-4 py-3 w-10"><input type="checkbox" onChange={handleSelectAll} checked={filteredData.length > 0 && selectedRows.size === filteredData.length && selectedRows.size > 0} /></th> {/* Fixed width */}
                      <th className="px-4 py-3 w-10">👁️</th> {/* Fixed width */}
                       {REVIEW_HEADERS.map(({ key, label, compact }) => (
                         <th key={key} onClick={() => requestSort(key)} className={`px-4 py-3 cursor-pointer whitespace-nowrap overflow-hidden text-ellipsis ${compact ? 'w-32' : 'w-48'}`}> {/* Widths */}
                             {label}{getSortIndicator(key)}
                         </th>
                       ))}
                      <th className="px-4 py-3 w-56">Tipo de Carta</th> {/* Width */}
                    </tr>
                  </thead>
                  <tbody>
                   {filteredData.map((row) => { // Map over filteredData for rendering
                      if (!row || typeof row !== 'object' || !row.No_Orden) {
                        // This check might be redundant if data source is clean, but safe
                        console.warn("Skipping potentially invalid row in ReviewArea render:", row);
                        return null;
                      }

                      const noOrdenKey = String(row.No_Orden);
                      const safeTemplates = Array.isArray(templates) ? templates : [];
                      const template = safeTemplates.find(t => t.id === row.Tipo_Carta);
                      const isComplementariedad = template && template.name.toUpperCase().includes('COMPLEMENTARIEDAD');
                      const requiresRadicado = isComplementariedad;

                      return (
                        <tr key={noOrdenKey} className={`border-b border-border-color hover:bg-highlight group ${isComplementariedad ? 'bg-indigo-900/50' : ''} ${selectedRows.has(noOrdenKey) ? 'bg-primary/20' : ''}`}>
                          <td className="px-4 py-2 w-10"><input type="checkbox" checked={selectedRows.has(noOrdenKey)} onChange={() => handleSelectRow(noOrdenKey)} /></td>
                          <td className="px-4 py-2 text-lg cursor-pointer w-10 text-center" onClick={() => onPreview(row)}>👁️</td>
                          {REVIEW_HEADERS.map(({ key, compact }) => (
                            <td key={key}
                                className={`px-4 py-2 border-r border-border-color outline-none whitespace-nowrap overflow-hidden text-ellipsis focus:bg-primary focus:text-black group-focus-within:whitespace-normal group-hover:whitespace-normal ${compact ? 'w-32' : 'w-48'}`}
                                contentEditable
                                onBlur={(e) => handleCellBlur(row.No_Orden, key, e.currentTarget.innerText)}
                                suppressContentEditableWarning={true}
                                // Use dangerouslySetInnerHTML ONLY if you trust the source or sanitize it.
                                // Prefer rendering text directly. If HTML is needed, consider a safe renderer.
                            >
                                {String(row[key] ?? '')} {/* Ensure value is string, default empty */}
                            </td>
                          ))}
                          <td className="px-4 py-2 w-56">
                            <div className="flex flex-col gap-1">
                              <select
                                value={row.Tipo_Carta || ''}
                                onChange={(e) => handleSelectChange(row.No_Orden, e.target.value)}
                                className="bg-surface border border-border-color rounded-md px-2 py-1 text-text-primary w-full text-xs" // smaller text
                              >
                                <option value="">-- Seleccionar --</option>
                                {safeTemplates.map(t => <option key={t.id} value={t.id} title={t.name}>{t.name}</option>)}
                              </select>
                              {requiresRadicado && (
                                <input
                                  type="text"
                                  placeholder="Radicado..."
                                  value={row.Radicado_Comp || ''}
                                  onChange={(e) => updateRow(row.No_Orden, { Radicado_Comp: e.target.value })}
                                  className="bg-surface border border-border-color rounded-md px-2 py-1 text-text-primary w-full mt-1 text-xs" // smaller text
                                />
                              )}
                            </div>
                          </td>
                        </tr>
                      );
                    })}
                     {filteredData.length === 0 && (
                        <tr><td colSpan={REVIEW_HEADERS.length + 3} className="text-center py-4 text-text-secondary italic">No hay casos en revisión o no coinciden con la búsqueda.</td></tr>
                     )}
                  </tbody>
                </table>
              </div>
              <div className="flex flex-wrap gap-4">
                <button
                    onClick={() => onSendToTracking(Array.from(selectedRows))}
                    disabled={selectedRows.size === 0}
                    className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Enviar a Seguimiento ({selectedRows.size})
                </button>
                 <button
                    onClick={handleExport}
                    disabled={currentData.length === 0}
                    className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                 >
                   Exportar para Envío Masivo ({currentData.length})
                 </button>
                <button
                    onClick={onClearReviewData}
                    className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors"
                >
                  Limpiar Tabla de Revisión
                </button>
              </div>
            </section>
          );
        }); // End of Memoized ReviewArea


        // =================================================================================
        // INLINED: components/TrackingArea.tsx
        // =================================================================================
        const TrackingTable = React.memo(({ data, isArchived, onUpdate, onArchive, filter }) => { // Memoize TrackingTable
            console.log(`Rendering TrackingTable (Archived: ${isArchived})`); // Debug log

          const [selectedRows, setSelectedRows] = useState(new Set());

          const statusClasses = useMemo(() => ({ // Memoize status classes object
            'Pendiente': 'bg-yellow-600/20',
            'En Gestión': 'bg-blue-600/20',
            'Finalizado': 'bg-green-600/20',
          }), []);

          // Ensure data is always an array
          const currentData = Array.isArray(data) ? data : [];

          const filteredData = useMemo(() => {
            if (!filter) return currentData;
            const lowercasedFilter = filter.toLowerCase();
            return currentData.filter(row =>
              row && typeof row === 'object' && // Ensure row is valid
              Object.values(row).some(value =>
                String(value).toLowerCase().includes(lowercasedFilter)
              )
            );
          }, [currentData, filter]); // Depend on currentData

          // Clear selection when filtered data changes
           useEffect(() => {
               setSelectedRows(prevSelected => {
                   const currentIndices = new Set(filteredData.map(r => currentData.indexOf(r)).filter(i => i !== -1));
                   const newSelection = new Set();
                   for (const index of prevSelected) {
                       if (currentIndices.has(index)) {
                           newSelection.add(index);
                       }
                   }
                   return newSelection;
               });
           }, [filteredData, currentData]);


          const handleSelectRow = useCallback((index) => {
            setSelectedRows(prevSelection => {
               const newSelection = new Set(prevSelection);
               if (newSelection.has(index)) {
                 newSelection.delete(index);
               } else {
                 newSelection.add(index);
               }
               return newSelection;
            });
          }, []); // No external deps

          const handleSelectAll = useCallback((e) => {
            if (e.target.checked) {
               // Use indices of the currently filtered data mapped back to original indices
              setSelectedRows(new Set(filteredData.map((row) => currentData.indexOf(row)).filter(index => index !== -1)));
            } else {
              setSelectedRows(new Set());
            }
          }, [filteredData, currentData]); // Depends on filteredData and currentData

          const handleBulkArchive = useCallback(() => {
            if (selectedRows.size > 0) {
              onArchive(Array.from(selectedRows)); // Pass indices
              setSelectedRows(new Set()); // Clear selection after action
            }
          }, [selectedRows, onArchive]); // Depends on selectedRows

          const handleCellUpdate = useCallback((originalIndex, field, value) => {
               const row = currentData[originalIndex];
               // Only call update if value actually changed
               if (row && String(row[field] || '') !== value) {
                  onUpdate(originalIndex, { ...row, [field]: value });
               }
           }, [currentData, onUpdate]);


          return (
            <div className="space-y-4">
              <div className="flex justify-between items-center">
                   <span className="text-text-secondary text-sm">
                       {selectedRows.size > 0 ? `${selectedRows.size} seleccionado(s)` : ''}
                   </span>
                   {selectedRows.size > 0 && (
                       <button
                           onClick={handleBulkArchive}
                           className={`font-bold py-2 px-4 rounded-lg transition-colors text-white ${isArchived ? 'bg-green-600 hover:bg-green-700' : 'bg-gray-600 hover:bg-gray-700'}`}
                       >
                           {isArchived ? `♻️ Restaurar (${selectedRows.size})` : `🗄️ Archivar (${selectedRows.size})`}
                       </button>
                   )}
              </div>
              <div className="table-container max-h-[40vh] overflow-auto border border-border-color rounded-lg"> {/* Adjusted height */}
                <table className="w-full text-sm text-left text-text-secondary table-fixed"> {/* table-fixed */}
                  <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                    <tr>
                      <th className="px-4 py-3 w-10"><input type="checkbox" onChange={handleSelectAll} checked={filteredData.length > 0 && selectedRows.size === filteredData.length && selectedRows.size > 0}/></th> {/* Width */}
                      <th className="px-4 py-3 w-32">Fecha Ing.</th> {/* Width */}
                      <th className="px-4 py-3 w-32">No. Orden</th> {/* Width */}
                      <th className="px-4 py-3 w-48">Nombre</th> {/* Width */}
                      <th className="px-4 py-3 w-32">EPS</th> {/* Width */}
                      <th className="px-4 py-3 w-32">Radicado</th> {/* Width */}
                      <th className="px-4 py-3 w-36">Estado</th> {/* Width */}
                      <th className="px-4 py-3 flex-1 min-w-[200px]">Notas</th> {/* Flexible width */}
                      <th className="px-4 py-3 w-16">Acción</th> {/* Width */}
                    </tr>
                  </thead>
                  <tbody>
                   {filteredData.map((row) => {
                       const originalIndex = currentData.indexOf(row);
                       if (!row || typeof row !== 'object' || originalIndex === -1) return null;

                       const rowClasses = `border-b border-border-color hover:bg-highlight transition-colors group ${isArchived ? 'bg-archive/30 text-text-secondary' : statusClasses[row.Estado] || ''} ${selectedRows.has(originalIndex) ? '!bg-primary/30' : ''}`; // Use !important for selection highlight


                      return (
                        <tr key={originalIndex} className={rowClasses}>
                          <td className="px-4 py-2 w-10"><input type="checkbox" checked={selectedRows.has(originalIndex)} onChange={() => handleSelectRow(originalIndex)} /></td>
                          <td className="px-4 py-2 w-32 whitespace-nowrap">{row.Fecha_Ing || ''}</td>
                          <td className="px-4 py-2 w-32 whitespace-nowrap">{row.No_Orden || ''}</td>
                          <td className="px-4 py-2 w-48 whitespace-nowrap overflow-hidden text-ellipsis" title={row.Nombre}>{row.Nombre || ''}</td>
                          <td className="px-4 py-2 w-32 whitespace-nowrap overflow-hidden text-ellipsis" title={row.EPS}>{row.EPS || ''}</td>
                          <td className="px-4 py-2 w-32 whitespace-nowrap overflow-hidden text-ellipsis" title={row.Radicado}>{row.Radicado || ''}</td>
                          <td className="px-4 py-2 w-36">
                            <select
                              value={row.Estado || TRACKING_STATUSES[0]}
                              onChange={e => handleCellUpdate(originalIndex, 'Estado', e.target.value)}
                              className="bg-surface border border-border-color rounded-md px-2 py-1 text-text-primary w-full text-xs" // smaller text
                              disabled={isArchived} // Disable editing in archive
                            >
                              {TRACKING_STATUSES.map(s => <option key={s} value={s}>{s}</option>)}
                            </select>
                          </td>
                          <td
                              className="px-4 py-2 outline-none focus:bg-primary focus:text-black min-w-[200px] group-focus-within:whitespace-normal group-hover:whitespace-normal" // Allow wrap on focus/hover
                              contentEditable={!isArchived} // Disable editing in archive
                              onBlur={e => handleCellUpdate(originalIndex, 'Notas', e.currentTarget.innerText)}
                              suppressContentEditableWarning={true}
                              // Render plain text, avoid dangerouslySetInnerHTML unless absolutely necessary and sanitized
                           >
                                {row.Notas || ''}
                           </td>
                          <td className="px-4 py-2 text-lg cursor-pointer w-16 text-center" onClick={() => onArchive([originalIndex])}>{isArchived ? '♻️' : '🗄️'}</td>
                        </tr>
                      );
                    })}
                     {filteredData.length === 0 && (
                        <tr><td colSpan={9} className="text-center py-4 text-text-secondary italic">
                            {isArchived ? 'No hay casos archivados' : 'No hay casos activos'} {filter ? ' que coincidan con la búsqueda.' : '.'}
                        </td></tr>
                     )}
                  </tbody>
                </table>
              </div>
            </div>
          );
        }); // End of Memoized TrackingTable

        const TrackingArea = React.memo(({ trackingData, archivedData, updateTrackingData, archiveItems }) => { // Memoize TrackingArea
          console.log("Rendering TrackingArea"); // Debug log
          const [showArchived, setShowArchived] = useState(false);
          const [filter, setFilter] = useState('');
           // Ensure data props are arrays
          const currentTrackingData = Array.isArray(trackingData) ? trackingData : [];
          const currentArchivedData = Array.isArray(archivedData) ? archivedData : [];


          return (
            <section id="area4" className="space-y-4">
              <h2 className="text-2xl font-bold text-primary border-b border-border-color pb-2">Área 4: Seguimiento</h2>
              <div className="action-bar bg-highlight p-4 rounded-lg flex flex-wrap items-center gap-4 justify-between">
                <input
                  type="text"
                  placeholder="Buscar en seguimiento (Activos y Archivados)..."
                  className="bg-surface border border-border-color rounded-md px-3 py-2 text-text-primary placeholder-text-secondary w-full sm:w-1/2 lg:w-1/3"
                  value={filter}
                  onChange={e => setFilter(e.target.value)}
                />
                <button onClick={() => setShowArchived(!showArchived)} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">
                  {showArchived ? 'Ocultar' : 'Mostrar'} Archivados ({currentArchivedData.length})
                </button>
              </div>

              <h3 className="text-xl font-semibold text-white">Casos Activos ({currentTrackingData.length})</h3>
              <TrackingTable
                data={currentTrackingData} // Pass guaranteed array
                isArchived={false}
                onUpdate={updateTrackingData} // Pass the callback directly
                onArchive={archiveItems} // Pass the callback directly
                filter={filter}
              />

              {showArchived && (
                <div className="mt-8">
                  <h3 className="text-xl font-semibold text-white">Casos Archivados ({currentArchivedData.length})</h3>
                  <TrackingTable
                    data={currentArchivedData} // Pass guaranteed array
                    isArchived={true}
                    onUpdate={updateTrackingData} // Pass the callback directly
                    onArchive={archiveItems} // Pass the callback directly
                    filter={filter}
                  />
                </div>
              )}
            </section>
          );
        }); // End of Memoized TrackingArea

        // =================================================================================
        // INLINED: components/SetupModal.tsx
        // =================================================================================
        const SetupModal = ({ onSave, onClose, initialUrl = '' }) => { // Cannot easily memoize modals with internal state like this
          const [url, setUrl] = useState(initialUrl);
          const [isVerifying, setIsVerifying] = useState(false);
          const [errorMsg, setErrorMsg] = useState(''); // State for error message

          const handleSave = async () => {
            setErrorMsg(''); // Clear previous errors
            if (!url || !url.startsWith('https://script.google.com/macros/s/')) {
              setErrorMsg("Por favor, introduce una URL válida de Google Apps Script (debe empezar con https://script.google.com/macros/s/).");
              return;
            }
            setIsVerifying(true);
            try {
                // onSave should throw an error if verification fails
                await onSave(url);
                // No need to explicitly close here, parent component handles it on success via state update
            } catch (error) {
                 console.error("Verification failed:", error);
                 // Display a user-friendly error message from the caught error
                 setErrorMsg(`Falló la verificación: ${error.message}. Revisa la URL y los permisos.`);
            } finally {
                setIsVerifying(false); // Ensure verifying state is reset even if error occurs
            }
          };

          return (
            <div className="fixed inset-0 bg-background bg-opacity-90 flex justify-center items-center z-[200] p-4"> {/* Increased z-index */}
              <div className="bg-surface rounded-lg shadow-xl w-full max-w-lg border border-border-color p-8 space-y-6">
                <div className="text-center">
                  <h2 className="text-2xl font-bold text-primary">Configuración de Conexión</h2>
                  <p className="text-text-secondary mt-2">
                      Proporciona la URL de Google Apps Script implementada como aplicación web.
                  </p>
                </div>
                <div>
                  <label htmlFor="script-url" className="block text-sm font-medium text-text-primary mb-1">
                      URL del Script
                  </label>
                  <input
                      id="script-url"
                      type="url"
                      value={url}
                      onChange={(e) => { setUrl(e.target.value); setErrorMsg(''); }} // Clear error on change
                      placeholder="https://script.google.com/macros/s/..."
                      className={`w-full bg-background border rounded-md px-3 py-2 text-text-primary placeholder-text-secondary focus:ring-primary focus:border-primary ${errorMsg ? 'border-danger' : 'border-border-color'}`} // Highlight on error
                      aria-invalid={!!errorMsg}
                      aria-describedby="url-error"
                  />
                  {errorMsg && <p id="url-error" className="text-danger text-sm mt-1">{errorMsg}</p>}
                </div>
                <div className="flex justify-end gap-4">
                  <button
                      onClick={onClose} // Let parent handle close logic
                      disabled={isVerifying}
                      className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                      Cancelar
                  </button>
                  <button
                      onClick={handleSave}
                      disabled={isVerifying || !url}
                      className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed min-w-[150px] flex justify-center items-center" // Ensure button size stays consistent
                  >
                      {isVerifying ? <Spinner /> : 'Guardar y Verificar'}
                  </button>
                </div>
              </div>
            </div>
          );
        };

        // =================================================================================
        // INLINED: components/TemplateManagerModal.tsx
        // =================================================================================
        const TemplateManagerModal = ({ templates, onClose, onSave, onReset }) => { // Cannot easily memoize modals
          const [currentTemplates, setCurrentTemplates] = useState(() => structuredClone(Array.isArray(templates) ? templates : [])); // Deep clone initial templates
          const [editingTemplate, setEditingTemplate] = useState(null); // Holds the template being edited/created

          const handleSaveLocal = useCallback(() => {
            // Add validation before saving if needed
            onSave(currentTemplates); // Pass the current state up
          }, [currentTemplates, onSave]);

          const handleAddNew = useCallback(() => {
            // Create a truly new ID for the new template
            setEditingTemplate({ id: `custom_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`, name: '', body: '' });
          }, []);

          const handleEdit = useCallback((template) => {
             // Create a copy for editing to avoid modifying the list directly
             setEditingTemplate({ ...template });
          }, []);

          const handleDelete = useCallback((idToDelete) => {
            if (window.confirm('¿Estás seguro de que quieres eliminar esta plantilla? Esta acción no se puede deshacer.')) {
              setCurrentTemplates(current => current.filter(t => t.id !== idToDelete)); // Use functional update
            }
          }, []);

          const handleSaveTemplateEdit = useCallback(() => {
            if (!editingTemplate || !editingTemplate.name.trim() || !editingTemplate.body.trim()) {
              alert('El nombre y el cuerpo de la plantilla no pueden estar vacíos.');
              return;
            }

            setCurrentTemplates(current => {
                const updatedTemplates = Array.isArray(current) ? [...current] : []; // Ensure it's an array
                const existingIndex = updatedTemplates.findIndex(t => t.id === editingTemplate.id);
                if (existingIndex > -1) {
                    // Update existing
                    updatedTemplates[existingIndex] = { ...editingTemplate }; // Ensure it's a new object
                } else {
                    // Add new
                    updatedTemplates.push({ ...editingTemplate }); // Ensure it's a new object
                }
                return updatedTemplates;
            });
            setEditingTemplate(null); // Close editor
          }, [editingTemplate]); // Depends on the template being edited


           // Handler for input changes within the editor
           const handleEditorChange = useCallback((field, value) => {
                setEditingTemplate(prev => prev ? ({ ...prev, [field]: value }) : null);
           }, []);


          return (
            <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[150] p-4"> {/* Increased z-index */}
              <div className="bg-surface rounded-lg shadow-xl w-full max-w-4xl border border-border-color flex flex-col max-h-[90vh]">
                <div className="p-6 border-b border-border-color flex justify-between items-center flex-shrink-0"> {/* Header */}
                  <h3 className="text-xl font-bold text-primary">Gestionar Plantillas de Correo</h3>
                  <button onClick={onClose} className="text-text-secondary text-2xl hover:text-text-primary">&times;</button>
                </div>

                <div className="p-6 overflow-y-auto space-y-6 flex-grow"> {/* Content Area */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6 h-full"> {/* Layout */}

                    {/* Left Side: List of Templates */}
                    <div className="flex flex-col h-full">
                      <div className="flex justify-between items-center mb-2">
                         <h4 className="text-lg font-semibold">Plantillas Actuales</h4>
                         <button onClick={handleAddNew} className="bg-green-600 hover:bg-green-700 text-white text-xs font-bold py-1 px-2 rounded disabled:opacity-50" disabled={!!editingTemplate}>
                           + Nueva
                         </button>
                      </div>
                      <ul className="space-y-2 border border-border-color rounded-lg p-2 overflow-y-auto flex-grow bg-background/30">
                        {currentTemplates.map(template => (
                          <li key={template.id} className={`flex justify-between items-center p-2 rounded transition-colors ${editingTemplate?.id === template.id ? 'bg-primary/30 ring-1 ring-primary' : 'bg-highlight hover:bg-highlight/70'}`}>
                            <span className="text-text-primary truncate flex-grow mr-2" title={template.name}>{template.name}</span>
                            <div className="space-x-2 flex-shrink-0">
                              <button onClick={() => handleEdit(template)} className="text-xs bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded disabled:opacity-50" disabled={!!editingTemplate}>Editar</button>
                              <button onClick={() => handleDelete(template.id)} className="text-xs bg-danger hover:bg-danger-hover px-2 py-1 rounded disabled:opacity-50" disabled={!!editingTemplate}>Borrar</button>
                            </div>
                          </li>
                        ))}
                         {currentTemplates.length === 0 && <li className="text-text-secondary text-center p-4 italic">No hay plantillas guardadas.</li>}
                      </ul>
                    </div>

                    {/* Right Side: Editor/Placeholder */}
                    <div className="flex flex-col h-full">
                       <h4 className="text-lg font-semibold mb-2">
                          {editingTemplate ? (currentTemplates.some(t => t.id === editingTemplate.id) ? 'Editar Plantilla' : 'Nueva Plantilla') : 'Editor de Plantilla'}
                       </h4>
                       {editingTemplate ? (
                           <div className="space-y-3 p-4 border border-border-color rounded-lg bg-highlight flex flex-col flex-grow">
                             <input
                               type="text"
                               placeholder="Nombre de la Plantilla"
                               value={editingTemplate.name}
                               onChange={(e) => handleEditorChange('name', e.target.value)}
                               className="w-full bg-background border border-border-color rounded-md px-3 py-2 text-sm flex-shrink-0"
                             />
                             <textarea
                               placeholder="Cuerpo de la Plantilla (HTML permitido)..."
                               value={editingTemplate.body}
                               onChange={(e) => handleEditorChange('body', e.target.value)}
                               className="w-full bg-background border border-border-color rounded-md px-3 py-2 resize-y flex-grow text-sm min-h-[200px]" // Ensure minimum height
                             />
                              <p className="text-xs text-text-secondary flex-shrink-0">Marcadores disponibles: {`{{Columna}}`} (ej: {`{{Nombre}}`}, {`{{No_Orden}}`}, {`{{EPS}}`}, {`{{Oficina_Virtual_EPS}}`}, etc.)</p>
                             <div className="flex gap-2 flex-shrink-0 justify-end">
                               <button onClick={() => setEditingTemplate(null)} className="bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded text-sm">Cancelar</button>
                               <button onClick={handleSaveTemplateEdit} className="bg-success hover:bg-green-700 px-3 py-1 rounded text-sm">Guardar Cambios</button>
                             </div>
                           </div>
                         ) : (
                           <div className="flex items-center justify-center h-full border border-dashed border-border-color rounded-lg bg-background/30 text-text-secondary italic">
                              Selecciona una plantilla para editar o haz clic en "+ Nueva".
                           </div>
                         )}
                    </div>

                  </div>
                </div>

                <div className="p-4 bg-header flex justify-between items-center rounded-b-lg flex-shrink-0"> {/* Footer */}
                   <button onClick={onReset} className="bg-danger hover:bg-danger-hover text-white font-bold py-2 px-4 rounded-lg text-sm" disabled={!!editingTemplate}>
                    Restaurar Predeterminadas
                  </button>
                  <div className="flex gap-4">
                    <button onClick={onClose} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg text-sm" disabled={!!editingTemplate}>
                        Cancelar
                    </button>
                    <button onClick={handleSaveLocal} className="bg-success hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg text-sm" disabled={!!editingTemplate}>
                        Guardar y Cerrar
                    </button>
                  </div>
                </div>
              </div>
            </div>
          );
        };


        // =================================================================================
        // INLINED: components/PreviewModal.tsx
        // =================================================================================
        const PreviewModal = ({ data, template, onClose }) => { // Cannot easily memoize modals
           // Ensure data is an object before proceeding
          if (!data || typeof data !== 'object') {
             console.error("Invalid data provided to PreviewModal:", data);
             // Optionally show an error to the user or close automatically
             // onClose(); // Uncomment to close if data is bad
             return ( // Render a fallback message
                  <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[150] p-4">
                     <div className="bg-surface rounded-lg shadow-xl w-full max-w-lg border border-border-color p-8 text-center">
                         <h3 className="text-xl font-bold text-danger mb-4">Error</h3>
                         <p className="text-text-secondary mb-6">No se pudieron cargar los datos para la vista previa.</p>
                         <button onClick={onClose} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Cerrar</button>
                     </div>
                  </div>
             );
          }

          const bodyContent = template && template.body ? replacePlaceholders(template.body, data) : '<p class="italic text-gray-500">[Selecciona un tipo de carta en el Área 3 para ver la vista previa aquí]</p>';
          const fullBody = `<div style="font-family: sans-serif; font-size: 14px; color: #333;">${bodyContent}${COMMON_EMAIL_BODY}${SIGNATURE}</div>`; // Wrap in basic styles for iframe


          const copyToClipboard = useCallback(() => {
             // Create a temporary element to parse HTML and get text content
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = fullBody; // Use fullBody which includes signature etc.
            // Get text content, trying different properties for browser compatibility
            const textContent = tempDiv.textContent || tempDiv.innerText || "";

            navigator.clipboard.writeText(textContent.trim()) // Trim whitespace
              .then(() => alert('¡Contenido de texto copiado al portapapeles!'))
              .catch(err => {
                   console.error('Failed to copy text content:', err);
                   alert('Falló al copiar el contenido de texto.');
               });
          }, [fullBody]); // Depends on fullBody


          const copyHtmlToClipboard = useCallback(() => {
               try {
                  // Use Clipboard API with HTML type
                  if (navigator.clipboard && window.ClipboardItem) {
                      const blob = new Blob([fullBody], { type: 'text/html' });
                      const item = new ClipboardItem({ 'text/html': blob });
                      navigator.clipboard.write([item])
                         .then(() => alert('¡Contenido HTML copiado al portapapeles!'))
                         .catch(err => {
                              console.error('Failed to copy HTML content using ClipboardItem:', err);
                              // Fallback or specific error message
                              alert('Falló al copiar el contenido HTML (tu navegador podría no soportarlo completamente). Intenta copiar el texto.');
                         });
                  } else {
                       // Fallback for older browsers (might not copy HTML format correctly)
                       console.warn("ClipboardItem API not supported, attempting fallback text copy.");
                       copyToClipboard(); // Fallback to text copy
                       alert("Se copió el texto, pero el formato HTML puede no ser compatible con tu navegador.");
                  }
               } catch (error) {
                   console.error('Error copying HTML:', error);
                   alert('Error inesperado al intentar copiar HTML.');
               }
            }, [fullBody, copyToClipboard]); // Depends on fullBody and copyToClipboard fallback


          return (
            <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[150] p-4"> {/* Increased z-index */}
              <div className="bg-surface rounded-lg shadow-xl w-full max-w-3xl border border-border-color flex flex-col max-h-[90vh]"> {/* Added max-h */}
                <div className="p-4 border-b border-border-color flex justify-between items-center flex-shrink-0"> {/* Header */}
                  <h3 className="text-lg font-bold text-primary truncate">Vista Previa: Orden {data.No_Orden || 'N/A'}</h3>
                   <button onClick={onClose} className="text-text-secondary text-2xl hover:text-text-primary ml-4">&times;</button>
                </div>
                {/* Use iframe to render HTML correctly */}
                <iframe
                  srcDoc={`<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{margin: 1rem;}</style></head><body>${fullBody}</body></html>`} // Add basic HTML structure and margin
                  className="flex-grow overflow-y-auto bg-white border-none" // Use border-none
                  sandbox="allow-same-origin" // Basic sandboxing for security
                  title={`Vista Previa Email Orden ${data.No_Orden || 'N/A'}`}
                />
                <div className="p-4 bg-header flex justify-end gap-4 rounded-b-lg flex-shrink-0"> {/* Footer */}
                   <button onClick={copyHtmlToClipboard} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm" title="Copiar como HTML formateado para pegar en correos">
                     Copiar HTML
                   </button>
                  <button onClick={copyToClipboard} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm" title="Copiar solo el texto sin formato">
                    Copiar Texto
                  </button>
                  <button onClick={onClose} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm">
                    Cerrar
                  </button>
                </div>
              </div>
            </div>
          );
        };


        // =================================================================================
        // INLINED: App.tsx (The main application component)
        // =================================================================================
        const App = () => {
          // Initialize state with empty arrays or appropriate defaults
          const [state, setState] = useState({
            finalData: [],
            trackingData: [],
            archivedData: [],
            portalData: [], // State specifically for Area 1 file input
            pdfData: Array(5).fill({}), // State specifically for Area 2 paste input
            templates: [],
            scriptUrl: null,
            isSetupNeeded: false, // True initially if no URL in localStorage
            isReconfiguring: false, // True if user clicks reconfigure button
            isLoading: true, // True during initial data fetch
            isSaving: false, // True while save operation is in progress
            isTemplateManagerOpen: false,
            previewData: null, // Holds the row data for the preview modal
            notification: null, // { message: string, type: 'success'|'error'|'warning'|'info', timeoutId?: number }
            editsCount: 0, // Counter for unsaved changes in Review and Tracking areas
            onlineStatus: true, // Tracks browser online status
            masterTrackingOrders: new Set(), // Holds all known No_Orden strings (from initial load + saves)
          });

          const [sortConfig, setSortConfig] = useState({
            key: 'No_Orden', // Default sort column
            direction: 'ascending', // Default sort direction
          });

          // --- Notification Management ---
          const hideNotification = useCallback(() => {
              // Use functional update to avoid stale state issues if called rapidly
              setState(prev => ({ ...prev, notification: null }));
          }, []); // Empty dependency array as it doesn't depend on external vars

          const showNotification = useCallback((message, type = 'info', duration = 5000) => {
             // Clear existing notification timeout if any to prevent overlaps
             setState(prev => {
                if (prev.notification?.timeoutId) {
                   clearTimeout(prev.notification.timeoutId);
                }
                const timeoutId = setTimeout(hideNotification, duration);
                return { ...prev, notification: { message, type, timeoutId } };
             });
          }, [hideNotification]); // Depend on hideNotification


          // --- Script URL and Initial Data Loading ---
          const handleSetScriptUrl = useCallback(async (url) => {
              console.log("Attempting to set script URL and fetch initial data...");
             setState(prev => ({ ...prev, isLoading: true, isReconfiguring: false })); // Start loading, close reconfigure modal
             try {
               const data = await fetchData(url); // Fetch initial data from Sheets
               localStorage.setItem('sigweb_scriptUrl', url); // Store URL on success
               setState(prev => ({
                 ...prev,
                 finalData: data.finalData, // Already ensured array by fetchData
                 trackingData: data.trackingData, // Already ensured array by fetchData
                 archivedData: data.archivedData, // Already ensured array by fetchData
                 // Initialize master set with all known orders from backend
                 masterTrackingOrders: new Set(data.masterTrackingOrders.map(String)),
                 scriptUrl: url,
                 isSetupNeeded: false, // Setup is complete
                 isLoading: false, // Loading finished
                 editsCount: 0, // Reset edits on successful load
               }));
               showNotification('¡Conexión exitosa y datos cargados!', 'success');
               console.log("Initial data fetched successfully.");
             } catch (error) {
               console.error("Error setting script URL or fetching data:", error);
               showNotification(
                 `Falló la conexión: ${error.message}. Revisa la URL y permisos del script.`,
                 'error',
                  10000 // Show error longer
               );
               // Keep setup needed true, stop loading, clear URL if it failed
               setState(prev => ({ ...prev, isLoading: false, isSetupNeeded: true, scriptUrl: null }));
               localStorage.removeItem('sigweb_scriptUrl'); // Remove bad URL from storage
               throw error; // Re-throw to prevent modal from closing automatically via handleSave in SetupModal
             }
          }, [showNotification]);


          // --- Effect for Initial Load and Online Status ---
          useEffect(() => {
              console.log("App component mounted. Checking config...");
            const url = localStorage.getItem('sigweb_scriptUrl');
            const loadedTemplates = loadTemplates(); // Load templates from localStorage or defaults
            setState(prev => ({ ...prev, templates: loadedTemplates }));

            if (url) {
                console.log("Found script URL in localStorage:", url);
                handleSetScriptUrl(url).catch(err => {
                    // Catch error here if initial load fails, user is already notified by handleSetScriptUrl
                    console.error("Initial data load failed on mount:", err);
                    // State should already be set to isSetupNeeded: true by handleSetScriptUrl's catch block
                });
            } else {
                console.log("No script URL found. Setup needed.");
                setState(prev => ({ ...prev, isSetupNeeded: true, isLoading: false })); // Need setup, stop loading indicator
            }

            // Online/Offline handling
            const updateOnlineStatus = () => {
                const isOnline = navigator.onLine;
                console.log("Network status changed:", isOnline ? "Online" : "Offline");
                setState(prev => {
                     if (prev.onlineStatus === isOnline) return prev; // Avoid unnecessary state updates
                     if (!isOnline) {
                        showNotification("Estás desconectado. El guardado en la nube está deshabilitado.", "warning", 10000);
                     } else if (prev.onlineStatus === false && isOnline){ // Only show "back online" if previously offline
                         showNotification("Estás conectado de nuevo.", "info");
                     }
                     return { ...prev, onlineStatus: isOnline };
                });
            };


            window.addEventListener('online', updateOnlineStatus);
            window.addEventListener('offline', updateOnlineStatus);
            updateOnlineStatus(); // Initial check

            return () => { // Cleanup listeners on component unmount
                console.log("App component unmounting. Removing listeners.");
                window.removeEventListener('online', updateOnlineStatus);
                window.removeEventListener('offline', updateOnlineStatus);
                 // Clear any pending notification timeouts
                 setState(prev => {
                    if (prev.notification?.timeoutId) {
                       clearTimeout(prev.notification.timeoutId);
                    }
                    return prev; // Return prev state to avoid unnecessary re-render on unmount
                 });
            };
            // Run only on mount and unmount - CAREFUL: handleSetScriptUrl IS a dependency
          }, [handleSetScriptUrl]); // Include handleSetScriptUrl but ensure it's stable via useCallback


          // --- Edit Counter ---
          const incrementEdits = useCallback(() => {
            console.log("Incrementing edits count"); // Debug log
            setState(prev => ({ ...prev, editsCount: prev.editsCount + 1 }));
          },[]); // No dependencies needed


          // --- Save Data ---
          const handleSave = useCallback(async () => {
              console.log("Save button clicked.");
              if (!state.scriptUrl) {
                  showNotification('No se puede guardar. La URL del script no está configurada.', 'error');
                  return;
              }
              if (!state.onlineStatus) {
                  showNotification('No se puede guardar mientras estás desconectado.', 'error');
                  return;
              }

              // Use safe arrays for checks and payload
              const safeFinalData = Array.isArray(state.finalData) ? state.finalData : [];
              const safeTrackingData = Array.isArray(state.trackingData) ? state.trackingData : [];
              const safeArchivedData = Array.isArray(state.archivedData) ? state.archivedData : [];

              // Check if there's anything new (finalData) or edited (editsCount > 0)
              if (safeFinalData.length === 0 && state.editsCount === 0) {
                   showNotification('No hay datos nuevos o modificados para guardar.', 'info');
                   return;
              }

              setState(prev => ({ ...prev, isSaving: true }));
              console.log("Attempting to save data...");

              try {
                  const payload = {
                      action: 'saveData',
                      payload: {
                          finalData: safeFinalData,
                          trackingData: safeTrackingData,
                          archivedData: safeArchivedData,
                      }
                  };
                  await saveData(state.scriptUrl, payload); // Assume success due to no-cors

                  // Update master tracking set LOCALLY with orders from ALL sections just sent
                  const newOrders = new Set(state.masterTrackingOrders); // Start with existing

                  [...safeFinalData, ...safeTrackingData, ...safeArchivedData].forEach(row => {
                      if (row && row.No_Orden) {
                          newOrders.add(String(row.No_Orden).trim());
                      }
                  });

                  showNotification('¡Datos enviados a la nube! (Verifica la hoja "TOTAL" para confirmar)', 'success');
                  console.log("Save request sent successfully. Updated masterTrackingOrders locally.");

                  // Clear local finalData and reset edits count after sending
                  setState(prev => ({
                      ...prev,
                      editsCount: 0, // Reset edits since changes were saved
                      masterTrackingOrders: newOrders, // Use the fully updated Set
                      finalData: [] // Clear the review area data after successful send
                  }));
              } catch (error) {
                  console.error("Error during save:", error);
                  showNotification(`Falló el guardado de datos: ${error.message}`, 'error');
              } finally {
                  setState(prev => ({ ...prev, isSaving: false }));
                  console.log("Save process finished.");
              }
          }, [state.scriptUrl, state.onlineStatus, state.finalData, state.trackingData, state.archivedData, state.masterTrackingOrders, state.editsCount, showNotification]); // Dependencies


          // --- Process Area 1 Data (Excel Upload) ---
          const processPortalData = useCallback(() => {
              console.log("Processing portal data...");
              const currentPortalData = Array.isArray(state.portalData) ? state.portalData.filter(row => row && Object.values(row).some(val => String(val).trim() !== '')) : []; // Filter empty rows from input

              if(currentPortalData.length === 0){
                   showNotification("No hay datos válidos cargados desde el archivo para procesar.", "warning");
                   setState(prev => ({ ...prev, portalData: [] })); // Clear the input area state
                   return;
              }

              // Filter out rows that already exist based on masterTrackingOrders Set
              const newRows = currentPortalData.filter(row => {
                   const orderKey = row && row.No_Orden ? String(row.No_Orden).trim() : null;
                   return orderKey && !state.masterTrackingOrders.has(orderKey);
              });

              const duplicates = currentPortalData.length - newRows.length;
              console.log(`Found ${newRows.length} new rows, skipped ${duplicates} duplicates.`);

              const processedData = newRows
                  .filter(row => row && row.No_Orden && String(row.No_Orden).trim()) // Redundant check, but safe
                  .map((row) => ({
                      ...row, // Keep all data, ensure all PORTAL_HEADERS were added during file parse
                      Nombre: capitalizeWords(row.Nombre || ''), // Apply specific formatting
                      EPS: (row.EPS || '').toUpperCase(),
                      // Default potentially missing PDF fields needed for Area 3
                      Descripcion_PDF: row.Descripcion_PDF || '(pendiente)',
                      Justificacion_PDF: row.Justificacion_PDF || '(pendiente)',
                      Fundamento_Legal_PDF: row.Fundamento_Legal_PDF || '(pendiente)',
                      // Ensure Tipo_Carta and Radicado_Comp exist, even if empty
                      Tipo_Carta: row.Tipo_Carta || '',
                      Radicado_Comp: row.Radicado_Comp || '',
                  }));

              // Append NEW processed rows to existing finalData, clear portalData input
              setState(prev => ({
                    ...prev,
                    // Append new processed rows to whatever is currently in finalData (Area 3)
                    finalData: [...(Array.isArray(prev.finalData) ? prev.finalData : []), ...processedData],
                    portalData: [] // Clear Area 1 input
              }));


              let message = `${processedData.length} nuevas filas procesadas y añadidas al Área 3.`;
              if (duplicates > 0) {
                  message += ` ${duplicates} fila(s) ya existentes fueron omitidas.`;
              }
              showNotification(message, processedData.length > 0 ? 'success' : 'info'); // Use 'info' if only duplicates found

          }, [state.portalData, state.masterTrackingOrders, state.finalData, showNotification]); // Added state.finalData dependency


           // --- Process Area 2 Data (PDF Paste) ---
           const mergePdfData = useCallback(() => {
               console.log("Merging PDF data...");
               const currentPdfData = Array.isArray(state.pdfData) ? state.pdfData.filter(row => row && Object.values(row).some(val => String(val).trim() !== '')) : []; // Filter empty rows

               if(currentPdfData.length === 0){
                    showNotification("No hay datos válidos en el Área 2 para combinar.", "warning");
                     setState(prev => ({ ...prev, pdfData: Array(5).fill({}) })); // Reset paste area
                    return;
               }

             const pdfMap = new Map();
             currentPdfData
               .filter(row => row && row['Archivo (No. Orden)'] && String(row['Archivo (No. Orden)']).trim())
               .forEach(row => {
                  const key = String(row['Archivo (No. Orden)']).trim();
                  if(key){
                    pdfMap.set(key, {
                      Descripcion_PDF: String(row['Descripción'] || '').trim(),
                      Justificacion_PDF: String(row['Justificación'] || '').trim(),
                      Fundamento_Legal_PDF: String(row['Fundamento Legal'] || '').trim(),
                    });
                  }
               });

             console.log(`Created PDF map with ${pdfMap.size} entries.`);

             // Ensure finalData is an array
             const currentFinalData = Array.isArray(state.finalData) ? state.finalData : [];
             let mergeCount = 0;
             const mergedData = currentFinalData.map(finalRow => {
               const orderKey = finalRow && finalRow.No_Orden ? String(finalRow.No_Orden).trim() : null;
               if (orderKey) {
                  const pdfMatch = pdfMap.get(orderKey);
                  // Merge ONLY if PDF data is not empty/placeholder and different from current
                  if (pdfMatch && (
                      (pdfMatch.Descripcion_PDF && pdfMatch.Descripcion_PDF !== '(pendiente)' && pdfMatch.Descripcion_PDF !== finalRow.Descripcion_PDF) ||
                      (pdfMatch.Justificacion_PDF && pdfMatch.Justificacion_PDF !== '(pendiente)' && pdfMatch.Justificacion_PDF !== finalRow.Justificacion_PDF) ||
                      (pdfMatch.Fundamento_Legal_PDF && pdfMatch.Fundamento_Legal_PDF !== '(pendiente)' && pdfMatch.Fundamento_Legal_PDF !== finalRow.Fundamento_Legal_PDF)
                     ))
                  {
                      mergeCount++;
                      // Create a new object with merged data, prioritizing non-empty PDF data
                      return {
                          ...finalRow,
                          Descripcion_PDF: (pdfMatch.Descripcion_PDF && pdfMatch.Descripcion_PDF !== '(pendiente)') ? pdfMatch.Descripcion_PDF : finalRow.Descripcion_PDF,
                          Justificacion_PDF: (pdfMatch.Justificacion_PDF && pdfMatch.Justificacion_PDF !== '(pendiente)') ? pdfMatch.Justificacion_PDF : finalRow.Justificacion_PDF,
                          Fundamento_Legal_PDF: (pdfMatch.Fundamento_Legal_PDF && pdfMatch.Fundamento_Legal_PDF !== '(pendiente)') ? pdfMatch.Fundamento_Legal_PDF : finalRow.Fundamento_Legal_PDF,
                      };
                  }
               }
               return finalRow; // Return original row if no match or no update needed
             });

             // Only update state and increment edits if merges actually happened
             if (mergeCount > 0) {
                 setState(prev => ({
                     ...prev,
                     finalData: mergedData,
                     pdfData: Array(5).fill({}), // Reset paste area
                     editsCount: prev.editsCount + mergeCount // Increment edits for merged rows
                 }));
                 showNotification(`${mergeCount} fila(s) actualizadas con datos del PDF en el Área 3.`, 'success');
                 console.log(`Merged PDF data into ${mergeCount} rows.`);
             } else {
                 setState(prev => ({ ...prev, pdfData: Array(5).fill({}) })); // Still reset paste area
                 showNotification('No se encontraron coincidencias o datos nuevos para combinar desde el PDF.', 'info');
                 console.log('No PDF data merged.');
             }


           }, [state.pdfData, state.finalData, showNotification]); // Dependencies


          // --- Update Row in Area 3 (Review Area) ---
          const updateFinalDataRow = useCallback((noOrden, partialUpdate) => {
              const keyToUpdate = String(noOrden);
             setState(prev => {
                const currentFinalData = Array.isArray(prev.finalData) ? prev.finalData : [];
                let rowUpdated = false;
                const newData = currentFinalData.map(row => {
                  if (row && String(row.No_Orden) === keyToUpdate) {
                      // Check if any value in partialUpdate is actually different
                      const isChanged = Object.keys(partialUpdate).some(updateKey => String(row[updateKey] ?? '') !== String(partialUpdate[updateKey] ?? ''));
                      if (isChanged) {
                         rowUpdated = true;
                         return { ...row, ...partialUpdate }; // Create new object only if changed
                      }
                  }
                  return row; // Return original object reference if no change
                });

                // Only update state and increment edits if a row was actually changed
                if (rowUpdated) {
                   console.log(`Updating finalData row ${keyToUpdate}`);
                   return { ...prev, finalData: newData, editsCount: prev.editsCount + 1 };
                } else {
                   return prev; // No change, return previous state
                }
             });
          }, []); // Removed incrementEdits dependency as it's handled internally


          // --- Clear Area 3 Data ---
          const handleClearReviewData = useCallback(() => {
            // Check if there's data to clear
            if (!Array.isArray(state.finalData) || state.finalData.length === 0) {
                 showNotification("La tabla de Revisión ya está vacía.", "info");
                 return;
            }
            if (window.confirm("¿Estás seguro de que quieres limpiar toda la tabla de Revisión (Área 3)?\nLos datos no guardados se perderán.\n\nEsto NO afecta los datos en Google Sheets.")) {
                setState(prev => ({ ...prev, finalData: [] })); // Only clear local state
                showNotification("Tabla de Revisión limpiada.", "info");
                // Note: editsCount is NOT reset here, as clearing is an action itself that might need saving if other areas were edited. It resets on successful save.
            }
          }, [showNotification, state.finalData]);


          // --- Send to Area 4 (Tracking) ---
          const handleSendToTracking = useCallback((selectedOrderKeys) => { // Receive array of string keys
             console.log("Attempting to send items to tracking:", selectedOrderKeys);
            const currentFinalData = Array.isArray(state.finalData) ? state.finalData : [];
            const safeTemplates = Array.isArray(state.templates) ? state.templates : [];

            const itemsToSend = currentFinalData
              .filter(row => row && selectedOrderKeys.includes(String(row.No_Orden)))
              .filter(row => { // Filter based on criteria
                const template = safeTemplates.find((t) => t.id === row.Tipo_Carta);
                const hasComplementariedadTemplate = template && template.name.toUpperCase().includes('COMPLEMENTARIEDAD');
                const hasRadicado = row.Radicado_Comp && String(row.Radicado_Comp).trim() !== '';
                if (hasComplementariedadTemplate && !hasRadicado) {
                   console.warn(`Row ${row.No_Orden} has Complementariedad template but no Radicado. Skipping.`);
                   showNotification(`El caso ${row.No_Orden} tiene plantilla de Complementariedad pero falta el número de Radicado. No se enviará a seguimiento.`, 'warning');
                }
                return hasComplementariedadTemplate && hasRadicado; // Must meet both
              });


            if (itemsToSend.length === 0) {
              showNotification("No hay ítems seleccionados que cumplan los criterios (Tipo 'COMPLEMENTARIEDAD' con 'Radicado') para enviar a seguimiento.", 'warning');
              return;
            }
             console.log(`${itemsToSend.length} items meet criteria for tracking.`);

            setState(prev => {
               const currentTrackingData = Array.isArray(prev.trackingData) ? prev.trackingData : [];
               let newTrackingData = [...currentTrackingData];
               let newFinalData = Array.isArray(prev.finalData) ? [...prev.finalData] : [];
               let addedCount = 0;
               let updatedCount = 0;
               let skippedCount = 0;
               const itemsActuallyMovedKeys = new Set(); // Track keys of items successfully moved/updated

               itemsToSend.forEach(item => {
                 const itemOrderKey = String(item.No_Orden);
                 const existingIndex = newTrackingData.findIndex(t => t && String(t.No_Orden) === itemOrderKey);

                 if (existingIndex !== -1) { // Item already exists in tracking
                    // Optional: Confirm update only if Radicado is different
                    if (newTrackingData[existingIndex].Radicado !== item.Radicado_Comp) {
                       if (window.confirm(`El caso ${itemOrderKey} ya está en seguimiento activo con Radicado "${newTrackingData[existingIndex].Radicado}".\n¿Actualizar a "${item.Radicado_Comp}"?`)) {
                         // Create a new object for the updated tracking item
                         newTrackingData[existingIndex] = { ...newTrackingData[existingIndex], Radicado: item.Radicado_Comp };
                         updatedCount++;
                         itemsActuallyMovedKeys.add(itemOrderKey);
                       } else {
                          skippedCount++; // User chose not to update
                       }
                    } else {
                         skippedCount++; // Already exists with same Radicado
                         console.log(`Skipping ${itemOrderKey}, already in tracking with same Radicado.`);
                    }
                 } else { // Item is new to tracking
                   newTrackingData.push({
                     Fecha_Ing: item.Fecha_Neg || new Date().toISOString().slice(0,10),
                     No_Orden: item.No_Orden,
                     Nombre: item.Nombre || '',
                     EPS: item.EPS || '',
                     Radicado: item.Radicado_Comp,
                     Estado: TRACKING_STATUSES[0], // Default state
                     Notas: '',
                   });
                   addedCount++;
                   itemsActuallyMovedKeys.add(itemOrderKey);
                 }
               });

               // Remove ONLY the successfully moved/updated items from finalData
               newFinalData = newFinalData.filter(f => !(f && itemsActuallyMovedKeys.has(String(f.No_Orden))));

               let summaryMessage = "";
               if (addedCount > 0) summaryMessage += `${addedCount} nuevo(s) enviado(s) a Seguimiento. `;
               if (updatedCount > 0) summaryMessage += `${updatedCount} actualizado(s) en Seguimiento. `;
               if (skippedCount > 0) summaryMessage += `${skippedCount} omitido(s) (ya existían o no se actualizó).`;

               if(addedCount > 0 || updatedCount > 0){
                   showNotification(summaryMessage.trim(), 'success');
                   // Increment edits count for the items moved/updated
                   return { ...prev, trackingData: newTrackingData, finalData: newFinalData, editsCount: prev.editsCount + addedCount + updatedCount };
               } else {
                   showNotification(summaryMessage.trim() || "No se realizaron cambios en Seguimiento.", 'info');
                   return { ...prev, finalData: newFinalData }; // Still update finalData if skips occurred but no moves/updates
               }
            });

          }, [state.templates, state.finalData, state.trackingData, showNotification]); // Dependencies


          // --- Export Area 3 Data for Mail Merge ---
          const exportForMailMerge = useCallback((dataToExport) => {
              const currentData = Array.isArray(dataToExport) ? dataToExport : [];
              if (currentData.length === 0) {
                  showNotification("No hay datos en revisión (Área 3) para exportar.", "warning");
                  return;
              }
              console.log(`Exporting ${currentData.length} rows for mail merge.`);
              try {
                  const safeTemplates = Array.isArray(state.templates) ? state.templates : [];
                  const exportable = currentData.map(row => {
                      const templateName = safeTemplates.find(t => t.id === row?.Tipo_Carta)?.name || "NO_SELECCIONADA";
                      // Select and rename columns for the export
                      return {
                          "Fecha": row?.Fecha_Neg || '',
                          "Orden": row?.No_Orden || '',
                          "Cedula": row?.No_Cedula || '',
                          "Nombre": row?.Nombre || '',
                          "EPS": row?.EPS || '',
                          "Programa": row?.Programa || '',
                          "Email": row?.Email || '',
                          "Motivo": row?.Motivo_Negacion || '',
                          "Desc_PDF": row?.Descripcion_PDF || '',
                          "Just_PDF": row?.Justificacion_PDF || '',
                          "Fund_PDF": row?.Fundamento_Legal_PDF || '',
                          "Tipo_Carta_Seleccionada": templateName,
                          "Radicado_Complementariedad": row?.Radicado_Comp || ''
                          // Add any other columns needed for mail merge here
                      };
                  });
                  const ws = XLSX.utils.json_to_sheet(exportable);
                  const wb = XLSX.utils.book_new();
                  XLSX.utils.book_append_sheet(wb, ws, "DatosParaEnvio");
                  XLSX.writeFile(wb, `Sigweb_Procesado_MailMerge_${new Date().toISOString().slice(0, 10)}.xlsx`);
                  showNotification("Archivo para Envío Masivo generado.", "success");
              } catch (error) {
                   console.error("Error exporting for mail merge:", error);
                   showNotification("Error al generar el archivo para envío masivo.", "error");
              }
          }, [state.templates, showNotification]); // Dependencies


          // --- Update Row in Area 4 (Tracking/Archived) ---
          const updateTrackingData = useCallback((index, updatedRow, isArchived) => {
              if (typeof index !== 'number' || index < 0) {
                 console.error("Invalid index provided to updateTrackingData:", index);
                 return;
              }
            const dataKey = isArchived ? 'archivedData' : 'trackingData';
            setState(prev => {
               const currentData = Array.isArray(prev[dataKey]) ? prev[dataKey] : [];
               if(index < currentData.length) {
                   // Avoid mutation: create a new array with the updated item
                   const newData = [...currentData];
                   newData[index] = updatedRow; // Place the already updated row object
                   console.log(`Updated item at index ${index} in ${dataKey}`);
                   // Increment edits count only if it's not already saving (prevents double counting during save process)
                   const newEditsCount = prev.isSaving ? prev.editsCount : prev.editsCount + 1;
                   return { ...prev, [dataKey]: newData, editsCount: newEditsCount };
               } else {
                   console.error(`Index ${index} out of bounds for ${dataKey}`);
                   return prev;
               }
            });
          }, []); // No external dependencies, relies on functional update


          // --- Archive/Unarchive Items in Area 4 ---
          const archiveItems = useCallback((indicesToMove, fromArchived) => {
              if (!Array.isArray(indicesToMove) || indicesToMove.some(isNaN) || indicesToMove.length === 0){
                 console.warn("Invalid or empty indices provided to archiveItems:", indicesToMove);
                 return;
              }
              console.log(`${fromArchived ? 'Unarchiving' : 'Archiving'} indices:`, indicesToMove);
            const sourceKey = fromArchived ? 'archivedData' : 'trackingData';
            const targetKey = fromArchived ? 'trackingData' : 'archivedData';

            setState(prev => {
               const sourceData = Array.isArray(prev[sourceKey]) ? prev[sourceKey] : [];
               const targetData = Array.isArray(prev[targetKey]) ? [...prev[targetKey]] : []; // Start target as copy

               const itemsToMove = [];
               const remainingSourceIndices = new Set(); // Keep track of indices *not* moved

               sourceData.forEach((item, index) => {
                   if (!indicesToMove.includes(index)) {
                       remainingSourceIndices.add(index);
                   }
               });

               // Build the new source array based on remaining indices
               const newSourceData = Array.from(remainingSourceIndices).map(index => sourceData[index]);

               // Find the items to move based on the provided indices
               indicesToMove.forEach(index => {
                  if(index >= 0 && index < sourceData.length && sourceData[index]){
                     itemsToMove.push(sourceData[index]); // Get the actual items to move
                  }
               });


               if (itemsToMove.length === 0) {
                    console.warn("No valid items found for the given indices to move.");
                    return prev; // No changes if no valid items were found
               }

               console.log(`Moving ${itemsToMove.length} items from ${sourceKey} to ${targetKey}.`);

               // Append moved items to the target array
               const newTargetData = [...targetData, ...itemsToMove];


               return {
                 ...prev,
                 [sourceKey]: newSourceData, // Updated source (items removed)
                 [targetKey]: newTargetData, // Updated target (items added)
                 // Increment edits count only if not currently saving
                 editsCount: prev.isSaving ? prev.editsCount : prev.editsCount + itemsToMove.length
               };
            });
          }, []); // No external dependencies


          // --- Template Management Callbacks ---
          const handleSaveTemplates = useCallback((newTemplates) => {
            const templatesToSave = Array.isArray(newTemplates) ? newTemplates : defaultTemplates;
            setState(prev => ({ ...prev, templates: templatesToSave }));
            saveTemplates(templatesToSave);
            showNotification('Plantillas de correo guardadas localmente.', 'success');
          }, [showNotification]);

          const handleResetTemplates = useCallback(() => {
            if (window.confirm('¿Estás seguro de que quieres restaurar las plantillas predeterminadas?\n\nTodas las plantillas personalizadas se perderán.')) {
              handleSaveTemplates([...defaultTemplates]); // Save a copy of defaults
            }
          }, [handleSaveTemplates]);

          // --- Memoized Sorted Data for Review Area ---
          const sortedFinalData = useMemo(() => {
            let sortableItems = Array.isArray(state.finalData) ? [...state.finalData] : [];
            if (sortConfig.key) {
                sortableItems.sort((a, b) => {
                    if (!a || !b) return 0;
                    const aVal = a[sortConfig.key] ?? ''; // Use nullish coalescing for cleaner default
                    const bVal = b[sortConfig.key] ?? '';
                    const comparison = String(aVal).localeCompare(String(bVal), undefined, { numeric: true, sensitivity: 'base' });
                    return sortConfig.direction === 'ascending' ? comparison : -comparison;
                });
            }
            return sortableItems;
          }, [state.finalData, sortConfig]);

          // --- Close Setup Modal Callback ---
           const handleCloseSetupModal = useCallback(() => {
                // Only allow closing if it's NOT the initial setup OR if a URL is now present
                if (!state.isSetupNeeded || state.scriptUrl) {
                    setState(prev => ({ ...prev, isReconfiguring: false }));
                } else {
                    alert("Debes configurar y verificar la URL del script para poder usar la aplicación.");
                }
           }, [state.isSetupNeeded, state.scriptUrl]);


          // ================== Render Logic ==================

          if (state.isLoading && !state.isSetupNeeded) { // Show loader only if not in initial setup and still loading
            return <div className="fixed inset-0 bg-background/90 flex items-center justify-center z-[300]"><Spinner /> <span className="ml-4 text-xl">Cargando Datos Iniciales...</span></div>;
          }

          // Show Setup Modal if needed (initial setup OR reconfiguring)
          if (state.isSetupNeeded || state.isReconfiguring) {
            return <SetupModal
                onSave={handleSetScriptUrl} // This now handles closing the modal on success
                onClose={handleCloseSetupModal} // Special close handler
                initialUrl={state.scriptUrl || ''}
             />;
          }

          // Main App Render (only if setup is complete and not loading)
          return (
            <div className="p-4 sm:p-8 bg-background min-h-screen">
              {/* Notification Area */}
              {state.notification && (
                <Notification
                  message={state.notification.message}
                  type={state.notification.type}
                  onClose={hideNotification} // Pass hideNotification to allow manual close
                />
              )}
              {/* Offline Indicator */}
              {!state.onlineStatus && (
                   <div className="bg-yellow-600 text-black text-center p-2 fixed top-0 left-0 w-full z-[100] shadow"> {/* Black text */}
                    ⚠ Estás desconectado. El guardado en la nube está deshabilitado.
                   </div>
              )}

              <main className={`max-w-screen-2xl mx-auto bg-surface p-4 sm:p-6 rounded-xl border border-border-color space-y-8 ${!state.onlineStatus ? 'pt-12 sm:pt-16' : ''}`}> {/* Adjusted padding */}
                <Header
                    onSave={handleSave}
                    onManageTemplates={() => setState(prev => ({ ...prev, isTemplateManagerOpen: true }))}
                    onReconfigure={() => setState(prev => ({ ...prev, isReconfiguring: true }))}
                />
                <Dashboard
                  reviewCount={Array.isArray(state.finalData) ? state.finalData.length : 0}
                  trackingCount={Array.isArray(state.trackingData) ? state.trackingData.length : 0}
                  archivedCount={Array.isArray(state.archivedData) ? state.archivedData.length : 0}
                  editsCount={state.editsCount} // Display number of unsaved edits
                />
                <div className="text-right">
                       <button
                           onClick={() => exportDetailedReport(state.finalData, state.trackingData, state.archivedData)}
                           className="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm" // Changed color
                       >
                           Descargar Reporte Detallado Excel
                       </button>
                </div>

                <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                  <DataInputArea
                    id="portal-area"
                    title="Área 1: Cargar Excel del Portal"
                    headers={PORTAL_HEADERS}
                    data={state.portalData}
                    onDataChange={(newData) => setState(prev => ({ ...prev, portalData: newData }))}
                    onProcess={processPortalData}
                    processButtonText="Procesar y Añadir a Revisión"
                    inputType="file"
                  />
                  <DataInputArea
                    id="pdf-area"
                    title="Área 2: Pegar Datos del Extractor PDF"
                    headers={PDF_HEADERS}
                    data={state.pdfData}
                    onDataChange={(newData) => setState(prev => ({ ...prev, pdfData: newData }))}
                    onProcess={mergePdfData}
                    processButtonText="Combinar PDF con Revisión"
                    inputType="paste"
                  />
                </div>
                <ReviewArea
                  data={sortedFinalData} // Use memoized sorted data from state.finalData
                  templates={state.templates}
                  updateRow={updateFinalDataRow} // Callback to update state.finalData
                  incrementEdits={incrementEdits} // Callback to update state.editsCount (now called internally by updateFinalDataRow)
                  onSendToTracking={handleSendToTracking} // Callback to move items from finalData to trackingData
                  onPreview={(row) => setState(prev => ({ ...prev, previewData: row }))} // Set state for preview modal
                  onExportForMailMerge={exportForMailMerge} // Callback to export finalData subset
                  onClearReviewData={handleClearReviewData} // Callback to clear finalData
                  sortConfig={sortConfig} // Current sort state
                  setSortConfig={setSortConfig} // Callback to update sort state
                />
                <TrackingArea
                  trackingData={state.trackingData}
                  archivedData={state.archivedData}
                  updateTrackingData={updateTrackingData} // Callback to update tracking/archived state
                  archiveItems={archiveItems} // Callback to move items between tracking/archived
                />

                {/* Saving Indicator */}
                {state.isSaving && <div className="fixed inset-0 bg-background/80 flex items-center justify-center z-[300]"><Spinner /> <span className="ml-4 text-xl">Guardando Datos en la Nube...</span></div>}
              </main>

              {/* Template Manager Modal */}
              {state.isTemplateManagerOpen && (
                <TemplateManagerModal
                  templates={state.templates}
                  onClose={() => setState(prev => ({...prev, isTemplateManagerOpen: false}))}
                  onSave={handleSaveTemplates} // Saves to state and localStorage
                  onReset={handleResetTemplates} // Resets state and localStorage to defaults
                />
              )}
               {/* Preview Modal */}
              {state.previewData && (
                <PreviewModal
                  data={state.previewData}
                  template={Array.isArray(state.templates) ? state.templates.find(t => t.id === state.previewData?.Tipo_Carta) : null}
                  onClose={() => setState(prev => ({...prev, previewData: null}))}
                />
              )}
            </div>
          );
        };

        // =================================================================================
        // INLINED: index.tsx (Render the application)
        // =================================================================================
        const rootElement = document.getElementById('root');
        if (!rootElement) {
          console.error("Fatal Error: Root element 'root' not found in HTML.");
          document.body.innerHTML = '<div style="color: red; padding: 20px; font-family: sans-serif; background-color: #333;">Error Crítico: No se encontró el elemento raíz de la aplicación (#root). Verifica el HTML.</div>';
        } else {
            try {
               const root = ReactDOM.createRoot(rootElement);
               // Render without StrictMode for now to avoid potential double-render issues with effects if not needed
               // root.render(<React.StrictMode><App /></React.StrictMode>);
               root.render(<App />);
            } catch(error) {
                console.error("Error rendering React application:", error);
                 rootElement.innerHTML = `<div style="color: orange; padding: 20px; font-family: sans-serif; background-color: #333;">Error Crítico al iniciar la aplicación React:<pre>${error.stack || error.message}</pre></div>`;
            }
        }

    </script>
</body>
</html>
