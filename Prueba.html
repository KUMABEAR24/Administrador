<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <meta http-equiv="Content-Security-Policy" 
        content="default-src 'self' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://unpkg.com https://esm.sh; script-src 'self' 'unsafe-eval' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://unpkg.com https://esm.sh;">

  <title>GESTION NEGACIONES EJE CAFETERO</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script>
     // Tailwind config...
  </script>
  <script type="importmap">
     // Import map...
  </script>
</head>
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GESTION NEGACIONES EJE CAFETERO</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script>
      // Tailwind CSS Configuration
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'primary': '#4e9fef',
              'background': '#1e1e1e',
              'surface': '#2d2d2d',
              'text-primary': '#d4d4d4',
              'text-secondary': '#a0a0a0',
              'border-color': '#444',
              'header': '#3a3a3a',
              'highlight': '#252526',
              'warning': '#6e550c',
              'archive': '#3a3a3a',
              'success': '#28a745',
              'danger': '#a02d2d',
              'danger-hover': '#c0392b',
              'btn-primary': '#0e639c',
              'btn-primary-hover': '#1a73e8',
            },
            animation: {
              'flash-success': 'flash-success 1s ease-out',
            },
            keyframes: {
              'flash-success': {
                'from': { backgroundColor: '#28a745' },
                'to': { backgroundColor: 'transparent' },
              }
            }
          }
        }
      }
    </script>
    
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client"
      }
    }
    </script>
</head>
    
<body class="bg-background text-text-primary">
    <div id="root"></div>

    <script type="text/babel" data-presets="react" data-type="module">
        import React, { useState, useEffect, useCallback, useMemo } from 'react';
        import ReactDOM from 'react-dom/client';

        // =================================================================================
        // INLINED: constants.ts
        // =================================================================================
        const PORTAL_HEADERS = [
            "Fecha_Neg", "Sucursal", "No_Orden", "No_Cedula", "Nombre", "Entidad_Ejecutora",
            "Motivo_Negacion", "Usuario_Emitio", "Auditor", "Observacion_Auditor", "Observacion_Ejecutivo",
            "Programa", "Plan", "Antiguedad", "EPS", "Telefono", "Celular", "Direccion", "Email", "Edad",
            "Tipo_Usuario", "Llamada", "Complementariedad", "Notificacion", "Gestion_Negacion", "Alternativa",
            "Observacion_Alternativa", "Monto", "Nit_Prestador", "Fecha_Complementariedad", "Tiempo_de_Gestion", "Regional"
        ];

        const PDF_HEADERS = [
          "Archivo (No. Orden)", "Descripción", "Justificación", "Fundamento Legal", "Código"
        ];

        const TRACKING_STATUSES = ['Pendiente', 'En Gestión', 'Finalizado'];
        
        const COMMON_EMAIL_BODY = `<br><br><b>Si tiene alguna duda puede contactarse por medio de los canales que tenemos disponibles para usted:</b><br>· Nuestra línea nacional 018000931666. O con nuestras líneas locales: Cali (602) 489 0073, Bogotá (601) 743 5485, Medellín (604) 604 4507, Barranquilla (605) 385 3165, Bucaramanga (607) 697 3350, Cartagena (605) 693 9853, Tuluá (602) 235 9483, Valledupar (605)588 5699, Pereira (606) 340 2635.<br>· WhatsApp: 317-224-07-94<br><br>Gracias por su Atención.`;
        const SIGNATURE = `<br><br>Cordialmente,<br><br><b>Juan Ricardo Morales Agudelo</b><br>Ejecutivo De Atención Integral<br>Coomeva Medicina Prepagada<br>Cra. 13 No.11-12 Centro Médico Circunvalar<br>Coomeva Medicina Prepagada Pereira, Risaralda<br><br><i>Este correo es generado automáticamente, por favor no responda este mensaje.</i>`;

        const defaultTemplates = [
            { id: 'tpl_neg_gen', name: 'PLANTILLA NEGACION GENERAL', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar información acerca del servicio {{Motivo_Negacion}} que en esta oportunidad no está aprobado debido a que corresponde a EXCLUSIÓN ({{Descripcion_PDF}}), ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>El servicio negado anteriormente; debe tramitarlo a través su EPS asignada. Adjuntamos soporte de la carta de negación.` },
            { id: 'tpl_neg_pert', name: 'PLANTILLA NO PERTINENCIA Y TEMAS ESTETICOS', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar información acerca del servicio {{Motivo_Negacion}} que en esta oportunidad No está aprobado debido a que corresponde a NO PERTINENCIA ({{Descripcion_PDF}}), ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>` },
            { id: 'tpl_comp_coinc', name: 'COMPLEMENTARIEDAD RED COINCIDENTE', body: `Apreciado Usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y el de su familia. Por medio de este correo queremos brindar información acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no fue aprobado, debido a que ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>Sin embargo, está en gestión a través de su EPS ({{EPS}}) con el número de radicado ({{Radicado_Comp}}), puede realizar seguimiento mediante la oficina virtual de la EPS ({{Oficina_Virtual_EPS}}).<br><br>Adicional estaremos haciendo seguimiento al radicado y una vez se encuentre gestionado por la EPS, le notificaremos por medio de correo electrónico.` },
            { id: 'tpl_comp_no_coinc', name: 'COMPLEMENTARIEDAD RED NO COINCIDENTE', body: `Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar información acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no está aprobado, debido a que corresponde a ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>El prestador actual solicitado, no tiene convenio con la EPS, por lo que los costos adicionales del servicio o insumo estarán a cargo del paciente. Sin embargo; se radica la solicitud ante su EPS con el número ({{Radicado_Comp}}) por favor realizar seguimiento mediante la oficina virtual de la EPS ({{Oficina_Virtual_EPS}}).` },
            { id: 'tpl_comp_ayudas', name: 'COMPLEMENTARIEDAD AYUDAS DIAGNOSTICAS', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar información acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no está aprobado debido a que corresponde a ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>Sin embargo, se encuentra en gestión a través de su EPS con el número de radicado ({{Radicado_Comp}}), por favor realizar seguimiento mediante la oficina virtual. ({{Oficina_Virtual_EPS}}).` },
        ];


        // =================================================================================
        // INLINED: services/utilityService.ts
        // =================================================================================
        const capitalizeWords = (str) => {
          if (!str) return '';
          return str.toLowerCase().replace(/\b\w/g, char => char.toUpperCase());
        };

        const processPastedData = (pastedText, headers) => {
          return pastedText
            .trim()
            .split(/\r?\n/)
            .map(rowText => {
              const cells = rowText.split('\t');
              const rowObject = {};
              headers.forEach((header, index) => {
                if (cells[index]) {
                  rowObject[header] = cells[index].trim();
                }
              });
              return rowObject;
            });
        };

        const replacePlaceholders = (templateBody, data) => {
          const getOficinaVirtual = (eps) => {
            const e = (eps || "").toUpperCase();
            if (e.includes("NUEVA EPS")) return `<a href='https://portal.nuevaeps.com.co/Portal/home.jspx' target='_blank' rel='noopener noreferrer'>NUEVA EPS</a>`;
            if (e.includes("SALUD TOTAL")) return `<a href='https://saludtotal.com.co/' target='_blank' rel='noopener noreferrer'>SALUD TOTAL</a>`;
            return eps;
          };

          const fullData = { ...data, Oficina_Virtual_EPS: getOficinaVirtual(data.EPS) };

          return templateBody.replace(/\{\{(\w+)\}\}/g, (match, key) => {
            // Ensure data[key] exists and is not null/undefined before returning
            return fullData[key] !== null && fullData[key] !== undefined ? fullData[key] : match;
          });
        };

        const exportDetailedReport = (finalData, trackingData, archivedData) => {
          try {
            const masterDataMap = new Map();

            [...finalData, ...trackingData, ...archivedData].forEach(row => {
              if (row && row.No_Orden) { // Added check for row existence
                const key = String(row.No_Orden).trim(); // Ensure key is a string
                if (key) { // Ensure key is not empty
                    const existing = masterDataMap.get(key) || {};
                    masterDataMap.set(key, { ...existing, ...row });
                }
              }
            });
            
            const masterData = Array.from(masterDataMap.values());

            if (masterData.length === 0) {
              alert("No hay datos consolidados para exportar.");
              return;
            }

            const wb = XLSX.utils.book_new();
            
            // Add sheets only if data exists
            if (finalData.length > 0) {
              const ws1 = XLSX.utils.json_to_sheet(finalData);
              XLSX.utils.book_append_sheet(wb, ws1, "Casos en Revisión");
            }
            
            if (trackingData.length > 0) {
              const ws2 = XLSX.utils.json_to_sheet(trackingData);
              XLSX.utils.book_append_sheet(wb, ws2, "Seguimiento Activo");
            }

            if (archivedData.length > 0) {
              const ws3 = XLSX.utils.json_to_sheet(archivedData);
              XLSX.utils.book_append_sheet(wb, ws3, "Seguimiento Archivado");
            }
            
            // Always add Maestro Consolidado if masterData exists
            const ws4 = XLSX.utils.json_to_sheet(masterData);
            XLSX.utils.book_append_sheet(wb, ws4, "Maestro Consolidado");

            XLSX.writeFile(wb, `Sigweb_Reporte_Detallado_${new Date().toISOString().slice(0, 10)}.xlsx`);
          } catch (error) {
            console.error("Falló la exportación del reporte Excel:", error);
            alert("Ocurrió un error al generar el reporte detallado.");
          }
        };

        // =================================================================================
        // INLINED: services/templateService.ts
        // =================================================================================
        const TEMPLATE_STORAGE_KEY = 'sigweb_emailTemplates';

        const loadTemplates = () => {
          try {
            const storedTemplates = localStorage.getItem(TEMPLATE_STORAGE_KEY);
            if (storedTemplates) {
              const parsed = JSON.parse(storedTemplates);
              if (Array.isArray(parsed) && parsed.length > 0 && parsed[0].id && parsed[0].name) {
                return parsed;
              }
            }
          } catch (error) {
            console.error("Falló la carga de plantillas desde localStorage, se usarán las predeterminadas.", error);
            localStorage.removeItem(TEMPLATE_STORAGE_KEY);
          }
          return defaultTemplates;
        };

        const saveTemplates = (templates) => {
          try {
            localStorage.setItem(TEMPLATE_STORAGE_KEY, JSON.stringify(templates));
          } catch (error) {
            console.error("Falló el guardado de plantillas en localStorage", error);
          }
        };


        // =================================================================================
        // INLINED: services/googleSheetService.ts
        // =================================================================================
        const fetchData = async (url) => {
            console.log("Fetching data from:", url); // Debug log
            const response = await fetch(`${url}?action=getData`);
            console.log("Fetch response status:", response.status); // Debug log
            if (!response.ok) {
                const errorText = await response.text();
                console.error("Network response was not ok:", errorText); // Debug log
                throw new Error(`La respuesta de la red no fue correcta: ${response.statusText} - ${errorText}`);
            }
            const data = await response.json();
            console.log("Fetched data:", data); // Debug log
            return {
                finalData: data.finalData || [],
                trackingData: data.trackingData || [],
                archivedData: data.archivedData || [],
                masterTrackingOrders: data.masterTrackingOrders || [],
            };
        };

        const saveData = async (url, requestBody) => {
            console.log("Saving data to:", url); // Debug log
            console.log("Save request body:", JSON.stringify(requestBody)); // Debug log
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    mode: 'no-cors', 
                    headers: {
                        'Content-Type': 'text/plain', // Required for no-cors with Apps Script text payload
                    },
                    body: JSON.stringify(requestBody), // Send the whole object including action and payload
                });
                // In no-cors mode, we CANNOT read the response status or body. 
                // We assume success if no network error is thrown.
                console.log("Save request sent (no-cors). Assuming success."); // Debug log
                return { status: 'success', message: 'Datos enviados al servidor (no-cors).' };
            } catch (error) {
                console.error("Error during save fetch:", error); // Debug log
                throw error; // Re-throw the error to be caught by handleSave
            }
        };


        // =================================================================================
        // INLINED: components/Spinner.tsx
        // =================================================================================
        const Spinner = () => {
          return (
            <div
              className="inline-block h-8 w-8 animate-spin rounded-full border-4 border-solid border-primary border-r-transparent align-[-0.125em] motion-reduce:animate-[spin_1.5s_linear_infinite]"
              role="status"
            >
              <span className="!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]">
                Cargando...
              </span>
            </div>
          );
        };


        // =================================================================================
        // INLINED: components/Notification.tsx
        // =================================================================================
        const Notification = ({ message, type, onClose }) => {
          const typeClasses = {
            success: 'bg-green-600',
            error: 'bg-red-600',
            warning: 'bg-yellow-500',
            info: 'bg-blue-600',
          };
          // Automatically close after a delay if onClose is provided
          useEffect(() => {
            if (onClose) {
              const timer = setTimeout(() => {
                onClose();
              }, 5000); // Default 5 seconds
              return () => clearTimeout(timer);
            }
          }, [onClose]);

          return (
            <div className={`fixed top-5 right-5 z-[100] p-4 rounded-lg shadow-lg text-white ${typeClasses[type]} flex items-center gap-4`}>
              <span>{message}</span>
              {onClose && <button onClick={onClose} className="text-xl font-bold">&times;</button>}
            </div>
          );
        };

        // =================================================================================
        // INLINED: components/Header.tsx
        // =================================================================================
        const Header = ({ onSave, onManageTemplates, onReconfigure }) => {
          return (
            <header className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 pb-4 border-b border-border-color">
              <div>
                <h1 className="text-3xl font-bold text-white">
                  GESTION NEGACIONES EJE CAFETERO
                </h1>
                <p className="text-text-secondary">Sistema Integrado de Gestión de Flujos de Trabajo</p>
              </div>
              <div className="flex flex-wrap gap-2">
                <button onClick={onManageTemplates} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors">
                  Gestionar Plantillas
                </button>
                <button onClick={onReconfigure} className="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg transition-colors flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0L8.21 5.15a1.5 1.5 0 01-1.25.82l-2.09.28c-1.68.23-2.34 2.26-1.09 3.42l1.52 1.48a1.5 1.5 0 01-.42 2.1l-1.83 1.25c-1.38.94-.92 3.01.7 3.42l2.05.51a1.5 1.5 0 011.1.98l.8 2.07c.43 1.12 2.29 1.12 2.72 0l.8-2.07a1.5 1.5 0 011.1-.98l2.05-.51c1.62-.4 2.08-2.48.7-3.42l-1.83-1.25a1.5 1.5 0 01-.42-2.1l1.52-1.48c1.25-1.16.59-3.19-1.09-3.42L13 5.97a1.5 1.5 0 01-1.25-.82l-.3-1.98zM10 13a3 3 0 100-6 3 3 0 000 6z" clipRule="evenodd" />
                    </svg>
                    Reconfigurar Conexión
                </button>
                <button onClick={onSave} className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M5.5 16.5a2.5 2.5 0 01-5 0V4.414a1.5 1.5 0 01.44-1.06L4.354.439A1.5 1.5 0 015.414 0H12.5a2.5 2.5 0 012.5 2.5v2" />
                        <path d="M5.5 16.5h8a2.5 2.5 0 002.5-2.5V8.5h-13v5.5a2.5 2.5 0 002.5 2.5z" />
                        <path d="M10.5 10a.5.5 0 01.5-.5h2a.5.5 0 010 1h-2a.5.5 0 01-.5-.5z" />
                    </svg>
                    Guardar en la Nube
                </button>
              </div>
            </header>
          );
        };
        

        // =================================================================================
        // INLINED: components/Dashboard.tsx
        // =================================================================================
        const DashboardCard = ({ title, value, icon }) => (
          <div className="bg-surface p-4 rounded-lg border border-border-color flex items-center">
            <div className="text-3xl text-primary mr-4">{icon}</div>
            <div>
              <h4 className="text-sm font-semibold text-text-secondary uppercase tracking-wider">{title}</h4>
              <p className="text-2xl font-bold text-text-primary">{value}</p>
            </div>
          </div>
        );

        const Dashboard = ({ reviewCount, trackingCount, archivedCount, editsCount }) => (
          <section id="dashboard" className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
            <DashboardCard title="Casos en Revisión" value={reviewCount} icon={'📋'} />
            <DashboardCard title="Seguimiento Activo" value={trackingCount} icon={'⏳'} />
            <DashboardCard title="Casos Archivados" value={archivedCount} icon={'🗄️'} />
            <DashboardCard title="Ediciones en Sesión" value={editsCount} icon={'✏️'} />
          </section>
        );


        // =================================================================================
        // INLINED: components/DataInputArea.tsx
        // =================================================================================
        function DataInputArea({
          id,
          title,
          headers,
          data,
          onDataChange,
          onProcess,
          processButtonText = "Procesar Datos",
          inputType = "paste", // "paste" or "file"
        }) {
          
          const handlePaste = useCallback((e) => {
            e.preventDefault();
            const pastedText = e.clipboardData.getData('text/plain');
            const newRows = processPastedData(pastedText, headers);

            // Ensure data is always an array before filtering
            const currentData = Array.isArray(data) ? data : [];
            const updatedData = [...currentData.filter(row => Object.values(row).some(val => val)), ...newRows];
            
            // Add empty rows only if it's the paste input type
            if (inputType === 'paste') {
                const emptyRowCount = updatedData.filter(row => !Object.values(row).some(val => val)).length;
                if (emptyRowCount < 5) {
                    for (let i = 0; i < (5 - emptyRowCount); i++) {
                        updatedData.push({});
                    }
                }
            }

            onDataChange(updatedData);
          }, [data, headers, onDataChange, inputType]);

          const handleCellChange = (rowIndex, header, value) => {
             // Ensure data is always an array
            const currentData = Array.isArray(data) ? data : [];
            const newData = [...currentData];
            // Ensure the row exists before trying to update it
            if(newData[rowIndex]){
                newData[rowIndex] = { ...newData[rowIndex], [header]: value };
            } else {
                 // Optionally handle cases where rowIndex might be out of bounds, though less likely with current logic
                 console.warn(`Attempted to edit non-existent row at index ${rowIndex}`);
                 return; // Prevent further processing if row doesn't exist
            }
            
            // Add empty rows only if it's the paste input type
             if (inputType === 'paste') {
                const emptyRowCount = newData.filter(row => !Object.values(row).some(val => val)).length;
                if (emptyRowCount < 5) {
                    newData.push({});
                }
            }

            onDataChange(newData);
          };
          
          const handleFileChange = (e) => {
              const file = e.target.files[0];
              if (!file) return;

              const reader = new FileReader();
              reader.onload = (event) => {
                  try {
                      const fileData = new Uint8Array(event.target.result);
                      const workbook = XLSX.read(fileData, { type: 'array', cellDates: true });
                      const sheetName = workbook.SheetNames[0];
                      const worksheet = workbook.Sheets[sheetName];
                      // Use header: 1 to get header row, raw: false for formatted values, defval: '' for empty cells
                      const json_data = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: false, defval: '' });

                      if (json_data.length < 2) {
                          alert("El archivo Excel parece estar vacío o no tiene encabezados.");
                          return;
                      }

                      const excelHeaders = json_data[0].map(h => String(h).trim()); // Get headers from the first row
                      const jsonDataObjects = XLSX.utils.sheet_to_json(worksheet, { raw: false, defval: '' }); // Convert rest to objects

                      const normalizeHeaders = (d) => {
                           // Keep your existing keyMap for normalization
                          const keyMap = {
                              'Fecha Neg.': 'Fecha_Neg', 'No. Orden': 'No_Orden', 'No. Cédula': 'No_Cedula',
                              'Entidad Ejecutora': 'Entidad_Ejecutora', 'Motivo Negación': 'Motivo_Negacion',
                              'Usuario Emitió': 'Usuario_Emitio', 'Observación Auditor': 'Observacion_Auditor',
                              'Observación Ejecutivo': 'Observacion_Ejecutivo', 'Antigüedad': 'Antiguedad',
                              'Teléfono': 'Telefono', 'Dirección': 'Direccion', 'Tipo Usuario': 'Tipo_Usuario',
                              'Notificación': 'Notificacion', 'Gestión': 'Gestion_Negacion',
                              'Observación Alternativa': 'Observacion_Alternativa', 'Nit Prestador': 'Nit_Prestador',
                              'Fecha Complementariedad': 'Fecha_Complementariedad', 'Tiempo de Gestion': 'Tiempo_de_Gestion'
                          };
                           // Map Excel dates (assuming they are serial numbers or specific string formats)
                          const excelDateToJSDate = (serialOrString) => {
                              if (typeof serialOrString === 'number') {
                                  // Handle Excel serial date number
                                  const utc_days = Math.floor(serialOrString - 25569);
                                  const utc_value = utc_days * 86400;                                     
                                  const date_info = new Date(utc_value * 1000);
                                  // Adjust for timezone offset
                                  const fractional_day = serialOrString - Math.floor(serialOrString) + 0.0000001;
                                  let total_seconds = Math.floor(86400 * fractional_day);
                                  const seconds = total_seconds % 60;
                                  total_seconds -= seconds;
                                  const hours = Math.floor(total_seconds / (60 * 60));
                                  const minutes = Math.floor(total_seconds / 60) % 60;
                                  
                                  // Create date object adjusted for local timezone
                                  return new Date(date_info.getFullYear(), date_info.getMonth(), date_info.getDate(), hours, minutes, seconds);

                              } else if (typeof serialOrString === 'string') {
                                  // Attempt to parse common string date formats if necessary
                                  // Example: Adjust if your Excel dates are like 'DD/MM/YYYY'
                                  // const parts = serialOrString.match(/(\d{1,2})[/|-](\d{1,2})[/|-](\d{4})/);
                                  // if (parts) return new Date(parts[3], parts[2] - 1, parts[1]);
                                  
                                  // For ISO-like strings or directly parsable formats
                                  const parsedDate = new Date(serialOrString);
                                  if (!isNaN(parsedDate)) return parsedDate;
                              }
                              return null; // Return null if conversion fails
                          };

                          return d.map(row => {
                              const newRow = {};
                              for (const key in row) {
                                  const trimmedKey = String(key).trim(); // Ensure key is trimmed string
                                  const newKey = keyMap[trimmedKey] || trimmedKey.replace(/ /g, '_'); // Normalize or replace spaces
                                  
                                  // Check if the key indicates a date column
                                  const isDateColumn = ['Fecha_Neg', 'Fecha_Complementariedad'].includes(newKey); // Add other date columns if needed

                                  if (isDateColumn) {
                                      const jsDate = excelDateToJSDate(row[key]);
                                      if (jsDate && !isNaN(jsDate)) {
                                          // Format as YYYY-MM-DD
                                          newRow[newKey] = jsDate.toISOString().slice(0, 10);
                                      } else {
                                          newRow[newKey] = ''; // Assign empty string if date conversion failed
                                          console.warn(`Could not parse date for column ${newKey}:`, row[key]);
                                      }
                                  } else {
                                      // Assign value directly for non-date columns, ensuring it's a string
                                      newRow[newKey] = row[key] !== null && row[key] !== undefined ? String(row[key]) : '';
                                  }
                              }
                              // Ensure all PORTAL_HEADERS are present, even if empty
                              PORTAL_HEADERS.forEach(header => {
                                  if (!(header in newRow)) {
                                      newRow[header] = '';
                                  }
                              });
                              return newRow;
                          });
                      };

                      const normalizedData = normalizeHeaders(jsonDataObjects);
                      onDataChange(normalizedData);
                      e.target.value = null; 
                  } catch (error) {
                      console.error("Error processing Excel file:", error);
                      alert("Hubo un error al procesar el archivo Excel. Asegúrate de que el formato y las columnas son correctos.");
                      onDataChange([]); // Clear data on error
                  }
              };
              reader.onerror = (error) => {
                   console.error("Error reading file:", error);
                   alert("Hubo un error al leer el archivo.");
                   onDataChange([]); // Clear data on error
              };
              reader.readAsArrayBuffer(file);
          };

          const clearTable = () => {
            onDataChange(inputType === 'paste' ? Array(5).fill({}) : []);
          }
          
          // Ensure 'data' is always an array for rendering
          const renderData = Array.isArray(data) ? data : (inputType === 'paste' ? Array(5).fill({}) : []);


          return (
            <section id={id} className="space-y-4">
              <h2 className="text-2xl font-bold text-primary border-b border-border-color pb-2">{title}</h2>
              
              {inputType === 'file' && (
                 <div className="flex items-center gap-4">
                    <label htmlFor={`${id}-file-upload`} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors cursor-pointer">
                        Subir Archivo Excel
                    </label>
                    <input 
                        id={`${id}-file-upload`}
                        type="file"
                        className="hidden"
                        accept=".xlsx, .xls, .csv" // Added CSV support
                        onChange={handleFileChange}
                    />
                    <span className="text-text-secondary">{renderData.length > 0 ? `${renderData.length} fila(s) cargada(s)` : 'Ningún archivo seleccionado'}</span>
                </div>
              )}

              <div className="table-container max-h-72 overflow-auto border border-border-color rounded-lg">
                <table className="w-full text-sm text-left text-text-secondary">
                  <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                    <tr>
                      {headers.map(header => (
                        <th key={header} scope="col" className="px-4 py-3 whitespace-nowrap">{header.replace(/_/g, ' ')}</th>
                      ))}
                    </tr>
                  </thead>
                   {/* Add check to ensure renderData is an array before mapping */}
                  <tbody onPaste={inputType === 'paste' ? handlePaste : undefined}>
                    {Array.isArray(renderData) && renderData.map((row, rowIndex) => (
                      <tr key={rowIndex} className="border-b border-border-color hover:bg-highlight">
                        {headers.map(header => (
                          <td
                            key={`${rowIndex}-${header}`}
                            className="px-4 py-2 border-r border-border-color focus:bg-primary focus:text-black outline-none"
                            contentEditable={inputType === 'paste'}
                            onBlur={inputType === 'paste' ? (e) => handleCellChange(rowIndex, header, e.currentTarget.innerText) : undefined}
                            suppressContentEditableWarning={true}
                          >
                            {/* Ensure row is an object and header exists before accessing */}
                            {(typeof row === 'object' && row !== null && row[header] !== undefined) ? String(row[header]) : ''}
                          </td>
                        ))}
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
              <div className="flex gap-4">
                <button 
                    onClick={onProcess} 
                    disabled={renderData.length === 0 || (inputType === 'paste' && renderData.every(row => !Object.values(row).some(val => val)))} // Disable if no data
                    className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed"
                 >
                  {processButtonText}
                </button>
                <button onClick={clearTable} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                  Limpiar Tabla
                </button>
              </div>
            </section>
          );
        }

        // =================================================================================
        // INLINED: components/ReviewArea.tsx
        // =================================================================================
        const ReviewArea = ({
          data,
          templates,
          updateRow,
          incrementEdits,
          onSendToTracking,
          onPreview,
          onExportForMailMerge,
          onClearReviewData,
          sortConfig,
          setSortConfig,
        }) => {
          const [selectedRows, setSelectedRows] = useState(new Set());
          const [filter, setFilter] = useState('');
          
          const REVIEW_HEADERS = [
              { key: 'Fecha_Neg', label: 'Fecha Neg.' },
              { key: 'No_Orden', label: 'No. Orden' },
              { key: 'No_Cedula', label: 'No. Cédula' },
              { key: 'Nombre', label: 'Nombre' },
              { key: 'EPS', label: 'EPS' },
              { key: 'Programa', label: 'Programa', compact: true },
              { key: 'Motivo_Negacion', label: 'Motivo Neg.', compact: true },
              { key: 'Descripcion_PDF', label: 'Descripción', compact: true },
              { key: 'Justificacion_PDF', label: 'Justificación', compact: true },
              { key: 'Fundamento_Legal_PDF', label: 'Fund. Legal', compact: true },
          ];
          
          // Ensure 'data' is always an array before filtering/sorting
          const currentData = Array.isArray(data) ? data : [];

          const filteredData = useMemo(() => {
            if (!filter) return currentData;
            const lowercasedFilter = filter.toLowerCase();
            return currentData.filter(row =>
              row && typeof row === 'object' && // Ensure row is a valid object
              Object.values(row).some(value =>
                String(value).toLowerCase().includes(lowercasedFilter)
              )
            );
          }, [currentData, filter]); // Depend on currentData

          const handleSelectRow = (noOrden) => {
            const key = String(noOrden); // Ensure key is string for Set consistency
            const newSelection = new Set(selectedRows);
            if (newSelection.has(key)) {
              newSelection.delete(key);
            } else {
              newSelection.add(key);
            }
            setSelectedRows(newSelection);
          };

          const handleSelectAll = (e) => {
            if (e.target.checked) {
              const allOrderNumbers = filteredData
                .map(row => row ? String(row.No_Orden) : null) // Get No_Orden as string, handle potential null rows
                .filter(Boolean); // Remove nulls/undefined
              setSelectedRows(new Set(allOrderNumbers));
            } else {
              setSelectedRows(new Set());
            }
          };

          const handleCellBlur = (noOrden, key, value) => {
             // Find row using string comparison for No_Orden
            const originalRow = currentData.find(r => r && String(r.No_Orden) === String(noOrden));
            if (originalRow && originalRow[key] !== value) {
              updateRow(noOrden, { [key]: value }); // Pass original noOrden (might be number or string)
              incrementEdits();
            }
          };
          
          const handleSelectChange = (noOrden, value) => {
            const changes = { Tipo_Carta: value };
            const template = templates.find(t => t.id === value);
            if (!template || !template.name.toUpperCase().includes('COMPLEMENTARIEDAD')) {
                changes.Radicado_Comp = '';
            }
             // Pass original noOrden (might be number or string)
            updateRow(noOrden, changes);
          };

          const requestSort = (key) => {
            let direction = 'ascending';
            if (sortConfig.key === key && sortConfig.direction === 'ascending') {
                direction = 'descending';
            }
            setSortConfig({ key, direction });
          };
          
          const getSortIndicator = (key) => {
            if (sortConfig.key !== key) return null;
            return sortConfig.direction === 'ascending' ? ' ▲' : ' ▼';
          };

          return (
            <section id="area3" className="space-y-4">
              <h2 className="text-2xl font-bold text-primary border-b border-border-color pb-2">Área 3: Revisión Final y Exportación</h2>
              <div className="action-bar bg-highlight p-4 rounded-lg flex flex-wrap items-center gap-4">
                <input
                  type="text"
                  placeholder="Buscar en tabla de revisión..."
                  className="bg-surface border border-border-color rounded-md px-3 py-2 text-text-primary placeholder-text-secondary w-full sm:w-auto"
                  value={filter}
                  onChange={(e) => setFilter(e.target.value)}
                />
                <span className="text-text-primary">{selectedRows.size} fila(s) seleccionada(s)</span>
              </div>

              <div className="table-container max-h-[700px] overflow-auto border border-border-color rounded-lg">
                <table className="w-full text-sm text-left text-text-secondary table-auto">
                  <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                    <tr>
                      <th className="px-4 py-3"><input type="checkbox" onChange={handleSelectAll} checked={filteredData.length > 0 && selectedRows.size === filteredData.length} /></th>
                      <th className="px-4 py-3">👁️</th>
                       {REVIEW_HEADERS.map(({ key, label, compact }) => (
                        <th key={key} onClick={() => requestSort(key)} className={`px-4 py-3 cursor-pointer ${compact ? 'max-w-[150px]' : ''}`}>
                            {label}{getSortIndicator(key)}
                        </th>
                      ))}
                      <th className="px-4 py-3">Tipo de Carta</th>
                    </tr>
                  </thead>
                  <tbody>
                   {/* Check filteredData exists and is an array */}
                    {Array.isArray(filteredData) && filteredData.map((row) => {
                       // Add a check to ensure 'row' is a valid object before proceeding
                      if (!row || typeof row !== 'object' || !row.No_Orden) {
                        console.warn("Skipping invalid row in ReviewArea render:", row);
                        return null; // Skip rendering this row
                      }
                      
                      const noOrdenKey = String(row.No_Orden); // Use string key for Set lookup
                      const template = templates.find(t => t.id === row.Tipo_Carta);
                      const isComplementariedad = template && template.name.toUpperCase().includes('COMPLEMENTARIEDAD');
                      const requiresRadicado = isComplementariedad;
                      
                      return (
                         // Use original No_Orden (might be number or string) for handlers, use string key for Set
                        <tr key={noOrdenKey} className={`border-b border-border-color hover:bg-highlight ${isComplementariedad ? 'bg-indigo-900/50' : ''}`}>
                          <td className="px-4 py-2"><input type="checkbox" checked={selectedRows.has(noOrdenKey)} onChange={() => handleSelectRow(noOrdenKey)} /></td>
                          <td className="px-4 py-2 text-lg cursor-pointer" onClick={() => onPreview(row)}>👁️</td>
                          {REVIEW_HEADERS.map(({ key, compact }) => (
                            <td key={key} 
                                className={`px-4 py-2 border-r border-border-color focus:bg-primary focus:text-black outline-none ${compact ? 'max-w-[150px] overflow-hidden text-ellipsis whitespace-nowrap' : ''}`}
                                contentEditable
                                onBlur={(e) => handleCellBlur(row.No_Orden, key, e.currentTarget.innerText)} // Pass original No_Orden
                                suppressContentEditableWarning={true}
                            >
                                {row[key] !== null && row[key] !== undefined ? String(row[key]) : ''} 
                            </td>
                          ))}
                          <td className="px-4 py-2">
                            <div className="flex flex-col gap-1">
                              <select 
                                value={row.Tipo_Carta || ''}
                                onChange={(e) => handleSelectChange(row.No_Orden, e.target.value)} // Pass original No_Orden
                                className="bg-surface border border-border-color rounded-md px-2 py-1 text-text-primary w-full"
                              >
                                <option value="">-- Seleccionar --</option>
                                {templates.map(t => <option key={t.id} value={t.id}>{t.name}</option>)}
                              </select>
                              {requiresRadicado && (
                                <input
                                  type="text"
                                  placeholder="Radicado..."
                                  value={row.Radicado_Comp || ''}
                                  onChange={(e) => updateRow(row.No_Orden, { Radicado_Comp: e.target.value })} // Pass original No_Orden
                                  className="bg-surface border border-border-color rounded-md px-2 py-1 text-text-primary w-full mt-1"
                                />
                              )}
                            </div>
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
              <div className="flex flex-wrap gap-4">
                <button 
                    onClick={() => onSendToTracking(Array.from(selectedRows))} // Pass the Set values (which are string keys)
                    disabled={selectedRows.size === 0} // Disable if no rows selected
                    className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed"
                >
                    Enviar a Seguimiento
                </button>
                 <button 
                    onClick={() => onExportForMailMerge(currentData)} // Export based on currentData
                    disabled={currentData.length === 0} // Disable if no data
                    className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed"
                >
                    Exportar para Envío Masivo
                </button>
                <button 
                    onClick={onClearReviewData}
                    className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors"
                >
                    Limpiar Tabla de Revisión
                </button>
              </div>
            </section>
          );
        };
        

        // =================================================================================
        // INLINED: components/TrackingArea.tsx
        // =================================================================================
        const TrackingTable = ({ data, isArchived, onUpdate, onArchive, filter }) => {
            
          const [selectedRows, setSelectedRows] = useState(new Set());
          
          const statusClasses = {
            'Pendiente': 'bg-yellow-600/20',
            'En Gestión': 'bg-blue-600/20',
            'Finalizado': 'bg-green-600/20',
          };
          
          // Ensure data is always an array
          const currentData = Array.isArray(data) ? data : [];

          const filteredData = useMemo(() => {
            if (!filter) return currentData;
            const lowercasedFilter = filter.toLowerCase();
            return currentData.filter(row =>
              row && typeof row === 'object' && // Ensure row is valid
              Object.values(row).some(value =>
                String(value).toLowerCase().includes(lowercasedFilter)
              )
            );
          }, [currentData, filter]); // Depend on currentData

          const handleSelectRow = (index) => {
            const newSelection = new Set(selectedRows);
            if (newSelection.has(index)) {
              newSelection.delete(index);
            } else {
              newSelection.add(index);
            }
            setSelectedRows(newSelection);
          };
          
          const handleSelectAll = (e) => {
            if (e.target.checked) {
               // Use indices of the currently filtered data
              setSelectedRows(new Set(filteredData.map((row) => currentData.indexOf(row)).filter(index => index !== -1)));
            } else {
              setSelectedRows(new Set());
            }
          };
          
          const handleBulkArchive = () => {
            if (selectedRows.size > 0) {
              onArchive(Array.from(selectedRows)); // Pass indices
              setSelectedRows(new Set());
            }
          };

          return (
            <div className="space-y-4">
              <div className="flex justify-end">
                   {selectedRows.size > 0 && (
                       <button
                           onClick={handleBulkArchive}
                           className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors"
                       >
                           {isArchived ? `Restaurar ${selectedRows.size} Seleccionados` : `Archivar ${selectedRows.size} Seleccionados`}
                       </button>
                   )}
              </div>
              <div className="table-container max-h-[400px] overflow-auto border border-border-color rounded-lg">
                <table className="w-full text-sm text-left text-text-secondary">
                  <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                    <tr>
                      <th className="px-4 py-3"><input type="checkbox" onChange={handleSelectAll} checked={filteredData.length > 0 && selectedRows.size === filteredData.length}/></th>
                      <th className="px-4 py-3">Fecha Ing.</th>
                      <th className="px-4 py-3">No. Orden</th>
                      <th className="px-4 py-3">Nombre</th>
                      <th className="px-4 py-3">EPS</th>
                      <th className="px-4 py-3">Radicado</th>
                      <th className="px-4 py-3">Estado</th>
                      <th className="px-4 py-3">Notas</th>
                      <th className="px-4 py-3">Acción</th>
                    </tr>
                  </thead>
                  <tbody>
                    {Array.isArray(filteredData) && filteredData.map((row) => {
                      // Find the original index in the full 'currentData' array
                       const originalIndex = currentData.findIndex(item => item === row);
                       // Skip if row is invalid or not found (shouldn't happen with findIndex but good practice)
                       if (!row || typeof row !== 'object' || originalIndex === -1) return null; 

                      return (
                      <tr key={originalIndex} className={`border-b border-border-color hover:bg-highlight transition-colors ${isArchived ? 'bg-archive/50 text-text-secondary' : statusClasses[row.Estado] || ''}`}>
                        <td className="px-4 py-2"><input type="checkbox" checked={selectedRows.has(originalIndex)} onChange={() => handleSelectRow(originalIndex)} /></td>
                        <td className="px-4 py-2">{row.Fecha_Ing || ''}</td>
                        <td className="px-4 py-2">{row.No_Orden || ''}</td>
                        <td className="px-4 py-2">{row.Nombre || ''}</td>
                        <td className="px-4 py-2">{row.EPS || ''}</td>
                        <td className="px-4 py-2">{row.Radicado || ''}</td>
                        <td className="px-4 py-2">
                          <select
                            value={row.Estado || TRACKING_STATUSES[0]} // Default to first status if undefined
                            onChange={e => onUpdate(originalIndex, { ...row, Estado: e.target.value })}
                            className="bg-surface border border-border-color rounded-md px-2 py-1 text-text-primary"
                          >
                            {TRACKING_STATUSES.map(s => <option key={s} value={s}>{s}</option>)}
                          </select>
                        </td>
                         {/* Ensure innerText exists before updating state */}
                        <td 
                            className="px-4 py-2 outline-none focus:bg-primary focus:text-black" 
                            contentEditable 
                            onBlur={e => {
                                const newNotes = e.currentTarget.innerText;
                                if(row.Notas !== newNotes){ // Only update if changed
                                    onUpdate(originalIndex, { ...row, Notas: newNotes });
                                }
                            }} 
                            suppressContentEditableWarning={true}
                         >
                             {row.Notas || ''}
                         </td>
                        <td className="px-4 py-2 text-lg cursor-pointer" onClick={() => onArchive([originalIndex])}>{isArchived ? '♻️' : '🗄️'}</td>
                      </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </div>
          );
        };

        const TrackingArea = ({ trackingData, archivedData, updateTrackingData, archiveItems }) => {
          const [showArchived, setShowArchived] = useState(false);
          const [filter, setFilter] = useState('');
           // Ensure data props are arrays
          const currentTrackingData = Array.isArray(trackingData) ? trackingData : [];
          const currentArchivedData = Array.isArray(archivedData) ? archivedData : [];


          return (
            <section id="area4" className="space-y-4">
              <h2 className="text-2xl font-bold text-primary border-b border-border-color pb-2">Área 4: Seguimiento</h2>
              <div className="action-bar bg-highlight p-4 rounded-lg flex flex-wrap items-center gap-4">
                <input
                  type="text"
                  placeholder="Buscar en seguimiento..."
                  className="bg-surface border border-border-color rounded-md px-3 py-2 text-text-primary placeholder-text-secondary w-full sm:w-auto"
                  value={filter}
                  onChange={e => setFilter(e.target.value)}
                />
                <button onClick={() => setShowArchived(!showArchived)} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">
                  {showArchived ? 'Ocultar' : 'Mostrar'} Archivados ({currentArchivedData.length})
                </button>
              </div>

              <h3 className="text-xl font-semibold text-white">Casos Activos ({currentTrackingData.length})</h3>
              <TrackingTable
                data={currentTrackingData} // Pass guaranteed array
                isArchived={false}
                onUpdate={(index, row) => updateTrackingData(index, row, false)}
                onArchive={(indices) => archiveItems(indices, false)}
                filter={filter}
              />

              {showArchived && (
                <div className="mt-8">
                  <h3 className="text-xl font-semibold text-white">Casos Archivados ({currentArchivedData.length})</h3>
                  <TrackingTable
                    data={currentArchivedData} // Pass guaranteed array
                    isArchived={true}
                    onUpdate={(index, row) => updateTrackingData(index, row, true)}
                    onArchive={(indices) => archiveItems(indices, true)}
                    filter={filter}
                  />
                </div>
              )}
            </section>
          );
        };

        // =================================================================================
        // INLINED: components/SetupModal.tsx
        // =================================================================================
        const SetupModal = ({ onSave, onClose, initialUrl = '' }) => {
          const [url, setUrl] = useState(initialUrl);
          const [isVerifying, setIsVerifying] = useState(false);

          const handleSave = async () => {
            if (!url || !url.startsWith('https://script.google.com/macros/s/')) { // Added check for empty url
                alert("Por favor, introduce una URL válida de Google Apps Script.");
                return;
            }
            setIsVerifying(true);
            // Wrap onSave in try/catch to handle potential errors during verification
             try {
                await onSave(url);
                // If onSave completes without error, verification is assumed successful
            } catch (error) {
                // Error handling is likely done within onSave/handleSetScriptUrl already
                console.error("Verification failed:", error); 
            } finally {
                setIsVerifying(false); // Ensure verifying state is reset even if error occurs
            }
          };

          return (
            <div className="fixed inset-0 bg-background bg-opacity-90 flex justify-center items-center z-[200] p-4"> {/* Increased z-index */}
              <div className="bg-surface rounded-lg shadow-xl w-full max-w-lg border border-border-color p-8 space-y-6">
                <div className="text-center">
                    <h2 className="text-2xl font-bold text-primary">Configuración de Conexión</h2>
                    <p className="text-text-secondary mt-2">
                        Proporciona la URL de Google Apps Script implementada como aplicación web.
                    </p>
                </div>
                <div>
                    <label htmlFor="script-url" className="block text-sm font-medium text-text-primary mb-1">
                        URL del Script
                    </label>
                    <input
                        id="script-url"
                        type="url"
                        value={url}
                        onChange={(e) => setUrl(e.target.value)}
                        placeholder="https://script.google.com/macros/s/..."
                        className="w-full bg-background border border-border-color rounded-md px-3 py-2 text-text-primary placeholder-text-secondary focus:ring-primary focus:border-primary"
                    />
                </div>
                <div className="flex justify-end gap-4">
                    <button
                        onClick={onClose}
                        disabled={isVerifying} // Disable cancel while verifying
                        className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed"
                    >
                        Cancelar
                    </button>
                    <button
                        onClick={handleSave}
                        disabled={isVerifying || !url} // Disable if verifying or url is empty
                        className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed"
                    >
                        {isVerifying ? <Spinner /> : 'Guardar y Verificar'} {/* Show spinner */}
                    </button>
                </div>
              </div>
            </div>
          );
        };

        // =================================================================================
        // INLINED: components/TemplateManagerModal.tsx
        // =================================================================================
        const TemplateManagerModal = ({ templates, onClose, onSave, onReset }) => {
          const [currentTemplates, setCurrentTemplates] = useState(() => Array.isArray(templates) ? templates : []); // Ensure initial state is array
          const [editingTemplate, setEditingTemplate] = useState(null);

          const handleSave = () => {
            onSave(currentTemplates);
            onClose();
          };

          const handleAddNew = () => {
            setEditingTemplate({ id: `tpl_${Date.now()}`, name: '', body: '' });
          };
          
          const handleEdit = (template) => {
            setEditingTemplate({ ...template }); // Create a copy for editing
          };

          const handleDelete = (idToDelete) => {
            if (window.confirm('¿Estás seguro de que quieres eliminar esta plantilla?')) {
              setCurrentTemplates(current => current.filter(t => t.id !== idToDelete)); // Use functional update
            }
          };
          
          const handleSaveTemplateEdit = () => {
            if (!editingTemplate || !editingTemplate.name || !editingTemplate.body) {
              alert('El nombre y el cuerpo de la plantilla no pueden estar vacíos.');
              return;
            }

            setCurrentTemplates(current => {
                const existingIndex = current.findIndex(t => t.id === editingTemplate.id);
                if (existingIndex > -1) {
                    // Update existing
                    const updated = [...current];
                    updated[existingIndex] = editingTemplate;
                    return updated;
                } else {
                    // Add new
                    return [...current, editingTemplate];
                }
            });
            setEditingTemplate(null); // Close editor
          };
          
          // Ensure currentTemplates is always an array for rendering
          const renderTemplates = Array.isArray(currentTemplates) ? currentTemplates : [];


          return (
            <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[150] p-4"> {/* Increased z-index */}
              <div className="bg-surface rounded-lg shadow-xl w-full max-w-4xl border border-border-color flex flex-col max-h-[90vh]">
                <div className="p-6 border-b border-border-color flex justify-between items-center">
                  <h3 className="text-xl font-bold text-primary">Gestionar Plantillas de Correo</h3>
                  <button onClick={onClose} className="text-text-secondary text-2xl hover:text-text-primary">&times;</button>
                </div>
                
                <div className="p-6 overflow-y-auto space-y-6 flex-grow"> {/* Added flex-grow */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6 h-full"> {/* Added h-full */}
                    <div className="flex flex-col"> {/* Added flex container */}
                      <h4 className="text-lg font-semibold mb-2">Plantillas Actuales</h4>
                      <ul className="space-y-2 border border-border-color rounded-lg p-2 overflow-y-auto flex-grow"> {/* Added flex-grow */}
                         {/* Check renderTemplates is array before mapping */}
                        {Array.isArray(renderTemplates) && renderTemplates.map(template => (
                          <li key={template.id} className="flex justify-between items-center p-2 bg-highlight rounded">
                            <span className="text-text-primary truncate" title={template.name}>{template.name}</span> {/* Added truncate */}
                            <div className="space-x-2 flex-shrink-0"> {/* Added flex-shrink-0 */}
                              <button onClick={() => handleEdit(template)} className="text-sm bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded">Editar</button>
                              <button onClick={() => handleDelete(template.id)} className="text-sm bg-danger hover:bg-danger-hover px-2 py-1 rounded">Borrar</button>
                            </div>
                          </li>
                        ))}
                         {renderTemplates.length === 0 && <li className="text-text-secondary text-center p-4">No hay plantillas personalizadas.</li>}
                      </ul>
                    </div>
                    
                    <div className="flex flex-col"> {/* Added flex container */}
                      <h4 className="text-lg font-semibold mb-2">{editingTemplate ? (editingTemplate.id.startsWith('tpl_') ? 'Editar Plantilla' : 'Crear Nueva Plantilla') : 'Crear Nueva Plantilla'}</h4>
                      {editingTemplate ? (
                        <div className="space-y-4 p-4 border border-border-color rounded-lg bg-highlight flex flex-col flex-grow"> {/* Added flex */}
                           <input
                            type="text"
                            placeholder="Nombre de la Plantilla"
                            value={editingTemplate.name || ''}
                            onChange={(e) => setEditingTemplate(prev => ({ ...prev, name: e.target.value }))}
                            className="w-full bg-background border border-border-color rounded-md px-3 py-2"
                          />
                          <textarea
                            placeholder="Cuerpo de la Plantilla (HTML permitido)..."
                            value={editingTemplate.body || ''}
                            onChange={(e) => setEditingTemplate(prev => ({ ...prev, body: e.target.value }))}
                            className="w-full bg-background border border-border-color rounded-md px-3 py-2 resize-y flex-grow" // Added flex-grow
                          />
                           <p className="text-xs text-text-secondary flex-shrink-0">Marcadores: {`{{Columna}}`} (e.j: {`{{Nombre}}`}, {`{{No_Orden}}`})</p> {/* Added flex-shrink-0 */}
                          <div className="flex gap-2 flex-shrink-0"> {/* Added flex-shrink-0 */}
                            <button onClick={handleSaveTemplateEdit} className="bg-green-600 hover:bg-green-700 px-3 py-1 rounded text-sm">Guardar Cambios</button>
                            <button onClick={() => setEditingTemplate(null)} className="bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded text-sm">Cancelar</button>
                          </div>
                        </div>
                      ) : (
                        <button onClick={handleAddNew} className="w-full bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg">
                          Añadir Nueva Plantilla
                        </button>
                      )}
                    </div>
                  </div>
                </div>

                <div className="p-4 bg-header flex justify-between items-center rounded-b-lg flex-shrink-0"> {/* Added flex-shrink-0 */}
                   <button onClick={onReset} className="bg-danger hover:bg-danger-hover text-white font-bold py-2 px-4 rounded-lg">
                    Restaurar Predeterminadas
                  </button>
                  <div className="flex gap-4">
                    <button onClick={onClose} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">
                        Cancelar
                    </button>
                    <button onClick={handleSave} className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">
                        Guardar y Cerrar
                    </button>
                  </div>
                </div>
              </div>
            </div>
          );
        };

        // =================================================================================
        // INLINED: components/PreviewModal.tsx
        // =================================================================================
        const PreviewModal = ({ data, template, onClose }) => {
           // Ensure data is an object before proceeding
          if (!data || typeof data !== 'object') {
             console.error("Invalid data provided to PreviewModal:", data);
             return null; // Don't render if data is invalid
          }
          const bodyContent = template && template.body ? replacePlaceholders(template.body, data) : '<p><i>Selecciona un tipo de carta en el Área 3 para ver la vista previa.</i></p>';
          const fullBody = bodyContent + COMMON_EMAIL_BODY + SIGNATURE;

          const copyToClipboard = () => {
             // Create a temporary element to parse HTML and get text content
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = fullBody;
            // Get text content, trying different properties for browser compatibility
            const textContent = tempDiv.textContent || tempDiv.innerText || "";

            navigator.clipboard.writeText(textContent.trim()) // Trim whitespace
              .then(() => alert('¡Contenido de texto copiado al portapapeles!'))
              .catch(err => {
                   console.error('Failed to copy text content:', err);
                   alert('Falló al copiar el contenido de texto.');
               });
          };
          
          const copyHtmlToClipboard = () => {
               try {
                  // Use Clipboard API with HTML type
                  const blob = new Blob([fullBody], { type: 'text/html' });
                  const item = new ClipboardItem({ 'text/html': blob });
                  navigator.clipboard.write([item])
                     .then(() => alert('¡Contenido HTML copiado al portapapeles!'))
                     .catch(err => {
                          console.error('Failed to copy HTML content:', err);
                          alert('Falló al copiar el contenido HTML (tu navegador podría no soportarlo).');
                      });
               } catch (error) {
                  console.error('Error copying HTML:', error);
                  alert('Error al intentar copiar HTML (ClipboardItem puede no ser soportado).');
               }
           };

          return (
            <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[150] p-4"> {/* Increased z-index */}
              <div className="bg-surface rounded-lg shadow-xl w-full max-w-3xl border border-border-color flex flex-col max-h-[90vh]"> {/* Added max-h */}
                <div className="p-6 border-b border-border-color flex justify-between items-center">
                  <h3 className="text-xl font-bold text-primary">Vista Previa del Correo para Orden: {data.No_Orden || 'N/A'}</h3>
                   <button onClick={onClose} className="text-text-secondary text-2xl hover:text-text-primary">&times;</button>
                </div>
                {/* Use iframe to render HTML correctly */}
                <iframe 
                  srcDoc={fullBody}
                  className="p-1 flex-grow overflow-y-auto bg-white" // Use p-1 instead of p-6 for iframe, added flex-grow
                  sandbox="allow-same-origin" // Basic sandboxing for security
                  style={{border: 'none', minHeight: '300px'}} // Ensure minimum height
                  title="Vista Previa Email"
                />
                <div className="p-4 bg-header flex justify-end gap-4 rounded-b-lg flex-shrink-0"> {/* Added flex-shrink-0 */}
                   <button onClick={copyHtmlToClipboard} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors" title="Copiar como HTML formateado para pegar en correos">
                     Copiar HTML
                   </button>
                  <button onClick={copyToClipboard} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors" title="Copiar solo el texto sin formato">
                    Copiar Texto
                  </button>
                  <button onClick={onClose} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    Cerrar
                  </button>
                </div>
              </div>
            </div>
          );
        };
        

        // =================================================================================
        // INLINED: App.tsx (The main application component)
        // =================================================================================
        const App = () => {
          // Initialize state with empty arrays or appropriate defaults
          const [state, setState] = useState({
            finalData: [],
            trackingData: [],
            archivedData: [],
            portalData: [],
            pdfData: Array(5).fill({}),
            templates: [],
            scriptUrl: null,
            isSetupNeeded: false,
            isReconfiguring: false,
            isLoading: true,
            isSaving: false,
            isTemplateManagerOpen: false,
            previewData: null,
            notification: null,
            editsCount: 0,
            onlineStatus: true,
            masterTrackingOrders: new Set(),
          });

          const [sortConfig, setSortConfig] = useState({
            key: 'No_Orden',
            direction: 'ascending',
          });

          const hideNotification = useCallback(() => {
             setState((prev) => ({ ...prev, notification: null }));
          }, []); // Empty dependency array as it doesn't depend on external vars

          const showNotification = useCallback((message, type = 'info', duration = 5000) => {
             // Clear existing notification timeout if any
             if (state.notification && state.notification.timeoutId) {
                clearTimeout(state.notification.timeoutId);
             }
             const timeoutId = setTimeout(hideNotification, duration);
             setState((prev) => ({ ...prev, notification: { message, type, timeoutId } }));
          }, [hideNotification, state.notification]); // Depend on hideNotification and state.notification

          const handleSetScriptUrl = useCallback(async (url) => {
             console.log("Attempting to set script URL and fetch initial data..."); // Debug log
            setState((prev) => ({ ...prev, isLoading: true }));
            try {
              const data = await fetchData(url); // fetchData defined earlier
              localStorage.setItem('sigweb_scriptUrl', url);
              setState((prev) => ({
                ...prev,
                 // Ensure fetched data are arrays, default to empty if not
                finalData: Array.isArray(data.finalData) ? data.finalData : [],
                trackingData: Array.isArray(data.trackingData) ? data.trackingData : [],
                archivedData: Array.isArray(data.archivedData) ? data.archivedData : [],
                masterTrackingOrders: new Set(Array.isArray(data.masterTrackingOrders) ? data.masterTrackingOrders.map(String) : []), // Ensure Set contains strings
                scriptUrl: url,
                isSetupNeeded: false,
                isReconfiguring: false,
                isLoading: false,
              }));
              showNotification('¡Conexión exitosa y datos cargados!', 'success');
              console.log("Initial data fetched successfully."); // Debug log
            } catch (error) {
              console.error("Error setting script URL or fetching data:", error); // Log the actual error
              showNotification(
                `Falló la conexión: ${error.message}. Revisa la URL y permisos del script.`, // Show more specific error
                'error',
                 10000 // Show error longer
              );
              setState((prev) => ({ ...prev, isLoading: false, isSetupNeeded: true })); // Go back to setup on error
            }
          }, [showNotification]); // Add showNotification dependency


          useEffect(() => {
             console.log("App component mounted. Checking for script URL..."); // Debug log
            const url = localStorage.getItem('sigweb_scriptUrl');
            const loadedTemplates = loadTemplates(); // loadTemplates defined earlier
            setState((prev) => ({ ...prev, templates: loadedTemplates }));

            if (url) {
                console.log("Found script URL in localStorage:", url); // Debug log
                handleSetScriptUrl(url);
            } else {
                console.log("No script URL found. Setup needed."); // Debug log
                setState((prev) => ({ ...prev, isSetupNeeded: true, isLoading: false }));
            }

            // Online/Offline handling
            const updateOnlineStatus = () => {
                const isOnline = navigator.onLine;
                console.log("Network status changed:", isOnline ? "Online" : "Offline"); // Debug log
                setState(prev => ({ ...prev, onlineStatus: isOnline }));
                if (!isOnline) {
                    showNotification("Estás desconectado. El guardado está deshabilitado.", "warning", 10000);
                } else {
                     // Optionally show a "back online" message
                     // showNotification("Estás conectado de nuevo.", "info");
                }
            };

            window.addEventListener('online', updateOnlineStatus);
            window.addEventListener('offline', updateOnlineStatus);
            // Initial check
            updateOnlineStatus();

            return () => { // Cleanup listeners on component unmount
                console.log("App component unmounting. Removing listeners."); // Debug log
                window.removeEventListener('online', updateOnlineStatus);
                window.removeEventListener('offline', updateOnlineStatus);
                 // Clear any pending notification timeouts
                if (state.notification && state.notification.timeoutId) {
                    clearTimeout(state.notification.timeoutId);
                }
            };
            // Run only on mount and unmount
          }, [handleSetScriptUrl, showNotification]); // Added dependencies


          const incrementEdits = useCallback(() => {
            setState((prev) => ({ ...prev, editsCount: prev.editsCount + 1 }));
          },[]); // No dependencies needed

          const handleSave = useCallback(async () => {
             console.log("Save button clicked."); // Debug log
            if (!state.scriptUrl) {
              showNotification('No se puede guardar. La URL del script no está configurada.', 'error');
              return;
            }
            if (!state.onlineStatus) {
                showNotification('No se puede guardar mientras estás desconectado.', 'error');
                return;
            }
             if (state.finalData.length === 0 && state.trackingData.length === 0 && state.archivedData.length === 0) {
                 showNotification('No hay datos nuevos o modificados para guardar.', 'info');
                 return;
             }
            setState((prev) => ({ ...prev, isSaving: true }));
            console.log("Attempting to save data..."); // Debug log
            try {
              await saveData(state.scriptUrl, { // saveData defined earlier
                action: 'saveData', 
                payload: {
                    finalData: state.finalData,
                    trackingData: state.trackingData,
                    archivedData: state.archivedData,
                }
              });
              
              // IMPORTANT: Assume save was successful (due to no-cors limitations)
              // Update master tracking set LOCALLY with orders from finalData that were just sent
              const newOrders = new Set(state.masterTrackingOrders);
              state.finalData.forEach(row => {
                  if (row && row.No_Orden) { // Check row and No_Orden exist
                     newOrders.add(String(row.No_Orden).trim())
                  }
              });

              showNotification('¡Datos enviados a la nube! (Verifica la hoja "TOTAL" para confirmar)', 'success');
              console.log("Save request sent successfully."); // Debug log
              // Clear local finalData and reset edits count after sending
              setState((prev) => ({ 
                  ...prev, 
                  editsCount: 0, 
                  masterTrackingOrders: newOrders, 
                  finalData: [] // Clear the review area data after successful send
               })); 
            } catch (error) {
              console.error("Error during save:", error); // Log the actual error
              showNotification(`Falló el guardado de datos: ${error.message}`, 'error');
            } finally {
              setState((prev) => ({ ...prev, isSaving: false }));
              console.log("Save process finished."); // Debug log
            }
          }, [state.scriptUrl, state.onlineStatus, state.finalData, state.trackingData, state.archivedData, state.masterTrackingOrders, showNotification]); // Added dependencies


          const processPortalData = useCallback(() => {
              console.log("Processing portal data..."); // Debug log
               // Ensure portalData is an array
              const currentPortalData = Array.isArray(state.portalData) ? state.portalData : [];
              if(currentPortalData.length === 0){
                   showNotification("No hay datos cargados desde el archivo para procesar.", "warning");
                   return;
              }
              
              // Filter out rows that already exist based on masterTrackingOrders Set
              const newRows = currentPortalData.filter(row => {
                  // Ensure row and No_Orden exist before checking the Set
                   const orderKey = row && row.No_Orden ? String(row.No_Orden).trim() : null;
                   return orderKey && !state.masterTrackingOrders.has(orderKey);
              });

              const duplicates = currentPortalData.length - newRows.length;
              console.log(`Found ${newRows.length} new rows, skipped ${duplicates} duplicates.`); // Debug log

              const processedData = newRows
                  // Ensure row is valid before mapping
                  .filter(row => row && row.No_Orden && String(row.No_Orden).trim()) 
                  .map((row) => ({
                      ...row, // Keep all data
                      Nombre: capitalizeWords(row.Nombre || ''), // Apply specific formatting
                      EPS: (row.EPS || '').toUpperCase(),
                      // Ensure required fields for Area 3 have defaults if missing from Excel
                      Descripcion_PDF: row.Descripcion_PDF || '(pendiente)',
                      Justificacion_PDF: row.Justificacion_PDF || '(pendiente)',
                      Fundamento_Legal_PDF: row.Fundamento_Legal_PDF || '(pendiente)',
                      Tipo_Carta: row.Tipo_Carta || '',
                      Radicado_Comp: row.Radicado_Comp || '',
                  }));

              // Update finalData with only the NEW processed rows, clear portalData
              setState((prev) => ({ ...prev, finalData: processedData, portalData: [] })); 
              
              let message = `${processedData.length} nuevas filas procesadas y listas en Área 3.`;
              if (duplicates > 0) {
                  message += ` ${duplicates} fila(s) ya existentes fueron omitidas.`;
              }
              showNotification(message, processedData.length > 0 ? 'success' : 'info'); // Use 'info' if only duplicates found

          }, [state.portalData, state.masterTrackingOrders, showNotification]); // Dependencies


          const mergePdfData = useCallback(() => {
             console.log("Merging PDF data..."); // Debug log
             // Ensure pdfData is an array
             const currentPdfData = Array.isArray(state.pdfData) ? state.pdfData : [];
             if(currentPdfData.every(row => !Object.values(row).some(val => val))){
                 showNotification("No hay datos en el Área 2 para combinar.", "warning");
                 return;
             }

            const pdfMap = new Map();
            currentPdfData
              .filter(row => row && row['Archivo (No. Orden)'] && String(row['Archivo (No. Orden)']).trim()) // Ensure row and key exist
              .forEach(row => {
                 const key = String(row['Archivo (No. Orden)']).trim();
                 if(key){ // Ensure key is not empty
                    pdfMap.set(key, {
                      Descripcion_PDF: row['Descripción'] || '', // Use bracket notation for keys with spaces
                      Justificacion_PDF: row['Justificación'] || '',
                      Fundamento_Legal_PDF: row['Fundamento Legal'] || '',
                    });
                 }
              });
              
            console.log(`Created PDF map with ${pdfMap.size} entries.`); // Debug log

            // Ensure finalData is an array
            const currentFinalData = Array.isArray(state.finalData) ? state.finalData : [];
            let mergeCount = 0;
            const mergedData = currentFinalData.map(finalRow => {
              // Ensure finalRow and No_Orden exist
              const orderKey = finalRow && finalRow.No_Orden ? String(finalRow.No_Orden).trim() : null;
              if (orderKey) {
                  const pdfMatch = pdfMap.get(orderKey);
                  if (pdfMatch) {
                      mergeCount++;
                      return { ...finalRow, ...pdfMatch };
                  }
              }
              return finalRow; // Return original row if no match or invalid
            });

            setState((prev) => ({ ...prev, finalData: mergedData, pdfData: Array(5).fill({}) }));
            showNotification(`${mergeCount} fila(s) actualizadas con datos del PDF en el Área 3.`, 'success');
            console.log(`Merged PDF data into ${mergeCount} rows.`); // Debug log
          }, [state.pdfData, state.finalData, showNotification]); // Dependencies


          const updateFinalDataRow = useCallback((noOrden, partialUpdate) => {
             // Ensure noOrden is a string for comparison
             const keyToUpdate = String(noOrden);
            setState((prev) => {
                // Ensure finalData is an array
               const currentFinalData = Array.isArray(prev.finalData) ? prev.finalData : [];
               const newData = currentFinalData.map(row => 
                  (row && String(row.No_Orden) === keyToUpdate) ? { ...row, ...partialUpdate } : row
               );
               return { ...prev, finalData: newData };
            });
            // Increment edits count immediately without waiting for state update
            incrementEdits(); 
          }, [incrementEdits]); // Dependency on incrementEdits


          const handleClearReviewData = useCallback(() => {
            if (window.confirm("¿Limpiar la tabla de Revisión (Área 3)?\n\nEsto NO borrará datos de la hoja 'TOTAL' en Google Sheets.")) {
                setState(prev => ({ ...prev, finalData: [] })); // Only clear local state
                showNotification("Tabla de Revisión limpiada.", "info");
            }
          }, [showNotification]); // Dependency


          const handleSendToTracking = useCallback((selectedOrderKeys) => { // Receive Set keys (strings)
            console.log("Sending selected items to tracking:", selectedOrderKeys); // Debug log
             // Ensure finalData is an array
            const currentFinalData = Array.isArray(state.finalData) ? state.finalData : [];

            const itemsToSend = currentFinalData
              .filter(row => row && selectedOrderKeys.includes(String(row.No_Orden))) // Filter using string keys
              .filter(row => {
                const template = state.templates.find((t) => t.id === row.Tipo_Carta);
                return (
                  template &&
                  template.name.toUpperCase().includes('COMPLEMENTARIEDAD') &&
                  row.Radicado_Comp &&
                  String(row.Radicado_Comp).trim() !== ''
                );
              });

            if (itemsToSend.length === 0) {
              showNotification("No hay ítems seleccionados que cumplan los criterios (Tipo 'COMPLEMENTARIEDAD' con 'Radicado') para enviar a seguimiento.", 'warning');
              return;
            }
             console.log(`${itemsToSend.length} items meet criteria for tracking.`); // Debug log

            setState(prev => {
                // Ensure trackingData and finalData are arrays
               const currentTrackingData = Array.isArray(prev.trackingData) ? prev.trackingData : [];
               let newTrackingData = [...currentTrackingData];
               let newFinalData = Array.isArray(prev.finalData) ? [...prev.finalData] : [];
               let addedCount = 0;
               let updatedCount = 0;

               itemsToSend.forEach(item => {
                 const itemOrderKey = String(item.No_Orden);
                 const existingIndex = newTrackingData.findIndex(t => t && String(t.No_Orden) === itemOrderKey);
                 if (existingIndex !== -1) {
                   if (window.confirm(`El caso ${itemOrderKey} ya está en seguimiento activo. ¿Actualizar Radicado?`)) {
                     newTrackingData[existingIndex] = { ...newTrackingData[existingIndex], Radicado: item.Radicado_Comp }; // Update existing
                     updatedCount++;
                   }
                 } else {
                   newTrackingData.push({ // Add new
                     Fecha_Ing: item.Fecha_Neg || new Date().toISOString().slice(0,10), // Use Neg date or today
                     No_Orden: item.No_Orden,
                     Nombre: item.Nombre || '',
                     EPS: item.EPS || '',
                     Radicado: item.Radicado_Comp, // Already validated not empty
                     Estado: 'Pendiente',
                     Notas: '',
                   });
                   addedCount++;
                 }
               });
               
               // Remove sent items from finalData
               const itemsSentOrderKeys = itemsToSend.map(i => String(i.No_Orden));
               newFinalData = newFinalData.filter(f => f && !itemsSentOrderKeys.includes(String(f.No_Orden)));

               if(addedCount > 0 || updatedCount > 0){
                   showNotification(`${addedCount} nuevo(s) enviado(s), ${updatedCount} actualizado(s) en Seguimiento Activo.`, 'success');
               }

               return { ...prev, trackingData: newTrackingData, finalData: newFinalData };
            });

          }, [state.templates, showNotification]); // Dependencies


          const exportForMailMerge = useCallback((dataToExport) => {
              // Ensure data is an array
              const currentData = Array.isArray(dataToExport) ? dataToExport : [];
              if (!currentData || currentData.length === 0) {
                  showNotification("No hay datos en revisión (Área 3) para exportar.", "warning");
                  return;
              }
              console.log(`Exporting ${currentData.length} rows for mail merge.`); // Debug log
              try {
                  const exportable = currentData.map(row => ({
                      // Ensure all keys exist, default to empty string
                      "Fecha": row.Fecha_Neg || '', 
                      "Orden": row.No_Orden || '',
                      "Cedula": row.No_Cedula || '',
                      "Nombre": row.Nombre || '',
                      "EPS": row.EPS || '',
                      "Programa": row.Programa || '',
                      "Email": row.Email || '',
                      "Motivo": row.Motivo_Negacion || '',
                      "Desc": row.Descripcion_PDF || '',
                      "Just": row.Justificacion_PDF || '',
                      "Fund": row.Fundamento_Legal_PDF || '',
                      "Carta": state.templates.find(t => t.id === row.Tipo_Carta)?.name || "NO_SELECCIONADA",
                      "Radicado": row.Radicado_Comp || ''
                  }));
                  const ws = XLSX.utils.json_to_sheet(exportable);
                  const wb = XLSX.utils.book_new();
                  XLSX.utils.book_append_sheet(wb, ws, "DatosParaEnvio");
                  XLSX.writeFile(wb, "Sigweb_Procesado_MailMerge.xlsx");
                  showNotification("Archivo 'Sigweb_Procesado_MailMerge.xlsx' generado.", "success");
              } catch (error) {
                   console.error("Error exporting for mail merge:", error);
                   showNotification("Error al generar el archivo para envío masivo.", "error");
              }
          }, [state.templates, showNotification]); // Dependencies


          const updateTrackingData = useCallback((index, updatedRow, isArchived) => {
             // Ensure index is a valid number
             if (typeof index !== 'number' || index < 0) {
                 console.error("Invalid index provided to updateTrackingData:", index);
                 return;
             }
            const dataKey = isArchived ? 'archivedData' : 'trackingData';
            setState(prev => {
                // Ensure the target array exists and is an array
               const currentData = Array.isArray(prev[dataKey]) ? [...prev[dataKey]] : [];
               if(index < currentData.length) { // Check if index is within bounds
                  currentData[index] = updatedRow;
                  console.log(`Updated item at index ${index} in ${dataKey}`); // Debug log
                  return { ...prev, [dataKey]: currentData, editsCount: prev.editsCount + 1 }; // Increment edits count on change
               } else {
                   console.error(`Index ${index} out of bounds for ${dataKey}`);
                   return prev; // Return previous state if index is invalid
               }
            });
          }, []); // No external dependencies needed


          const archiveItems = useCallback((indicesToMove, fromArchived) => {
             // Ensure indicesToMove is an array of numbers
             if (!Array.isArray(indicesToMove) || indicesToMove.some(isNaN)){
                 console.error("Invalid indices provided to archiveItems:", indicesToMove);
                 return;
             }
             console.log(`${fromArchived ? 'Unarchiving' : 'Archiving'} indices:`, indicesToMove); // Debug log
            const sourceKey = fromArchived ? 'archivedData' : 'trackingData';
            const targetKey = fromArchived ? 'trackingData' : 'archivedData';

            setState(prev => {
                // Ensure source and target data are arrays
               const sourceData = Array.isArray(prev[sourceKey]) ? [...prev[sourceKey]] : [];
               const targetData = Array.isArray(prev[targetKey]) ? [...prev[targetKey]] : [];
               
               const itemsToMove = [];
               const remainingSource = [];

               // Separate items to move and items to keep, handling potential sparse arrays or invalid indices
               sourceData.forEach((item, index) => {
                   if (indicesToMove.includes(index)) {
                       if (item) itemsToMove.push(item); // Only move valid items
                   } else {
                        if(item) remainingSource.push(item); // Keep valid items
                   }
               });
               
               console.log(`Moving ${itemsToMove.length} items from ${sourceKey} to ${targetKey}.`); // Debug log

               return {
                 ...prev,
                 [sourceKey]: remainingSource,
                 [targetKey]: [...targetData, ...itemsToMove], // Append moved items
                 editsCount: prev.editsCount + itemsToMove.length // Increment edits for each moved item
               };
            });
          }, []); // No external dependencies

          const handleSaveTemplates = useCallback((newTemplates) => {
            // Ensure newTemplates is an array
            const templatesToSave = Array.isArray(newTemplates) ? newTemplates : [];
            setState((prev) => ({ ...prev, templates: templatesToSave }));
            saveTemplates(templatesToSave); // saveTemplates defined earlier
            showNotification('Plantillas de correo guardadas localmente.', 'success');
          }, [showNotification]); // Dependency

          const handleResetTemplates = useCallback(() => {
            if (window.confirm('¿Restaurar plantillas predeterminadas? Se perderán las personalizadas.')) {
              handleSaveTemplates(defaultTemplates); // Use defaultTemplates constant
            }
          }, [handleSaveTemplates]); // Dependency

          // Memoized sorted data for Area 3
          const sortedFinalData = useMemo(() => {
             // Ensure finalData is an array
            let sortableItems = Array.isArray(state.finalData) ? [...state.finalData] : []; 
            if (sortConfig.key) {
                sortableItems.sort((a, b) => {
                     // Handle potential null/undefined rows during sort
                    if (!a || !b) return 0; 
                    // Safely access sort key, default to empty string if missing
                    const aVal = a[sortConfig.key] !== undefined && a[sortConfig.key] !== null ? String(a[sortConfig.key]) : '';
                    const bVal = b[sortConfig.key] !== undefined && b[sortConfig.key] !== null ? String(b[sortConfig.key]) : '';
                    
                    // LocaleCompare for potentially better string sorting
                    const comparison = aVal.localeCompare(bVal, undefined, { numeric: true, sensitivity: 'base' });

                    return sortConfig.direction === 'ascending' ? comparison : -comparison;
                });
            }
            return sortableItems;
          }, [state.finalData, sortConfig]); // Dependencies

          // ================== Render Logic ==================

          if (state.isLoading && !state.isSetupNeeded) { // Show loader only if not in initial setup
            return <div className="fixed inset-0 bg-background/90 flex items-center justify-center z-[300]"><Spinner /> <span className="ml-4 text-xl">Cargando Datos Iniciales...</span></div>;
          }

          // Show Setup Modal if needed or reconfiguring
          if (state.isSetupNeeded || state.isReconfiguring) {
            return <SetupModal 
                onSave={handleSetScriptUrl} 
                onClose={() => {
                    // Only close if not in initial setup, otherwise keep showing it
                    if(!state.isSetupNeeded) {
                       setState(prev => ({ ...prev, isReconfiguring: false }));
                    } else {
                         alert("Debes configurar la URL del script para continuar.");
                    }
                }} 
                initialUrl={state.scriptUrl || ''} 
             />;
          }

          // Main App Render
          return (
            <div className="p-4 sm:p-8 bg-background min-h-screen">
              {/* Notification Area */}
              {state.notification && (
                <Notification
                  message={state.notification.message}
                  type={state.notification.type}
                  onClose={hideNotification} 
                />
              )}
              {/* Offline Indicator */}
              {!state.onlineStatus && (
                   <div className="bg-yellow-600 text-white text-center p-2 fixed top-0 left-0 w-full z-[100]">
                     ⚠ Estás desconectado. El guardado en la nube está deshabilitado.
                   </div>
              )}

              <main className={`max-w-screen-2xl mx-auto bg-surface p-4 sm:p-6 rounded-xl border border-border-color space-y-8 ${!state.onlineStatus ? 'pt-10' : ''}`}> {/* Add padding top if offline banner shows */}
                <Header 
                    onSave={handleSave} 
                    onManageTemplates={() => setState(prev => ({ ...prev, isTemplateManagerOpen: true }))}
                    onReconfigure={() => setState(prev => ({ ...prev, isReconfiguring: true }))}
                />
                <Dashboard
                  reviewCount={Array.isArray(state.finalData) ? state.finalData.length : 0}
                  trackingCount={Array.isArray(state.trackingData) ? state.trackingData.length : 0}
                  archivedCount={Array.isArray(state.archivedData) ? state.archivedData.length : 0}
                  editsCount={state.editsCount}
                />
                <div className="text-right">
                       <button
                           onClick={() => exportDetailedReport(state.finalData, state.trackingData, state.archivedData)}
                           className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors"
                       >
                           Descargar Reporte Detallado
                       </button>
                </div>

                <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                  {/* Area 1: File Upload */}
                  <DataInputArea
                    id="portal-area"
                    title="Área 1: Cargar Excel del Portal"
                    headers={PORTAL_HEADERS}
                    data={state.portalData} // Bind to portalData
                    onDataChange={(newData) => setState(prev => ({ ...prev, portalData: newData }))}
                    onProcess={processPortalData} // Use specific processor
                    processButtonText="Procesar Datos del Archivo"
                    inputType="file" 
                  />
                  {/* Area 2: Paste PDF Data */}
                  <DataInputArea
                    id="pdf-area"
                    title="Área 2: Pegar Datos del Extractor PDF"
                    headers={PDF_HEADERS}
                    data={state.pdfData} // Bind to pdfData
                    onDataChange={(newData) => setState(prev => ({ ...prev, pdfData: newData }))}
                    onProcess={mergePdfData} // Use specific processor
                    processButtonText="Combinar con Datos del PDF"
                    inputType="paste"
                  />
                </div>
                 {/* Area 3: Review */}
                <ReviewArea
                  data={sortedFinalData} // Use memoized sorted data
                  templates={state.templates}
                  updateRow={updateFinalDataRow}
                  incrementEdits={incrementEdits}
                  onSendToTracking={handleSendToTracking}
                  onPreview={(row) => setState(prev => ({ ...prev, previewData: row }))}
                  onExportForMailMerge={exportForMailMerge}
                  onClearReviewData={handleClearReviewData}
                  sortConfig={sortConfig}
                  setSortConfig={setSortConfig}
                />
                 {/* Area 4: Tracking */}
                <TrackingArea
                  trackingData={state.trackingData}
                  archivedData={state.archivedData}
                  updateTrackingData={updateTrackingData}
                  archiveItems={archiveItems}
                />
                
                {/* Saving Indicator */}
                {state.isSaving && <div className="fixed inset-0 bg-background/80 flex items-center justify-center z-[300]"><Spinner /> <span className="ml-4 text-xl">Guardando Datos...</span></div>}
              </main>

              {/* Template Manager Modal */}
              {state.isTemplateManagerOpen && (
                <TemplateManagerModal
                  templates={state.templates}
                  onClose={() => setState(prev => ({...prev, isTemplateManagerOpen: false}))}
                  onSave={handleSaveTemplates}
                  onReset={handleResetTemplates}
                />
              )}
               {/* Preview Modal */}
              {state.previewData && (
                <PreviewModal
                  data={state.previewData}
                  template={state.templates.find(t => t.id === state.previewData?.Tipo_Carta)} // Safely find template
                  onClose={() => setState(prev => ({...prev, previewData: null}))}
                />
              )}
            </div>
          );
        };

        // =================================================================================
        // INLINED: index.tsx (Render the application)
        // =================================================================================
        const rootElement = document.getElementById('root');
        if (!rootElement) {
          console.error("Fatal Error: Root element 'root' not found in HTML."); // Log error
          // Optionally display a message to the user in the body
          document.body.innerHTML = '<div style="color: red; padding: 20px;">Error Crítico: No se encontró el elemento raíz de la aplicación.</div>';
        } else {
            try {
               const root = ReactDOM.createRoot(rootElement);
               root.render(<React.StrictMode><App /></React.StrictMode>); // Added StrictMode for development checks
            } catch(error) {
                console.error("Error rendering React application:", error);
                 rootElement.innerHTML = '<div style="color: red; padding: 20px;">Error Crítico: Falló al iniciar la aplicación React.</div>';
            }
        }

    </script>
</body>
</html>
