<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta http-equiv="Content-Security-Policy"
          content="default-src 'self' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://unpkg.com https://esm.sh;
                   script-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://unpkg.com https://esm.sh;
                   style-src 'self' 'unsafe-inline';
                   connect-src 'self' https://script.google.com https://unpkg.com;"> {/* Añadido unpkg.com */}

    <title>GESTION NEGACIONES EJE CAFETERO</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'primary': '#4e9fef',
              'background': '#1e1e1e',
              'surface': '#2d2d2d',
              'text-primary': '#d4d4d4',
              'text-secondary': '#a0a0a0',
              'border-color': '#444',
              'header': '#3a3a3a',
              'highlight': '#252526',
              'warning': '#6e550c',
              'archive': '#3a3a3a',
              'success': '#28a745',
              'danger': '#a02d2d',
              'danger-hover': '#c0392b',
              'btn-primary': '#0e639c',
              'btn-primary-hover': '#1a73e8',
            },
            animation: {
              'flash-success': 'flash-success 1s ease-out',
               'fade-in-down': 'fade-in-down 0.5s ease-out forwards',
            },
            keyframes: {
              'flash-success': {
                'from': { backgroundColor: '#28a745' },
                'to': { backgroundColor: 'transparent' },
              },
               'fade-in-down': {
                 '0%': { opacity: '0', transform: 'translateY(-10px)' },
                 '100%': { opacity: '1', transform: 'translateY(0)' },
               },
            }
          }
        }
      }
    </script>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client"
      }
    }
    </script>
</head>

<body class="bg-background text-text-primary">
    <div id="root"></div>

    <script type="text/babel" data-presets="react" data-type="module">
        import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react'; // Added useRef
        import ReactDOM from 'react-dom/client';

        // =================================================================================
        // INLINED: constants.ts - No changes needed
        // =================================================================================
        const PORTAL_HEADERS = [
            "Fecha_Neg", "Sucursal", "No_Orden", "No_Cedula", "Nombre", "Entidad_Ejecutora",
            "Motivo_Negacion", "Usuario_Emitio", "Auditor", "Observacion_Auditor", "Observacion_Ejecutivo",
            "Programa", "Plan", "Antiguedad", "EPS", "Telefono", "Celular", "Direccion", "Email", "Edad",
            "Tipo_Usuario", "Llamada", "Complementariedad", "Notificacion", "Gestion_Negacion", "Alternativa",
            "Observacion_Alternativa", "Monto", "Nit_Prestador", "Fecha_Complementariedad", "Tiempo_de_Gestion", "Regional"
        ];
        const PDF_HEADERS = ["Archivo (No. Orden)", "Descripción", "Justificación", "Fundamento Legal", "Código"];
        const TRACKING_STATUSES = ['Pendiente', 'En Gestión', 'Finalizado'];
        const COMMON_EMAIL_BODY = `<br><br><b>Si tiene alguna duda puede contactarse por medio de los canales que tenemos disponibles para usted:</b><br>· Nuestra línea nacional 018000931666. O con nuestras líneas locales: Cali (602) 489 0073, Bogotá (601) 743 5485, Medellín (604) 604 4507, Barranquilla (605) 385 3165, Bucaramanga (607) 697 3350, Cartagena (605) 693 9853, Tuluá (602) 235 9483, Valledupar (605)588 5699, Pereira (606) 340 2635.<br>· WhatsApp: 317-224-07-94<br><br>Gracias por su Atención.`;
        const SIGNATURE = `<br><br>Cordialmente,<br><br><b>Juan Ricardo Morales Agudelo</b><br>Ejecutivo De Atención Integral<br>Coomeva Medicina Prepagada<br>Cra. 13 No.11-12 Centro Médico Circunvalar<br>Coomeva Medicina Prepagada Pereira, Risaralda<br><br><i>Este correo es generado automáticamente, por favor no responda este mensaje.</i>`;
        const defaultTemplates = [
            { id: 'tpl_neg_gen', name: 'PLANTILLA NEGACION GENERAL', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar información acerca del servicio {{Motivo_Negacion}} que en esta oportunidad no está aprobado debido a que corresponde a EXCLUSIÓN ({{Descripcion_PDF}}), ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>El servicio negado anteriormente; debe tramitarlo a través su EPS asignada. Adjuntamos soporte de la carta de negación.` },
            { id: 'tpl_neg_pert', name: 'PLANTILLA NO PERTINENCIA Y TEMAS ESTETICOS', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar información acerca del servicio {{Motivo_Negacion}} que en esta oportunidad No está aprobado debido a que corresponde a NO PERTINENCIA ({{Descripcion_PDF}}), ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>` },
            { id: 'tpl_comp_coinc', name: 'COMPLEMENTARIEDAD RED COINCIDENTE', body: `Apreciado Usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y el de su familia. Por medio de este correo queremos brindar información acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no fue aprobado, debido a que ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>Sin embargo, está en gestión a través de su EPS ({{EPS}}) con el número de radicado ({{Radicado_Comp}}), puede realizar seguimiento mediante la oficina virtual de la EPS ({{Oficina_Virtual_EPS}}).<br><br>Adicional estaremos haciendo seguimiento al radicado y una vez se encuentre gestionado por la EPS, le notificaremos por medio de correo electrónico.` },
            { id: 'tpl_comp_no_coinc', name: 'COMPLEMENTARIEDAD RED NO COINCIDENTE', body: `Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar información acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no está aprobado, debido a que corresponde a ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>El prestador actual solicitado, no tiene convenio con la EPS, por lo que los costos adicionales del servicio o insumo estarán a cargo del paciente. Sin embargo; se radica la solicitud ante su EPS con el número ({{Radicado_Comp}}) por favor realizar seguimiento mediante la oficina virtual de la EPS ({{Oficina_Virtual_EPS}}).` },
            { id: 'tpl_comp_ayudas', name: 'COMPLEMENTARIEDAD AYUDAS DIAGNOSTICAS', body: `Apreciado usuario;<br><br>Agradecemos la confianza que ha depositado en nosotros al confiar el cuidado de su salud y la de su familia. Por medio de este correo queremos brindar información acerca del servicio ({{Descripcion_PDF}}) que en esta oportunidad no está aprobado debido a que corresponde a ({{Justificacion_PDF}}), ({{Fundamento_Legal_PDF}}).<br><br>Sin embargo, se encuentra en gestión a través de su EPS con el número de radicado ({{Radicado_Comp}}), por favor realizar seguimiento mediante la oficina virtual. ({{Oficina_Virtual_EPS}}).` },
        ];


        // =================================================================================
        // INLINED: services/utilityService.ts - No changes needed
        // =================================================================================
        const capitalizeWords = (str) => { /* ... */ };
        const processPastedData = (pastedText, headers) => { /* ... */ };
        const replacePlaceholders = (templateBody, data) => { /* ... */ };
        const exportDetailedReport = (finalData, trackingData, archivedData) => { /* ... */ };
         // Function definitions from previous step...
         const capitalizeWords = (str) => {
           if (!str) return '';
           return str.toLowerCase().replace(/\b\w/g, char => char.toUpperCase());
         };

         const processPastedData = (pastedText, headers) => {
           return pastedText
             .trim()
             .split(/\r?\n/)
             .map(rowText => {
               const cells = rowText.split('\t');
               const rowObject = {};
               headers.forEach((header, index) => {
                  rowObject[header] = cells[index] ? cells[index].trim() : '';
               });
               return rowObject;
             });
         };

         const replacePlaceholders = (templateBody, data) => {
           const getOficinaVirtual = (eps) => {
             const e = (eps || "").toUpperCase();
             if (e.includes("NUEVA EPS")) return `<a href='https://portal.nuevaeps.com.co/Portal/home.jspx' target='_blank' rel='noopener noreferrer' style='color: #1a73e8; text-decoration: underline;'>NUEVA EPS</a>`;
             if (e.includes("SALUD TOTAL")) return `<a href='https://saludtotal.com.co/' target='_blank' rel='noopener noreferrer' style='color: #1a73e8; text-decoration: underline;'>SALUD TOTAL</a>`;
             return eps || '';
           };
           const safeData = (typeof data === 'object' && data !== null) ? data : {};
           const fullData = { ...safeData, Oficina_Virtual_EPS: getOficinaVirtual(safeData.EPS) };
           const safeTemplateBody = typeof templateBody === 'string' ? templateBody : '';
           return safeTemplateBody.replace(/\{\{(\w+)\}\}/g, (match, key) => {
             const value = fullData[key];
             return value !== null && value !== undefined ? String(value) : '';
           });
         };

          const exportDetailedReport = (finalData, trackingData, archivedData) => {
            try {
              const masterDataMap = new Map();
              const safeFinalData = Array.isArray(finalData) ? finalData : [];
              const safeTrackingData = Array.isArray(trackingData) ? trackingData : [];
              const safeArchivedData = Array.isArray(archivedData) ? archivedData : [];

              [...safeFinalData, ...safeTrackingData, ...safeArchivedData].forEach(row => {
                if (row && row.No_Orden) {
                  const key = String(row.No_Orden).trim();
                  if (key) {
                    const existing = masterDataMap.get(key) || {};
                    masterDataMap.set(key, { ...existing, ...row });
                  }
                }
              });

              const masterData = Array.from(masterDataMap.values());
              if (masterData.length === 0) { alert("No hay datos consolidados para exportar."); return; }

              const wb = XLSX.utils.book_new();
              const allHeaders = [...new Set([...PORTAL_HEADERS, 'Fecha_Ing', 'Radicado', 'Estado', 'Notas'])];

              if (safeFinalData.length > 0) {
                const ws1 = XLSX.utils.json_to_sheet(safeFinalData, { header: allHeaders });
                XLSX.utils.book_append_sheet(wb, ws1, "Casos en Revisión");
              }
              if (safeTrackingData.length > 0) {
                const ws2 = XLSX.utils.json_to_sheet(safeTrackingData, { header: allHeaders });
                XLSX.utils.book_append_sheet(wb, ws2, "Seguimiento Activo");
              }
              if (safeArchivedData.length > 0) {
                const ws3 = XLSX.utils.json_to_sheet(safeArchivedData, { header: allHeaders });
                XLSX.utils.book_append_sheet(wb, ws3, "Seguimiento Archivado");
              }
              const ws4 = XLSX.utils.json_to_sheet(masterData, { header: allHeaders });
              XLSX.utils.book_append_sheet(wb, ws4, "Maestro Consolidado");
              XLSX.writeFile(wb, `Sigweb_Reporte_Detallado_${new Date().toISOString().slice(0, 10)}.xlsx`);
            } catch (error) { console.error("Falló la exportación:", error); alert("Error al generar reporte."); }
          };


        // =================================================================================
        // INLINED: services/templateService.ts - No changes needed
        // =================================================================================
        const TEMPLATE_STORAGE_KEY = 'sigweb_emailTemplates';
        const loadTemplates = () => { /* ... */ };
        const saveTemplates = (templates) => { /* ... */ };
         // Function definitions from previous step...
         const loadTemplates = () => {
           let loadedTemplates = [...defaultTemplates];
           try {
             const storedTemplates = localStorage.getItem(TEMPLATE_STORAGE_KEY);
             if (storedTemplates) {
               const parsed = JSON.parse(storedTemplates);
               if (Array.isArray(parsed) && parsed.every(t => t && typeof t.id === 'string' && typeof t.name === 'string' && typeof t.body === 'string')) {
                  loadedTemplates = parsed; console.log("Loaded templates from localStorage.");
               } else { console.warn("Stored templates invalid. Using defaults."); localStorage.removeItem(TEMPLATE_STORAGE_KEY); }
             } else { console.log("No stored templates. Using defaults."); }
           } catch (error) { console.error("Error loading templates. Using defaults.", error); localStorage.removeItem(TEMPLATE_STORAGE_KEY); }
            const loadedIds = new Set(loadedTemplates.map(t => t.id));
            const missingDefaults = defaultTemplates.filter(dt => !loadedIds.has(dt.id));
            if (missingDefaults.length > 0) { console.log("Adding missing defaults."); loadedTemplates = [...loadedTemplates, ...missingDefaults]; saveTemplates(loadedTemplates); }
            return loadedTemplates;
         };
         const saveTemplates = (templates) => {
           try {
             if (!Array.isArray(templates) || !templates.every(t => t && typeof t.id === 'string' && typeof t.name === 'string' && typeof t.body === 'string')) {
                console.error("Invalid templates data for saving."); alert("Error: Datos de plantilla inválidos."); return;
             }
             localStorage.setItem(TEMPLATE_STORAGE_KEY, JSON.stringify(templates)); console.log("Templates saved.");
           } catch (error) { console.error("Failed to save templates:", error); alert("Error al guardar plantillas."); }
         };


        // =================================================================================
        // INLINED: services/googleSheetService.ts - No changes needed
        // =================================================================================
        const fetchData = async (url) => { /* ... */ };
        const saveData = async (url, requestBody) => { /* ... */ };
         // Function definitions from previous step...
         const fetchData = async (url) => {
             console.log("Fetching data from:", url);
             if (!url || typeof url !== 'string' || !url.startsWith('https://script.google.com/macros/s/')) { throw new Error("URL inválida para fetchData."); }
             try {
                 const fetchUrl = `${url}?action=getData&t=${Date.now()}`;
                 const response = await fetch(fetchUrl);
                 console.log("Fetch status:", response.status, response.statusText);
                 if (!response.ok) {
                     let errorText = `HTTP error ${response.status} ${response.statusText}`; try { const body = await response.text(); if (body) errorText += ` - ${body}`; } catch (e) {}
                     console.error("Fetch not ok:", errorText);
                     if (response.status === 401 || response.status === 403) errorText += "\n\n**Sugerencia:** Verifica permisos de ejecución y acceso anónimo en Google Apps Script.";
                     else if (response.status === 404) errorText += "\n\n**Sugerencia:** Verifica URL y si la implementación está activa.";
                     throw new Error(`Respuesta de red no ok: ${errorText}`);
                 }
                 const contentType = response.headers.get("content-type");
                 if (!contentType || !contentType.includes("application/json")) { console.error("Non-JSON response:", await response.text()); throw new Error(`Respuesta inesperada (no JSON). Content-Type: ${contentType}`); }
                 const data = await response.json(); console.log("Fetched data:", data);
                 return { finalData: Array.isArray(data.finalData) ? data.finalData : [], trackingData: Array.isArray(data.trackingData) ? data.trackingData : [], archivedData: Array.isArray(data.archivedData) ? data.archivedData : [], masterTrackingOrders: Array.isArray(data.masterTrackingOrders) ? data.masterTrackingOrders : [] };
             } catch (error) {
                  console.error("Fetch data failed:", error);
                  if (error instanceof TypeError && error.message.includes('Failed to fetch')) { throw new Error("Error de red: No se pudo conectar. Verifica URL y conexión."); }
                  if (error.message.startsWith("Respuesta de red no ok") || error.message.startsWith("Respuesta inesperada")) { throw error; }
                  throw new Error(`Error al obtener datos: ${error.message}`);
             }
         };
         const saveData = async (url, requestBody) => {
             console.log("Saving data to:", url);
             if (!url || typeof url !== 'string' || !url.startsWith('https://script.google.com/macros/s/')) { throw new Error("URL inválida para saveData."); }
             if (!requestBody || typeof requestBody !== 'object' || requestBody.action !== 'saveData' || !requestBody.payload) { console.error("Invalid body for saveData:", requestBody); throw new Error("Formato inválido para guardar."); }
             const bodyString = JSON.stringify(requestBody); console.log(`Save size: ~${(bodyString.length / 1024).toFixed(2)} KB`);
             try {
                 await fetch(url, { method: 'POST', mode: 'no-cors', cache: 'no-cache', headers: { 'Content-Type': 'text/plain;charset=utf-8' }, body: bodyString });
                 console.log("Save request sent (no-cors). Assuming success.");
                 return { status: 'success', message: 'Datos enviados (respuesta no verificada).' };
             } catch (error) {
                 console.error("Save fetch error:", error);
                 if (error instanceof TypeError && error.message.includes('Failed to fetch')) { throw new Error("Error de red al guardar. Verifica URL y conexión."); }
                 if (bodyString.length > 100 * 1024) { console.warn("Payload grande, puede exceder límites."); }
                 throw new Error(`Error al guardar: ${error.message}`);
             }
         };


        // =================================================================================
        // INLINED: components/Spinner.tsx - No changes needed
        // =================================================================================
        const Spinner = React.memo(() => { /* ... */ });
         // Function definition from previous step...
         const Spinner = React.memo(() => (
           <div
             className="inline-block h-6 w-6 animate-spin rounded-full border-4 border-solid border-primary border-r-transparent align-[-0.125em] motion-reduce:animate-[spin_1.5s_linear_infinite]"
             role="status"
           ><span className="!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]">Cargando...</span></div>
         ));

        // =================================================================================
        // INLINED: components/Notification.tsx - No changes needed
        // =================================================================================
        const Notification = React.memo(({ message, type = 'info', onClose }) => { /* ... */ });
         // Function definition from previous step...
         const Notification = React.memo(({ message, type = 'info', onClose }) => {
             const typeClasses = { success: 'bg-green-600', error: 'bg-red-600', warning: 'bg-yellow-500 text-black', info: 'bg-blue-600' };
             const [isVisible, setIsVisible] = useState(true);
             const timeoutIdRef = useRef(null);
             const handleClose = useCallback(() => { setIsVisible(false); if (timeoutIdRef.current) clearTimeout(timeoutIdRef.current); if (onClose) onClose(); }, [onClose]);
             useEffect(() => { if (onClose) { timeoutIdRef.current = setTimeout(handleClose, 5000); return () => { if (timeoutIdRef.current) clearTimeout(timeoutIdRef.current); }; } }, [handleClose, onClose]);
             if (!isVisible) return null;
             return (
                 <div className={`fixed top-5 right-5 z-[250] p-4 rounded-lg shadow-lg text-white ${typeClasses[type] || typeClasses.info} flex items-center gap-4 animate-fade-in-down`}>
                     <span>{message}</span><button onClick={handleClose} className="text-xl font-bold leading-none ml-2 flex-shrink-0">&times;</button>
                 </div>
             );
         });

        // =================================================================================
        // INLINED: components/Header.tsx - No changes needed
        // =================================================================================
        const Header = React.memo(({ onSave, onManageTemplates, onReconfigure }) => { /* ... */ });
         // Function definition from previous step...
         const Header = React.memo(({ onSave, onManageTemplates, onReconfigure }) => {
           console.log("Rendering Header");
           return (
             <header className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 pb-4 border-b border-border-color">
               <div><h1 className="text-2xl lg:text-3xl font-bold text-white">GESTION NEGACIONES EJE CAFETERO</h1><p className="text-text-secondary text-sm">Sistema Integrado de Gestión de Flujos de Trabajo</p></div>
               <div className="flex flex-wrap gap-2">
                 <button onClick={onManageTemplates} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-3 rounded-lg transition-colors text-xs sm:text-sm">Plantillas</button>
                 <button onClick={onReconfigure} className="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-3 rounded-lg transition-colors flex items-center gap-1 text-xs sm:text-sm"><svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0L8.21 5.15a1.5 1.5 0 01-1.25.82l-2.09.28c-1.68.23-2.34 2.26-1.09 3.42l1.52 1.48a1.5 1.5 0 01-.42 2.1l-1.83 1.25c-1.38.94-.92 3.01.7 3.42l2.05.51a1.5 1.5 0 011.1.98l.8 2.07c.43 1.12 2.29 1.12 2.72 0l.8-2.07a1.5 1.5 0 011.1-.98l2.05-.51c1.62-.4 2.08-2.48.7-3.42l-1.83-1.25a1.5 1.5 0 01-.42-2.1l1.52-1.48c1.25-1.16.59-3.19-1.09-3.42L13 5.97a1.5 1.5 0 01-1.25-.82l-.3-1.98zM10 13a3 3 0 100-6 3 3 0 000 6z" clipRule="evenodd" /></svg>Config</button>
                 <button onClick={onSave} className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-lg transition-colors flex items-center gap-1 text-xs sm:text-sm"><svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M5.5 16.5a2.5 2.5 0 01-5 0V4.414a1.5 1.5 0 01.44-1.06L4.354.439A1.5 1.5 0 015.414 0H12.5a2.5 2.5 0 012.5 2.5v2" /><path d="M5.5 16.5h8a2.5 2.5 0 002.5-2.5V8.5h-13v5.5a2.5 2.5 0 002.5 2.5z" /><path d="M10.5 10a.5.5 0 01.5-.5h2a.5.5 0 010 1h-2a.5.5 0 01-.5-.5z" /></svg>Guardar</button>
               </div>
             </header>
           );
         });

        // =================================================================================
        // INLINED: components/Dashboard.tsx - No changes needed
        // =================================================================================
        const DashboardCard = React.memo(({ title, value, icon }) => { /* ... */ });
        const Dashboard = React.memo(({ reviewCount, trackingCount, archivedCount, editsCount }) => { /* ... */ });
         // Function definitions from previous step...
         const DashboardCard = React.memo(({ title, value, icon }) => (
           <div className="bg-surface p-3 rounded-lg border border-border-color flex items-center">
             <div className="text-2xl text-primary mr-3">{icon}</div>
             <div><h4 className="text-xs font-semibold text-text-secondary uppercase tracking-wider">{title}</h4><p className="text-xl font-bold text-text-primary">{value}</p></div>
           </div>
         ));
         const Dashboard = React.memo(({ reviewCount, trackingCount, archivedCount, editsCount }) => (
           <section id="dashboard" className="grid grid-cols-2 sm:grid-cols-4 gap-3 sm:gap-4">
             <DashboardCard title="En Revisión" value={reviewCount} icon={'📋'} /><DashboardCard title="Seguimiento" value={trackingCount} icon={'⏳'} />
             <DashboardCard title="Archivados" value={archivedCount} icon={'🗄️'} /><DashboardCard title="Edits Pendientes" value={editsCount} icon={'✏️'} />
           </section>
         ));

        // =================================================================================
        // INLINED: components/DataInputArea.tsx - *** REMOVED React.memo ***
        // =================================================================================
        function DataInputArea({ // Removed React.memo wrapper
          id,
          title,
          headers,
          data,
          onDataChange,
          onProcess,
          processButtonText = "Procesar Datos",
          inputType = "paste",
        }) {
          console.log(`Rendering DataInputArea: ${id}`);

          const handlePaste = useCallback((e) => {
            e.preventDefault();
            const pastedText = e.clipboardData.getData('text/plain');
            const newRows = processPastedData(pastedText, headers);
            const currentData = Array.isArray(data) ? data : [];
            const filteredCurrent = currentData.filter(row => row && Object.values(row).some(val => String(val).trim() !== ''));
            const updatedData = [...filteredCurrent, ...newRows];
            if (inputType === 'paste') {
              const emptyRowCount = updatedData.filter(row => !row || !Object.values(row).some(val => String(val).trim() !== '')).length;
              const targetEmptyRows = 5;
              if (emptyRowCount < targetEmptyRows) { for (let i = 0; i < (targetEmptyRows - emptyRowCount); i++) { updatedData.push({}); } }
            }
            onDataChange(updatedData);
          }, [data, headers, onDataChange, inputType]);

          const handleCellChange = useCallback((rowIndex, header, value) => {
            const currentData = Array.isArray(data) ? data : [];
            const newData = [...currentData];
            if (newData[rowIndex]) { newData[rowIndex] = { ...newData[rowIndex], [header]: value }; }
            else { console.warn(`Edit non-existent row: ${rowIndex}`); return; }
            if (inputType === 'paste') {
              const targetEmptyRows = 5;
              const nonEmptyRows = newData.filter(row => row && Object.values(row).some(val => String(val).trim() !== ''));
              const currentEmptyRowCount = newData.length - nonEmptyRows.length;
              if (currentEmptyRowCount < targetEmptyRows) { for (let i = 0; i < (targetEmptyRows - currentEmptyRowCount); i++) { nonEmptyRows.push({}); } }
              const finalData = [...nonEmptyRows];
              while (finalData.filter(row => !row || !Object.values(row).some(val => String(val).trim() !== '')).length > targetEmptyRows && finalData.length > targetEmptyRows) {
                 const lastEmptyIndex = finalData.findLastIndex(row => !row || !Object.values(row).some(val => String(val).trim() !== ''));
                 if (lastEmptyIndex !== -1) { finalData.splice(lastEmptyIndex, 1); } else { break; }
              } onDataChange(finalData);
            } else { onDataChange(newData); }
          }, [data, onDataChange, inputType]);

          const handleFileChange = useCallback((e) => {
             // ... (handleFileChange logic remains the same) ...
              const file = e.target.files[0];
              if (!file) return;
              const reader = new FileReader();
              reader.onload = (event) => {
                  try {
                      const fileData = new Uint8Array(event.target.result);
                      const workbook = XLSX.read(fileData, { type: 'array', cellDates: true, dateNF: 'yyyy-mm-dd' });
                      const sheetName = workbook.SheetNames[0];
                      const worksheet = workbook.Sheets[sheetName];
                      const headerRow = XLSX.utils.sheet_to_json(worksheet, { header: 1, range: 0, raw: false, defval: '' })[0] || [];
                      const excelHeaders = headerRow.map(h => String(h).trim());
                      const jsonDataObjects = XLSX.utils.sheet_to_json(worksheet, { raw: false, defval: '' });
                      if (jsonDataObjects.length === 0) { alert("Archivo Excel vacío."); onDataChange([]); e.target.value = null; return; }

                      const normalizeHeadersAndData = (d) => {
                          const keyMap = { /* ... same keyMap ... */
                            'fecha neg.': 'Fecha_Neg', 'no. orden': 'No_Orden', 'no. cédula': 'No_Cedula', 'entidad ejecutora': 'Entidad_Ejecutora', 'motivo negación': 'Motivo_Negacion', 'usuario emitió': 'Usuario_Emitio', 'observación auditor': 'Observacion_Auditor', 'observación ejecutivo': 'Observacion_Ejecutivo', 'antigüedad': 'Antiguedad', 'teléfono': 'Telefono', 'dirección': 'Direccion', 'tipo usuario': 'Tipo_Usuario', 'notificación': 'Notificacion', 'gestión': 'Gestion_Negacion', 'observación alternativa': 'Observacion_Alternativa', 'nit prestador': 'Nit_Prestador', 'fecha complementariedad': 'Fecha_Complementariedad', 'tiempo de gestion': 'Tiempo_de_Gestion', 'sucursal': 'Sucursal', 'nombre': 'Nombre', 'programa': 'Programa', 'plan': 'Plan', 'eps': 'EPS', 'celular': 'Celular', 'email': 'Email', 'edad': 'Edad', 'llamada': 'Llamada', 'complementariedad': 'Complementariedad', 'alternativa': 'Alternativa', 'monto': 'Monto', 'regional': 'Regional'
                          };
                          const dateKeysInternal = new Set(['Fecha_Neg', 'Fecha_Complementariedad']);
                          const parseDateValue = (value) => { /* ... same parseDateValue ... */
                             if (value === null || value === undefined || String(value).trim() === '') return '';
                             if (typeof value === 'number') { try { const jsDate = XLSX.SSF.parse_date_code(value); if (jsDate && jsDate.y >= 1900) return `${jsDate.y}-${String(jsDate.m).padStart(2, '0')}-${String(jsDate.d).padStart(2, '0')}`; } catch (e) { console.warn("Err parse date num:", value, e); } }
                             else if (typeof value === 'string') { if (/^\d{4}-\d{2}-\d{2}(T.*)?$/.test(value)) return value.substring(0, 10); try { const parts = value.match(/(\d{1,2})[/-](\d{1,2})[/-](\d{4})/); if (parts) { const y = parseInt(parts[3], 10), m = parseInt(parts[2], 10), d = parseInt(parts[1], 10); if (y >= 1900 && m >= 1 && m <= 12 && d >= 1 && d <= 31) return `${y}-${String(m).padStart(2, '0')}-${String(d).padStart(2, '0')}`; } const parsed = new Date(value); if (!isNaN(parsed) && parsed.getFullYear() >= 1900) return parsed.toISOString().slice(0, 10); } catch (e) { console.warn("Err parse date str:", value, e); } }
                             console.warn("Returning date as str:", value); return String(value);
                          };
                          return d.map(row => { const newRow = {}; PORTAL_HEADERS.forEach(h => newRow[h] = ''); for (const k in row) { const iKey = keyMap[String(k).trim().toLowerCase()]; if (iKey) { const val = row[k]; newRow[iKey] = dateKeysInternal.has(iKey) ? parseDateValue(val) : (val != null ? String(val) : ''); } } return newRow; });
                      };

                      const normalizedData = normalizeHeadersAndData(jsonDataObjects);
                      onDataChange(normalizedData);
                  } catch (error) { console.error("Error processing Excel:", error); alert("Error al procesar Excel:\n" + error.message); onDataChange([]);
                  } finally { if(e.target) e.target.value = null; }
              };
              reader.onerror = (error) => { console.error("Error reading file:", error); alert("Error al leer archivo."); onDataChange([]); if(e.target) e.target.value = null; };
              reader.readAsArrayBuffer(file);
          }, [onDataChange, headers]); // headers needed? only for processPastedData called inside? No, headers aren't used here.

          const clearTable = useCallback(() => {
            if (inputType === 'file' && data.length > 0 && data.some(row => Object.values(row).some(v=>v))) {
                if (!window.confirm("¿Limpiar datos cargados del archivo?")) return;
            }
            onDataChange(inputType === 'paste' ? Array(5).fill({}) : []);
          }, [inputType, onDataChange, data]);

          const renderData = useMemo(() => Array.isArray(data) ? data : (inputType === 'paste' ? Array(5).fill({}) : []), [data, inputType]);

          // THE RETURN JSX - This is where the error occurred before
          return (
            <section id={id} className="space-y-4">
              <h2 className="text-xl font-bold text-primary border-b border-border-color pb-2">{title}</h2>
              {inputType === 'file' && ( /* File Input UI */
                 <div className="flex items-center gap-4">
                   <label htmlFor={`${id}-file-upload`} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-3 rounded-lg transition-colors cursor-pointer text-sm">Subir Excel</label>
                   <input id={`${id}-file-upload`} type="file" className="hidden" accept=".xlsx, .xls, .csv" onChange={handleFileChange} />
                   <span className="text-text-secondary text-sm">{renderData.length > 0 && renderData.some(row => Object.values(row).some(v=>String(v).trim() !== '')) ? `${renderData.filter(row => Object.values(row).some(v=>String(v).trim() !== '')).length} fila(s)` : 'Ningún archivo'}</span>
                 </div>
              )}
              <div className="table-container max-h-60 overflow-auto border border-border-color rounded-lg bg-background/20">
                <table className="w-full text-xs text-left text-text-secondary table-fixed border-collapse">
                  <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                    <tr>
                      {/* THIS IS THE LINE (approx 683) THAT CAUSED THE ERROR */}
                      {headers.map(header => (
                        <th key={header} scope="col" className="px-3 py-2 whitespace-nowrap overflow-hidden text-ellipsis w-32 font-semibold border-r border-border-color/30 last:border-r-0">{header.replace(/_/g, ' ')}</th>
                      ))}
                      {/* END OF PROBLEMATIC LINE MAPPING */}
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-border-color/30" onPaste={inputType === 'paste' ? handlePaste : undefined}>
                    {renderData.map((row, rowIndex) => (
                      <tr key={rowIndex} className="group hover:bg-highlight">
                        {headers.map(header => (
                          <td key={`${rowIndex}-${header}`} className="px-3 py-1 border-r border-border-color/30 last:border-r-0 outline-none whitespace-nowrap overflow-hidden text-ellipsis w-32 focus-within:bg-primary/20 focus-within:text-white group-hover:whitespace-normal group-focus-within:whitespace-normal"
                              contentEditable={inputType === 'paste'} onBlur={inputType === 'paste' ? (e) => handleCellChange(rowIndex, header, e.currentTarget.innerText) : undefined} suppressContentEditableWarning={true}
                          >{(row && row[header] != null) ? String(row[header]) : ''}</td>
                        ))}
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
              <div className="flex gap-3">
                <button onClick={onProcess} disabled={renderData.length === 0 || renderData.every(row => !row || !Object.values(row).some(val => String(val).trim() !== ''))} className="bg-primary hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-sm">{processButtonText}</button>
                <button onClick={clearTable} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-3 rounded-lg transition-colors text-sm">Limpiar Tabla</button>
              </div>
            </section>
          );
        } // End of DataInputArea

        // =================================================================================
        // INLINED: components/ReviewArea.tsx - Already memoized
        // =================================================================================
        const ReviewArea = React.memo(({ data, templates, updateRow, incrementEdits, onSendToTracking, onPreview, onExportForMailMerge, onClearReviewData, sortConfig, setSortConfig }) => { /* ... */ });
         // Function definition from previous step...
         const ReviewArea = React.memo(({ data, templates, updateRow, incrementEdits, onSendToTracking, onPreview, onExportForMailMerge, onClearReviewData, sortConfig, setSortConfig }) => {
             console.log("Rendering ReviewArea");
             const [selectedRows, setSelectedRows] = useState(new Set());
             const [filter, setFilter] = useState('');
             const REVIEW_HEADERS = useMemo(() => [ { key: 'Fecha_Neg', label: 'Fecha Neg.', width: 'w-24' }, { key: 'No_Orden', label: 'No. Orden', width: 'w-24' }, { key: 'No_Cedula', label: 'No. Cédula', width: 'w-28' }, { key: 'Nombre', label: 'Nombre', width: 'w-48 flex-1 min-w-[12rem]' }, { key: 'EPS', label: 'EPS', width: 'w-32' }, { key: 'Programa', label: 'Prog.', width: 'w-28', compact: true }, { key: 'Motivo_Negacion', label: 'Motivo', width: 'w-40', compact: true }, { key: 'Descripcion_PDF', label: 'Desc.', width: 'w-40', compact: true }, { key: 'Justificacion_PDF', label: 'Just.', width: 'w-40', compact: true }, { key: 'Fundamento_Legal_PDF', label: 'Fund.', width: 'w-36', compact: true }, ], []);
             const currentData = useMemo(() => Array.isArray(data) ? data : [], [data]);
             const filteredData = useMemo(() => { if (!filter) return currentData; const lcf = filter.toLowerCase(); try { return currentData.filter(r => r && typeof r === 'object' && Object.values(r).some(v => String(v).toLowerCase().includes(lcf))); } catch (e) { console.error("Filter error:", e); return currentData; } }, [currentData, filter]);
             useEffect(() => { const keys = new Set(filteredData.map(r => r ? String(r.No_Orden) : null).filter(Boolean)); setSelectedRows(prev => { const n = new Set(); for (const k of prev) { if (keys.has(k)) n.add(k); } return (n.size !== prev.size || ![...n].every(k => prev.has(k))) ? n : prev; }); }, [filteredData]);
             const handleSelectRow = useCallback((noOrden) => { const k = String(noOrden); setSelectedRows(p => { const n = new Set(p); if (n.has(k)) n.delete(k); else n.add(k); return n; }); }, []);
             const handleSelectAll = useCallback((e) => { setSelectedRows(e.target.checked ? new Set(filteredData.map(r => r ? String(r.No_Orden) : null).filter(Boolean)) : new Set()); }, [filteredData]);
             const handleCellBlur = useCallback((noOrden, key, rawValue) => { const v = String(rawValue || '').trim(); const oRow = currentData.find(r => r && String(r.No_Orden) === String(noOrden)); if (oRow && v !== String(oRow[key] || '').trim()) { console.log(`Blur Update: ${noOrden}, ${key}, "${v}"`); updateRow(noOrden, { [key]: v }); } }, [currentData, updateRow]);
             const handleSelectChange = useCallback((noOrden, value) => { const changes = { Tipo_Carta: value }; const safeT = Array.isArray(templates) ? templates : []; const tmpl = safeT.find(t => t.id === value); const oRow = currentData.find(r => r && String(r.No_Orden) === String(noOrden)); const curRad = oRow?.Radicado_Comp || ''; if (!tmpl || !tmpl.name.toUpperCase().includes('COMPLEMENTARIEDAD')) { if (curRad !== '') changes.Radicado_Comp = ''; } if (oRow && oRow.Tipo_Carta !== value) updateRow(noOrden, changes); else if (changes.Radicado_Comp === '' && curRad !== '') updateRow(noOrden, changes); }, [templates, currentData, updateRow]);
             const requestSort = useCallback((key) => { setSortConfig(cs => ({ key, direction: (cs.key === key && cs.direction === 'ascending') ? 'descending' : 'ascending' })); }, [setSortConfig]);
             const getSortIndicator = useCallback((key) => (sortConfig.key !== key ? ' ' : (sortConfig.direction === 'ascending' ? '▲' : '▼')), [sortConfig]);
             const handleExport = useCallback(() => { onExportForMailMerge(currentData); }, [onExportForMailMerge, currentData]);

             return ( /* ... ReviewArea JSX ... */
               <section id="area3" className="space-y-4">
                 <h2 className="text-xl font-bold text-primary border-b border-border-color pb-2">Área 3: Revisión Final y Exportación</h2>
                 <div className="action-bar bg-highlight p-3 rounded-lg flex flex-wrap items-center gap-4 justify-between text-sm"> <input type="text" placeholder="Buscar en tabla..." className="bg-surface border border-border-color rounded-md px-3 py-1 text-text-primary placeholder-text-secondary w-full sm:w-auto text-sm" value={filter} onChange={(e) => setFilter(e.target.value)} aria-label="Buscar revisión" /> <span className="text-text-primary whitespace-nowrap">{selectedRows.size} sel. / {currentData.length} total</span> </div>
                 <div className="table-container max-h-[65vh] overflow-auto border border-border-color rounded-lg bg-background/20">
                   <table className="w-full text-xs text-left text-text-secondary table-fixed border-collapse">
                     <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                       <tr>
                         <th className="px-2 py-2 w-8"><input type="checkbox" onChange={handleSelectAll} checked={filteredData.length > 0 && selectedRows.size === filteredData.length} disabled={filteredData.length === 0} title="Seleccionar Visible" aria-label="Seleccionar todo" /></th>
                         <th className="px-2 py-2 w-8">👁️</th>
                         {REVIEW_HEADERS.map(({ key, label, width }) => (<th key={key} onClick={() => requestSort(key)} className={`px-2 py-2 cursor-pointer whitespace-nowrap overflow-hidden text-ellipsis ${width} font-semibold border-l border-border-color/30`} title={`Ordenar ${label}`}>{label}<span className="ml-1">{getSortIndicator(key)}</span></th>))}
                         <th className="px-2 py-2 w-48 font-semibold border-l border-border-color/30">Tipo de Carta</th>
                       </tr>
                     </thead>
                     <tbody className="divide-y divide-border-color/30">
                       {filteredData.length > 0 ? filteredData.map((row) => { /* ... row rendering logic ... */
                           if (!row || typeof row !== 'object' || !row.No_Orden) return <tr key={`invalid-${Math.random()}`}><td colSpan={REVIEW_HEADERS.length + 3} className="text-center text-danger py-1">Fila inválida</td></tr>;
                           const noOrdenKey = String(row.No_Orden); const safeTemplates = Array.isArray(templates) ? templates : []; const template = safeTemplates.find(t => t.id === row.Tipo_Carta); const isComp = template && template.name.toUpperCase().includes('COMPLEMENTARIEDAD'); const reqRad = isComp; const isSel = selectedRows.has(noOrdenKey);
                           return ( <tr key={noOrdenKey} className={`group ${isComp ? 'bg-indigo-900/10' : ''} ${isSel ? 'bg-primary/20 hover:bg-primary/30' : 'hover:bg-highlight/50'}`}>
                             <td className="px-2 py-1 text-center"><input type="checkbox" checked={isSel} onChange={() => handleSelectRow(noOrdenKey)} /></td>
                             <td className="px-2 py-1 text-base cursor-pointer text-center" onClick={() => onPreview(row)} title="Vista Previa">👁️</td>
                             {REVIEW_HEADERS.map(({ key, width }) => (<td key={key} className={`px-2 py-1 border-l border-border-color/30 outline-none whitespace-nowrap overflow-hidden text-ellipsis focus-within:bg-primary/20 focus-within:text-white group-hover:whitespace-normal group-focus-within:whitespace-normal ${width}`} contentEditable onBlur={(e) => handleCellBlur(row.No_Orden, key, e.currentTarget.innerText)} suppressContentEditableWarning={true} title={String(row[key] ?? '')}>{String(row[key] ?? '')}</td>))}
                             <td className="px-2 py-1 w-48 border-l border-border-color/30"> <div className="flex flex-col gap-1"> <select value={row.Tipo_Carta || ''} onChange={(e) => handleSelectChange(row.No_Orden, e.target.value)} className="bg-surface border border-border-color rounded px-1 py-0.5 text-text-primary w-full text-xs"> <option value="">-- Seleccionar --</option> {safeTemplates.map(t => <option key={t.id} value={t.id} title={t.name}>{t.name}</option>)} </select> {reqRad && ( <input type="text" placeholder="Radicado Comp..." value={row.Radicado_Comp || ''} onChange={(e) => updateRow(row.No_Orden, { Radicado_Comp: e.target.value.trim() })} className="bg-surface border border-border-color rounded px-1 py-0.5 text-text-primary w-full mt-1 text-xs" /> )} </div> </td>
                           </tr> );
                       }) : (<tr><td colSpan={REVIEW_HEADERS.length + 3} className="text-center py-4 text-text-secondary italic">No hay casos en revisión{filter ? ' que coincidan.' : '.'}</td></tr>)}
                     </tbody>
                   </table>
                 </div>
                 <div className="flex flex-wrap gap-3 text-sm"> <button onClick={() => onSendToTracking(Array.from(selectedRows))} disabled={selectedRows.size === 0} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Enviar a Seg. ({selectedRows.size})</button> <button onClick={handleExport} disabled={currentData.length === 0} className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Exportar p/ Mail ({currentData.length})</button> <button onClick={onClearReviewData} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-3 rounded-lg transition-colors">Limpiar Tabla</button> </div>
               </section>
             );
         });

        // =================================================================================
        // INLINED: components/TrackingArea.tsx - Already memoized
        // =================================================================================
        const TrackingTable = React.memo(({ data, isArchived, onUpdate, onArchive, filter }) => { /* ... */ });
        const TrackingArea = React.memo(({ trackingData, archivedData, updateTrackingData, archiveItems }) => { /* ... */ });
         // Function definitions from previous step...
         const TrackingTable = React.memo(({ data, isArchived, onUpdate, onArchive, filter }) => {
             console.log(`Rendering TrackingTable (Archived: ${isArchived})`);
             const [selectedRows, setSelectedRows] = useState(new Set());
             const statusClasses = useMemo(() => ({ 'Pendiente': 'bg-yellow-900/30', 'En Gestión': 'bg-blue-900/30', 'Finalizado': 'bg-green-900/30' }), []);
             const currentData = useMemo(() => Array.isArray(data) ? data : [], [data]);
             const filteredData = useMemo(() => { if (!filter) return currentData; const lcf = filter.toLowerCase(); try { return currentData.filter(r => r && typeof r === 'object' && Object.values(r).some(v => String(v).toLowerCase().includes(lcf))); } catch (e) { console.error("Filter error TT:", e); return currentData; } }, [currentData, filter]);
             useEffect(() => { const indices = new Set(filteredData.map(r => currentData.indexOf(r)).filter(i => i !== -1)); setSelectedRows(p => { const n = new Set(); for (const i of p) { if (indices.has(i)) n.add(i); } return (n.size !== p.size || ![...n].every(i => p.has(i))) ? n : p; }); }, [filteredData, currentData]);
             const handleSelectRow = useCallback((index) => { setSelectedRows(p => { const n = new Set(p); if (n.has(index)) n.delete(index); else n.add(index); return n; }); }, []);
             const handleSelectAll = useCallback((e) => { setSelectedRows(e.target.checked ? new Set(filteredData.map(r => currentData.indexOf(r)).filter(i => i !== -1)) : new Set()); }, [filteredData, currentData]);
             const handleBulkArchive = useCallback(() => { if (selectedRows.size > 0) { onArchive(Array.from(selectedRows)); setSelectedRows(new Set()); } }, [selectedRows, onArchive]);
             const handleCellUpdate = useCallback((idx, field, value) => { const row = currentData[idx]; const pVal = field === 'Notas' ? String(value || '').trim() : value; if (row && String(row[field] || '') !== pVal) { onUpdate(idx, { ...row, [field]: pVal }, isArchived); } }, [currentData, onUpdate, isArchived]);

             return ( /* ... TrackingTable JSX ... */
               <div className="space-y-3">
                 <div className="flex justify-between items-center text-sm"> <span className="text-text-secondary">{filteredData.length} fila(s){selectedRows.size > 0 ? `, ${selectedRows.size} sel.` : ''}</span> {selectedRows.size > 0 && (<button onClick={handleBulkArchive} className={`font-bold py-1 px-3 rounded transition-colors text-white text-xs ${isArchived ? 'bg-green-600 hover:bg-green-700' : 'bg-gray-600 hover:bg-gray-700'}`}>{isArchived ? `♻️ Restaurar (${selectedRows.size})` : `🗄️ Archivar (${selectedRows.size})`}</button>)} </div>
                 <div className="table-container max-h-[40vh] overflow-auto border border-border-color rounded-lg bg-background/20">
                   <table className="w-full text-xs text-left text-text-secondary table-fixed border-collapse">
                     <thead className="text-xs text-text-primary uppercase bg-header sticky top-0 z-10">
                       <tr>
                         <th className="px-2 py-2 w-8"><input type="checkbox" onChange={handleSelectAll} checked={filteredData.length > 0 && selectedRows.size === filteredData.length} disabled={filteredData.length === 0} title="Seleccionar Visible" /></th>
                         <th className="px-2 py-2 w-24 font-semibold border-l border-border-color/30">Fecha Ing.</th> <th className="px-2 py-2 w-24 font-semibold border-l border-border-color/30">No. Orden</th> <th className="px-2 py-2 w-40 font-semibold border-l border-border-color/30">Nombre</th> <th className="px-2 py-2 w-28 font-semibold border-l border-border-color/30">EPS</th> <th className="px-2 py-2 w-28 font-semibold border-l border-border-color/30">Radicado</th> <th className="px-2 py-2 w-28 font-semibold border-l border-border-color/30">Estado</th> <th className="px-2 py-2 flex-1 min-w-[150px] font-semibold border-l border-border-color/30">Notas</th> <th className="px-2 py-2 w-12 font-semibold border-l border-border-color/30">Acción</th>
                       </tr>
                     </thead>
                     <tbody className="divide-y divide-border-color/30">
                       {filteredData.length > 0 ? filteredData.map((row) => { /* ... row rendering logic ... */
                           const idx = currentData.indexOf(row); if (!row || typeof row !== 'object' || idx === -1) return null; const isSel = selectedRows.has(idx); const rowCls = `group ${isArchived ? 'bg-black/10 text-text-secondary italic' : statusClasses[row.Estado] || ''} ${isSel ? '!bg-primary/30 hover:!bg-primary/40' : 'hover:bg-highlight/50'}`;
                           return ( <tr key={idx} className={rowCls}>
                             <td className="px-2 py-1 text-center"><input type="checkbox" checked={isSel} onChange={() => handleSelectRow(idx)} /></td>
                             <td className="px-2 py-1 w-24 whitespace-nowrap">{row.Fecha_Ing || ''}</td> <td className="px-2 py-1 w-24 whitespace-nowrap">{row.No_Orden || ''}</td> <td className="px-2 py-1 w-40 whitespace-nowrap overflow-hidden text-ellipsis" title={row.Nombre}>{row.Nombre || ''}</td> <td className="px-2 py-1 w-28 whitespace-nowrap overflow-hidden text-ellipsis" title={row.EPS}>{row.EPS || ''}</td> <td className="px-2 py-1 w-28 whitespace-nowrap overflow-hidden text-ellipsis" title={row.Radicado}>{row.Radicado || ''}</td>
                             <td className="px-2 py-1 w-28"> <select value={row.Estado || TRACKING_STATUSES[0]} onChange={e => handleCellUpdate(idx, 'Estado', e.target.value)} className={`bg-surface/50 border border-border-color/50 rounded px-1 py-0.5 w-full text-xs ${isArchived ? 'text-gray-400' : 'text-text-primary'}`} disabled={isArchived}> {TRACKING_STATUSES.map(s => <option key={s} value={s}>{s}</option>)} </select> </td>
                             <td className={`px-2 py-1 outline-none min-w-[150px] focus-within:bg-primary/20 focus-within:text-white group-hover:whitespace-normal group-focus-within:whitespace-normal ${isArchived ? '' : 'hover:bg-black/20'}`} contentEditable={!isArchived} onBlur={e => handleCellUpdate(idx, 'Notas', e.currentTarget.innerText)} suppressContentEditableWarning={true} title={row.Notas}>{row.Notas || ''}</td>
                             <td className="px-2 py-1 text-base cursor-pointer w-12 text-center" onClick={() => onArchive([idx])} title={isArchived ? 'Restaurar' : 'Archivar'}>{isArchived ? '♻️' : '🗄️'}</td>
                           </tr> );
                       }) : (<tr><td colSpan={9} className="text-center py-4 text-text-secondary italic">{isArchived ? 'No hay casos archivados' : 'No hay casos activos'}{filter ? ' que coincidan.' : '.'}</td></tr>)}
                     </tbody>
                   </table>
                 </div>
               </div>
             );
         });
         const TrackingArea = React.memo(({ trackingData, archivedData, updateTrackingData, archiveItems }) => {
           console.log("Rendering TrackingArea"); const [showArchived, setShowArchived] = useState(false); const [filter, setFilter] = useState(''); const ctd = useMemo(() => Array.isArray(trackingData) ? trackingData : [], [trackingData]); const cad = useMemo(() => Array.isArray(archivedData) ? archivedData : [], [archivedData]);
           return ( /* ... TrackingArea JSX ... */
             <section id="area4" className="space-y-4">
               <h2 className="text-xl font-bold text-primary border-b border-border-color pb-2">Área 4: Seguimiento</h2>
               <div className="action-bar bg-highlight p-3 rounded-lg flex flex-wrap items-center gap-4 justify-between text-sm"> <input type="text" placeholder="Buscar en Seguimiento..." className="bg-surface border border-border-color rounded-md px-3 py-1 text-text-primary placeholder-text-secondary w-full sm:w-1/2 lg:w-1/3 text-sm" value={filter} onChange={e => setFilter(e.target.value)} aria-label="Buscar seguimiento" /> <button onClick={() => setShowArchived(!showArchived)} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-3 rounded-lg text-xs sm:text-sm">{showArchived ? 'Ocultar' : 'Mostrar'} Archivados ({cad.length})</button> </div>
               <h3 className="text-lg font-semibold text-white">Casos Activos ({ctd.length})</h3>
               <TrackingTable data={ctd} isArchived={false} onUpdate={updateTrackingData} onArchive={archiveItems} filter={filter} />
               {showArchived && (<div className="mt-6"> <h3 className="text-lg font-semibold text-text-secondary">Casos Archivados ({cad.length})</h3> <TrackingTable data={cad} isArchived={true} onUpdate={updateTrackingData} onArchive={archiveItems} filter={filter} /> </div>)}
             </section>
           );
         });

        // =================================================================================
        // INLINED: components/SetupModal.tsx - No changes needed
        // =================================================================================
        const SetupModal = ({ onSave, onClose, initialUrl = '' }) => { /* ... */ };
         // Function definition from previous step...
         const SetupModal = ({ onSave, onClose, initialUrl = '' }) => {
             const [url, setUrl] = useState(initialUrl); const [isVerifying, setIsVerifying] = useState(false); const [errorMsg, setErrorMsg] = useState('');
             const handleSave = async () => { setErrorMsg(''); if (!url || !url.startsWith('https://script.google.com/macros/s/')) { setErrorMsg("URL inválida (debe empezar con https://script.google.com/macros/s/)."); return; } setIsVerifying(true); try { await onSave(url); } catch (error) { console.error("Verify failed:", error); setErrorMsg(`Falló: ${error.message}. Revisa URL/permisos.`); } finally { setIsVerifying(false); } };
             return ( /* ... SetupModal JSX ... */
               <div className="fixed inset-0 bg-background bg-opacity-90 flex justify-center items-center z-[200] p-4">
                 <div className="bg-surface rounded-lg shadow-xl w-full max-w-lg border border-border-color p-8 space-y-6">
                   <div className="text-center"><h2 className="text-2xl font-bold text-primary">Configuración de Conexión</h2><p className="text-text-secondary mt-2">URL de Google Apps Script (aplicación web).</p></div>
                   <div> <label htmlFor="script-url" className="block text-sm font-medium text-text-primary mb-1">URL del Script</label> <input id="script-url" type="url" value={url} onChange={(e) => { setUrl(e.target.value); setErrorMsg(''); }} placeholder="https://script.google.com/macros/s/..." className={`w-full bg-background border rounded-md px-3 py-2 text-text-primary placeholder-text-secondary focus:ring-primary focus:border-primary ${errorMsg ? 'border-danger' : 'border-border-color'}`} aria-invalid={!!errorMsg} aria-describedby="url-error" /> {errorMsg && <p id="url-error" className="text-danger text-sm mt-1">{errorMsg}</p>} </div>
                   <div className="flex justify-end gap-4"> <button onClick={onClose} disabled={isVerifying} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Cancelar</button> <button onClick={handleSave} disabled={isVerifying || !url} className="bg-btn-primary hover:bg-btn-primary-hover text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed min-w-[150px] flex justify-center items-center">{isVerifying ? <Spinner /> : 'Guardar y Verificar'}</button> </div>
                 </div>
               </div>
             );
         };

        // =================================================================================
        // INLINED: components/TemplateManagerModal.tsx - No changes needed
        // =================================================================================
        const TemplateManagerModal = ({ templates, onClose, onSave, onReset }) => { /* ... */ };
         // Function definition from previous step...
          const TemplateManagerModal = ({ templates, onClose, onSave, onReset }) => {
            const [currentTemplates, setCurrentTemplates] = useState(() => structuredClone(Array.isArray(templates) ? templates : [])); const [editingTemplate, setEditingTemplate] = useState(null);
            const handleSaveLocal = useCallback(() => { onSave(currentTemplates); }, [currentTemplates, onSave]);
            const handleAddNew = useCallback(() => { setEditingTemplate({ id: `custom_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`, name: '', body: '' }); }, []);
            const handleEdit = useCallback((template) => { setEditingTemplate({ ...template }); }, []);
            const handleDelete = useCallback((idToDelete) => { if (window.confirm('¿Eliminar esta plantilla?')) { setCurrentTemplates(current => current.filter(t => t.id !== idToDelete)); } }, []);
            const handleSaveTemplateEdit = useCallback(() => { if (!editingTemplate || !editingTemplate.name.trim() || !editingTemplate.body.trim()) { alert('Nombre y cuerpo no pueden estar vacíos.'); return; } setCurrentTemplates(current => { const u = Array.isArray(current) ? [...current] : []; const idx = u.findIndex(t => t.id === editingTemplate.id); if (idx > -1) u[idx] = { ...editingTemplate }; else u.push({ ...editingTemplate }); return u; }); setEditingTemplate(null); }, [editingTemplate]);
            const handleEditorChange = useCallback((field, value) => { setEditingTemplate(prev => prev ? ({ ...prev, [field]: value }) : null); }, []);
            return ( /* ... TemplateManagerModal JSX ... */
              <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[250] p-4">
                <div className="bg-surface rounded-lg shadow-xl w-full max-w-4xl border border-border-color flex flex-col max-h-[90vh]">
                  <div className="p-6 border-b border-border-color flex justify-between items-center flex-shrink-0"><h3 className="text-xl font-bold text-primary">Gestionar Plantillas</h3><button onClick={onClose} className="text-text-secondary text-2xl hover:text-text-primary">&times;</button></div>
                  <div className="p-6 overflow-y-auto space-y-6 flex-grow"> <div className="grid grid-cols-1 md:grid-cols-2 gap-6 h-full">
                    <div className="flex flex-col h-full"> <div className="flex justify-between items-center mb-2"><h4 className="text-lg font-semibold">Plantillas</h4><button onClick={handleAddNew} className="bg-green-600 hover:bg-green-700 text-white text-xs font-bold py-1 px-2 rounded disabled:opacity-50" disabled={!!editingTemplate}>+ Nueva</button></div> <ul className="space-y-1 border border-border-color rounded-lg p-2 overflow-y-auto flex-grow bg-background/30"> {currentTemplates.map(t => (<li key={t.id} className={`flex justify-between items-center p-2 rounded transition-colors text-sm ${editingTemplate?.id === t.id ? 'bg-primary/30 ring-1 ring-primary' : 'bg-highlight hover:bg-highlight/70'}`}><span className="text-text-primary truncate flex-grow mr-2" title={t.name}>{t.name}</span><div className="space-x-1 flex-shrink-0"><button onClick={() => handleEdit(t)} className="text-xs bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded disabled:opacity-50" disabled={!!editingTemplate}>Editar</button><button onClick={() => handleDelete(t.id)} className="text-xs bg-danger hover:bg-danger-hover px-2 py-1 rounded disabled:opacity-50" disabled={!!editingTemplate}>Borrar</button></div></li>))} {currentTemplates.length === 0 && <li className="text-text-secondary text-center p-4 italic">No hay plantillas.</li>} </ul> </div>
                    <div className="flex flex-col h-full"> <h4 className="text-lg font-semibold mb-2">{editingTemplate ? (currentTemplates.some(t => t.id === editingTemplate.id) ? 'Editar' : 'Nueva') : 'Editor'}</h4> {editingTemplate ? (<div className="space-y-3 p-4 border border-border-color rounded-lg bg-highlight flex flex-col flex-grow"><input type="text" placeholder="Nombre" value={editingTemplate.name} onChange={(e) => handleEditorChange('name', e.target.value)} className="w-full bg-background border border-border-color rounded-md px-3 py-2 text-sm flex-shrink-0" /><textarea placeholder="Cuerpo (HTML)..." value={editingTemplate.body} onChange={(e) => handleEditorChange('body', e.target.value)} className="w-full bg-background border border-border-color rounded-md px-3 py-2 resize-y flex-grow text-sm min-h-[200px]" /><p className="text-xs text-text-secondary flex-shrink-0">Marcadores: {`{{Columna}}`}</p><div className="flex gap-2 flex-shrink-0 justify-end"><button onClick={() => setEditingTemplate(null)} className="bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded text-sm">Cancelar</button><button onClick={handleSaveTemplateEdit} className="bg-success hover:bg-green-700 px-3 py-1 rounded text-sm">Guardar</button></div></div>) : (<div className="flex items-center justify-center h-full border border-dashed border-border-color rounded-lg bg-background/30 text-text-secondary italic p-4 text-center">Selecciona o crea una plantilla.</div>)} </div>
                  </div> </div>
                  <div className="p-4 bg-header flex justify-between items-center rounded-b-lg flex-shrink-0"><button onClick={onReset} className="bg-danger hover:bg-danger-hover text-white font-bold py-2 px-4 rounded-lg text-sm disabled:opacity-50" disabled={!!editingTemplate}>Restaurar</button><div className="flex gap-4"><button onClick={onClose} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg text-sm" disabled={!!editingTemplate}>Cancelar</button><button onClick={handleSaveLocal} className="bg-success hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg text-sm" disabled={!!editingTemplate}>Guardar y Cerrar</button></div></div>
                </div>
              </div>
            );
         };

        // =================================================================================
        // INLINED: components/PreviewModal.tsx - No changes needed
        // =================================================================================
        const PreviewModal = ({ data, template, onClose }) => { /* ... */ };
         // Function definition from previous step...
         const PreviewModal = ({ data, template, onClose }) => {
             if (!data || typeof data !== 'object') { console.error("Invalid preview data:", data); return ( <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[250] p-4"><div className="bg-surface rounded-lg shadow-xl w-full max-w-lg border border-border-color p-8 text-center"><h3 className="text-xl font-bold text-danger mb-4">Error</h3><p className="text-text-secondary mb-6">Datos inválidos para vista previa.</p><button onClick={onClose} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Cerrar</button></div></div> ); }
             const bodyContent = template && template.body ? replacePlaceholders(template.body, data) : '<p class="italic text-gray-500">[Selecciona tipo de carta]</p>';
             const fullBody = `<div style="font-family: Arial, sans-serif; font-size: 14px; color: #333; line-height: 1.6;">${bodyContent}${COMMON_EMAIL_BODY}${SIGNATURE}</div>`;
             const copyText = useCallback(() => { const d = document.createElement('div'); d.innerHTML = fullBody; navigator.clipboard.writeText(d.textContent||d.innerText||"").then(()=>alert('Texto copiado!')).catch(e=>{console.error('Copy text failed:',e);alert('Error al copiar texto.');}); }, [fullBody]);
             const copyHtml = useCallback(() => { try { if (navigator.clipboard && window.ClipboardItem) { const b = new Blob([fullBody],{type:'text/html'}); const i = new ClipboardItem({'text/html':b}); navigator.clipboard.write([i]).then(()=>alert('HTML copiado!')).catch(e=>{console.error('Copy HTML failed:',e);alert('Error al copiar HTML.');}); } else { copyText(); alert("Texto copiado (HTML no soportado)."); } } catch (e) { console.error('Copy HTML error:', e); alert('Error inesperado al copiar HTML.'); } }, [fullBody, copyText]);
             return ( /* ... PreviewModal JSX ... */
               <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[250] p-4">
                 <div className="bg-white rounded-lg shadow-xl w-full max-w-3xl border border-gray-300 flex flex-col max-h-[90vh]">
                   <div className="p-4 border-b border-gray-300 flex justify-between items-center flex-shrink-0 bg-gray-100 rounded-t-lg"><h3 className="text-lg font-bold text-gray-800 truncate">Vista Previa: Orden {data.No_Orden||'N/A'}</h3><button onClick={onClose} className="text-gray-500 hover:text-gray-800 text-2xl ml-4">&times;</button></div>
                   <iframe srcDoc={fullBody} className="flex-grow overflow-y-auto border-none w-full bg-white p-4" sandbox="allow-same-origin" title={`Preview ${data.No_Orden||'N/A'}`} />
                   <div className="p-4 bg-gray-100 flex justify-end gap-3 rounded-b-lg flex-shrink-0 border-t border-gray-300"><button onClick={copyHtml} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-lg text-sm" title="Copiar HTML">Copiar HTML</button><button onClick={copyText} className="bg-blue-800 hover:bg-blue-900 text-white font-bold py-2 px-3 rounded-lg text-sm" title="Copiar Texto">Copiar Texto</button><button onClick={onClose} className="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-3 rounded-lg text-sm">Cerrar</button></div>
                 </div>
               </div>
             );
         };

        // =================================================================================
        // INLINED: App.tsx (The main application component) - No changes needed here, only in child components
        // =================================================================================
        const App = () => {
          // ... (App state and logic remains the same as previous correct version) ...
           console.log("Rendering App");
           const [state, setState] = useState({ finalData: [], trackingData: [], archivedData: [], portalData: [], pdfData: Array(5).fill({}), templates: [], scriptUrl: null, isSetupNeeded: false, isReconfiguring: false, isLoading: true, isSaving: false, isTemplateManagerOpen: false, previewData: null, notification: null, editsCount: 0, onlineStatus: true, masterTrackingOrders: new Set(), });
           const [sortConfig, setSortConfig] = useState({ key: 'Fecha_Neg', direction: 'descending' });
           const notificationTimeoutIdRef = useRef(null);
           const hideNotification = useCallback(() => { if (notificationTimeoutIdRef.current) clearTimeout(notificationTimeoutIdRef.current); setState(prev => ({ ...prev, notification: null })); }, []);
           const showNotification = useCallback((message, type = 'info', duration = 5000) => { if (notificationTimeoutIdRef.current) clearTimeout(notificationTimeoutIdRef.current); setState(prev => ({ ...prev, notification: { message, type } })); notificationTimeoutIdRef.current = setTimeout(hideNotification, duration); }, [hideNotification]);
           const handleSetScriptUrl = useCallback(async (url) => { console.log("Setting URL & fetching..."); setState(p => ({ ...p, isLoading: true, isReconfiguring: false })); try { const d = await fetchData(url); localStorage.setItem('sigweb_scriptUrl', url); setState(p => ({ ...p, finalData: d.finalData, trackingData: d.trackingData, archivedData: d.archivedData, masterTrackingOrders: new Set(d.masterTrackingOrders.map(String)), scriptUrl: url, isSetupNeeded: false, isLoading: false, editsCount: 0 })); showNotification('Conexión OK!', 'success'); console.log("Fetch OK."); } catch (e) { console.error("Set URL/Fetch Error:", e); showNotification(`Falló: ${e.message}`, 'error', 15000); setState(p => ({ ...p, isLoading: false, isSetupNeeded: true, scriptUrl: null })); localStorage.removeItem('sigweb_scriptUrl'); throw e; } }, [showNotification]);
           useEffect(() => { console.log("App mounted."); const url = localStorage.getItem('sigweb_scriptUrl'); const tmpls = loadTemplates(); setState(p => ({ ...p, templates: tmpls })); if (url) { console.log("Found URL:", url); handleSetScriptUrl(url).catch(e => console.error("Initial load failed:", e)); } else { console.log("No URL. Setup needed."); setState(p => ({ ...p, isSetupNeeded: true, isLoading: false })); } const updateOnline = () => { const isOnline = navigator.onLine; setState(p => { if (p.onlineStatus === isOnline) return p; console.log("Network:", isOnline ? "Online" : "Offline"); if (!isOnline) showNotification("Desconectado. Guardado deshabilitado.", "warning", 10000); else if (p.onlineStatus === false) showNotification("Conectado.", "success", 3000); return { ...p, onlineStatus: isOnline }; }); }; window.addEventListener('online', updateOnline); window.addEventListener('offline', updateOnline); updateOnline(); return () => { console.log("App unmounting."); window.removeEventListener('online', updateOnline); window.removeEventListener('offline', updateOnline); if (notificationTimeoutIdRef.current) clearTimeout(notificationTimeoutIdRef.current); }; }, [handleSetScriptUrl, showNotification]);
           const incrementEdits = useCallback((count = 1) => { console.log(`Incr edits by ${count}`); setState(prev => ({ ...prev, editsCount: prev.editsCount + count })); },[]);
           const handleSave = useCallback(async () => { /* ... same handleSave ... */
                console.log("Save clicked.");
                if (!state.scriptUrl) { showNotification('No URL configured.', 'error'); return; }
                if (!state.onlineStatus) { showNotification('Offline, cannot save.', 'error'); return; }
                const safeFD = Array.isArray(state.finalData) ? state.finalData : []; const safeTD = Array.isArray(state.trackingData) ? state.trackingData : []; const safeAD = Array.isArray(state.archivedData) ? state.archivedData : [];
                if (safeFD.length === 0 && state.editsCount === 0) { showNotification('Nada nuevo o modificado para guardar.', 'info'); return; }
                setState(p => ({ ...p, isSaving: true })); console.log("Saving...");
                try {
                    const payload = { action: 'saveData', payload: { finalData: safeFD, trackingData: safeTD, archivedData: safeAD } };
                    await saveData(state.scriptUrl, payload);
                    const newOrders = new Set(state.masterTrackingOrders);
                    [...safeFD, ...safeTD, ...safeAD].forEach(r => { if (r && r.No_Orden) newOrders.add(String(r.No_Orden).trim()); });
                    showNotification('Datos enviados (no verificado).', 'success'); console.log("Save sent. Updated master locally.");
                    setState(p => ({ ...p, editsCount: 0, masterTrackingOrders: newOrders, finalData: [] })); // Clear review area
                } catch (e) { console.error("Save Error:", e); showNotification(`Falló guardado: ${e.message}`, 'error', 10000);
                } finally { setState(p => ({ ...p, isSaving: false })); console.log("Save finished."); }
           }, [state.scriptUrl, state.onlineStatus, state.finalData, state.trackingData, state.archivedData, state.masterTrackingOrders, state.editsCount, showNotification]);
           const processPortalData = useCallback(() => { /* ... same processPortalData ... */
                console.log("Processing portal..."); const data = Array.isArray(state.portalData) ? state.portalData.filter(r => r && Object.values(r).some(v => String(v).trim() !== '')) : [];
                if (data.length === 0) { showNotification("No hay datos válidos del archivo.", "warning"); setState(p => ({ ...p, portalData: [] })); return; }
                const newRows = data.filter(r => { const k = r && r.No_Orden ? String(r.No_Orden).trim() : null; return k && !state.masterTrackingOrders.has(k); });
                const dups = data.length - newRows.length; console.log(`${newRows.length} new, ${dups} dups.`);
                const processed = newRows.map(r => ({ ...r, Nombre: capitalizeWords(r.Nombre || ''), EPS: (r.EPS || '').toUpperCase(), Descripcion_PDF: r.Descripcion_PDF || '(p)', Justificacion_PDF: r.Justificacion_PDF || '(p)', Fundamento_Legal_PDF: r.Fundamento_Legal_PDF || '(p)', Tipo_Carta: r.Tipo_Carta || '', Radicado_Comp: r.Radicado_Comp || '' }));
                setState(p => ({ ...p, finalData: [...(Array.isArray(p.finalData)?p.finalData:[]), ...processed], portalData: [] }));
                let msg = `${processed.length} filas añadidas a Revisión.`; if (dups > 0) msg += ` ${dups} omitidas (ya existen).`; showNotification(msg, processed.length > 0 ? 'success' : 'info');
           }, [state.portalData, state.masterTrackingOrders, state.finalData, showNotification]);
           const mergePdfData = useCallback(() => { /* ... same mergePdfData ... */
                 console.log("Merging PDF..."); const pdfData = Array.isArray(state.pdfData) ? state.pdfData.filter(r => r && Object.values(r).some(v => String(v).trim() !== '')) : [];
                 if (pdfData.length === 0) { showNotification("No hay datos PDF para combinar.", "warning"); setState(p => ({ ...p, pdfData: Array(5).fill({}) })); return; }
                 const pdfMap = new Map(); pdfData.filter(r => r && r['Archivo (No. Orden)'] && String(r['Archivo (No. Orden)']).trim()).forEach(r => { const k = String(r['Archivo (No. Orden)']).trim(); if (k) pdfMap.set(k, { Descripcion_PDF: String(r['Descripción']||'').trim(), Justificacion_PDF: String(r['Justificación']||'').trim(), Fundamento_Legal_PDF: String(r['Fundamento Legal']||'').trim() }); });
                 console.log(`PDF map size: ${pdfMap.size}`);
                 const finalData = Array.isArray(state.finalData) ? state.finalData : []; let merges = 0;
                 const merged = finalData.map(fRow => { const k = fRow && fRow.No_Orden ? String(fRow.No_Orden).trim() : null; if (k) { const pMatch = pdfMap.get(k); if (pMatch) { let u = false; const nRow = {...fRow}; if (pMatch.Descripcion_PDF && pMatch.Descripcion_PDF !== '(p)' && pMatch.Descripcion_PDF !== fRow.Descripcion_PDF) { nRow.Descripcion_PDF = pMatch.Descripcion_PDF; u = true; } if (pMatch.Justificacion_PDF && pMatch.Justificacion_PDF !== '(p)' && pMatch.Justificacion_PDF !== fRow.Justificacion_PDF) { nRow.Justificacion_PDF = pMatch.Justificacion_PDF; u = true; } if (pMatch.Fundamento_Legal_PDF && pMatch.Fundamento_Legal_PDF !== '(p)' && pMatch.Fundamento_Legal_PDF !== fRow.Fundamento_Legal_PDF) { nRow.Fundamento_Legal_PDF = pMatch.Fundamento_Legal_PDF; u = true; } if (u) { merges++; return nRow; } } } return fRow; });
                 if (merges > 0) { setState(p => ({ ...p, finalData: merged, pdfData: Array(5).fill({}), editsCount: p.editsCount + merges })); showNotification(`${merges} fila(s) actualizadas con PDF.`, 'success'); console.log(`Merged ${merges} rows.`); }
                 else { setState(p => ({ ...p, pdfData: Array(5).fill({}) })); showNotification('No se encontraron datos nuevos del PDF para combinar.', 'info'); console.log('No PDF merges.'); }
           }, [state.pdfData, state.finalData, showNotification]);
           const updateFinalDataRow = useCallback((noOrden, partialUpdate) => { /* ... same updateFinalDataRow ... */
                const key = String(noOrden); setState(p => { const d = Array.isArray(p.finalData) ? p.finalData : []; let u = false; const nD = d.map(r => { if (r && String(r.No_Orden) === key) { const c = Object.keys(partialUpdate).some(k => String(r[k]??'') !== String(partialUpdate[k]??'')); if (c) { u = true; return { ...r, ...partialUpdate }; } } return r; }); if (u) { console.log(`Updating final row ${key}`); return { ...p, finalData: nD, editsCount: p.editsCount + 1 }; } return p; });
           }, []);
           const handleClearReviewData = useCallback(() => { /* ... same handleClearReviewData ... */
                const d = Array.isArray(state.finalData) ? state.finalData : []; if (d.length === 0) { showNotification("Revisión ya está vacía.", "info"); return; }
                if (window.confirm("¿Limpiar tabla Revisión? Datos no guardados se perderán.\nNO afecta Google Sheets.")) { setState(p => ({ ...p, finalData: [] })); showNotification("Tabla Revisión limpiada.", "info"); }
           }, [showNotification, state.finalData]);
           const handleSendToTracking = useCallback((selectedKeys) => { /* ... same handleSendToTracking ... */
                console.log("Sending to tracking:", selectedKeys); const fData = Array.isArray(state.finalData) ? state.finalData : []; const tpls = Array.isArray(state.templates) ? state.templates : []; let skipped = 0;
                const items = fData.filter(r => r && selectedKeys.includes(String(r.No_Orden))).filter(r => { const t = tpls.find(t => t.id === r.Tipo_Carta); const hc = t && t.name.toUpperCase().includes('COMPLEMENTARIEDAD'); const hr = r.Radicado_Comp && String(r.Radicado_Comp).trim() !== ''; if (hc && !hr) skipped++; return hc && hr; });
                if (skipped > 0) showNotification(`${skipped} caso(s) omitido(s) por falta de Radicado.`, 'warning', 7000);
                if (items.length === 0) { showNotification(skipped > 0 ? "Ningún otro ítem cumplió criterios." : "Ningún ítem seleccionado cumple criterios (Compl.+Radicado).", 'warning'); return; }
                console.log(`${items.length} meet criteria.`);
                setState(p => { const tData = Array.isArray(p.trackingData)?p.trackingData:[]; let nTD=[...tData]; let nFD=Array.isArray(p.finalData)?[...p.finalData]:[]; let add=0, upd=0, skip=0; const moved=new Set(); items.forEach(i => { const k=String(i.No_Orden); const idx=nTD.findIndex(t=>t&&String(t.No_Orden)===k); if(idx!==-1){if(nTD[idx].Radicado!==i.Radicado_Comp){if(window.confirm(`Caso ${k} ya existe con Rad. "${nTD[idx].Radicado}".\n¿Actualizar a "${i.Radicado_Comp}"?`)){nTD[idx]={...nTD[idx],Radicado:i.Radicado_Comp};upd++;moved.add(k);}else skip++;}else skip++;}else{nTD.push({Fecha_Ing:i.Fecha_Neg||new Date().toISOString().slice(0,10),No_Orden:i.No_Orden,Nombre:i.Nombre||'',EPS:i.EPS||'',Radicado:i.Radicado_Comp,Estado:TRACKING_STATUSES[0],Notas:''});add++;moved.add(k);}}); nFD=nFD.filter(f=>!(f&&moved.has(String(f.No_Orden)))); let msg=""; if(add>0)msg+=`${add} nuevo(s). `; if(upd>0)msg+=`${upd} actualizado(s). `; if(skip>0)msg+=`${skip} omitido(s).`; if(add>0||upd>0){showNotification(msg.trim(),'success');return{...p,trackingData:nTD,finalData:nFD,editsCount:p.editsCount+add+upd};}else{showNotification(msg.trim()||"No se hicieron cambios.",'info');return{...p,finalData:nFD};}});
           }, [state.templates, state.finalData, state.trackingData, showNotification]);
           const exportForMailMerge = useCallback((data) => { /* ... same exportForMailMerge ... */
                 const cData = Array.isArray(data) ? data : []; if (cData.length === 0) { showNotification("No hay datos en revisión.", "warning"); return; } console.log(`Exporting ${cData.length} for mail.`); try { const safeT = Array.isArray(state.templates) ? state.templates : []; const exp = cData.map(r => { const tName = safeT.find(t => t.id === r?.Tipo_Carta)?.name || "NO_SEL."; return { "Fecha": r?.Fecha_Neg||'', "Orden": r?.No_Orden||'', "Cedula": r?.No_Cedula||'', "Nombre": r?.Nombre||'', "EPS": r?.EPS||'', "Programa": r?.Programa||'', "Email": r?.Email||'', "Motivo": r?.Motivo_Negacion||'', "Desc_PDF": r?.Descripcion_PDF||'', "Just_PDF": r?.Justificacion_PDF||'', "Fund_PDF": r?.Fundamento_Legal_PDF||'', "Tipo_Carta": tName, "Radicado_Comp": r?.Radicado_Comp||'' }; }); const ws = XLSX.utils.json_to_sheet(exp); const wb = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(wb, ws, "DatosMail"); XLSX.writeFile(wb, `Sigweb_MailMerge_${new Date().toISOString().slice(0, 10)}.xlsx`); showNotification("Archivo Mail Merge generado.", "success"); } catch (e) { console.error("Export mail merge error:", e); showNotification("Error al exportar.", "error"); }
           }, [state.templates, showNotification]);
           const updateTrackingData = useCallback((index, updatedRow, isArchived) => { /* ... same updateTrackingData ... */
                 if (typeof index !== 'number' || index < 0) { console.error("Invalid index for updateTracking:", index); return; } const key = isArchived ? 'archivedData' : 'trackingData'; setState(p => { const d = Array.isArray(p[key]) ? p[key] : []; if (index < d.length) { const nD = [...d]; nD[index] = updatedRow; console.log(`Updated ${key} index ${index}`); const nE = p.isSaving ? p.editsCount : p.editsCount + 1; return { ...p, [key]: nD, editsCount: nE }; } else { console.error(`Index ${index} out of bounds for ${key}`); return p; } });
           }, []);
           const archiveItems = useCallback((indices, fromArchived) => { /* ... same archiveItems ... */
                 if (!Array.isArray(indices) || indices.some(isNaN) || indices.length === 0) { console.warn("Invalid indices for archive:", indices); return; } console.log(`${fromArchived?'Unarchiving':'Archiving'} indices:`, indices); const srcK = fromArchived ? 'archivedData' : 'trackingData'; const tgtK = fromArchived ? 'trackingData' : 'archivedData'; setState(p => { const srcD = Array.isArray(p[srcK]) ? p[srcK] : []; const tgtD = Array.isArray(p[tgtK]) ? [...p[tgtK]] : []; const toMove = []; const remainIdx = new Set(srcD.map((_, i) => i)); indices.forEach(idx => { if (idx >= 0 && idx < srcD.length && srcD[idx]) { toMove.push(srcD[idx]); remainIdx.delete(idx); } }); if (toMove.length === 0) { console.warn("No valid items to move."); return p; } const newSrc = Array.from(remainIdx).map(i => srcD[i]); const newTgt = [...tgtD, ...toMove]; console.log(`Moving ${toMove.length} items.`); return { ...p, [srcK]: newSrc, [tgtK]: newTgt, editsCount: p.isSaving ? p.editsCount : p.editsCount + toMove.length }; });
           }, []);
           const handleSaveTemplates = useCallback((newTemplates) => { /* ... same handleSaveTemplates ... */
                const t = Array.isArray(newTemplates) ? newTemplates : defaultTemplates; setState(p => ({ ...p, templates: t })); saveTemplates(t); showNotification('Plantillas guardadas.', 'success');
           }, [showNotification]);
           const handleResetTemplates = useCallback(() => { /* ... same handleResetTemplates ... */
                if (window.confirm('¿Restaurar plantillas? Se perderán las personalizadas.')) { handleSaveTemplates([...defaultTemplates]); }
           }, [handleSaveTemplates]);
           const sortedFinalData = useMemo(() => { /* ... same sortedFinalData ... */
                let items = Array.isArray(state.finalData) ? [...state.finalData] : []; if (sortConfig.key) { items.sort((a, b) => { if (!a || !b) return 0; const aV = a[sortConfig.key]??''; const bV = b[sortConfig.key]??''; let comp; if (sortConfig.key === 'No_Orden') { const nA = parseInt(aV, 10), nB = parseInt(bV, 10); if (!isNaN(nA) && !isNaN(nB)) comp = nA - nB; } if (comp === undefined) comp = String(aV).localeCompare(String(bV), undefined, { numeric: true, sensitivity: 'base' }); return sortConfig.direction === 'ascending' ? comp : -comp; }); } return items;
           }, [state.finalData, sortConfig]);
           const handleCloseSetupModal = useCallback(() => { /* ... same handleCloseSetupModal ... */
                 if (!state.isSetupNeeded || state.scriptUrl) { setState(p => ({ ...p, isReconfiguring: false })); } else { alert("Debes configurar y verificar la URL."); }
           }, [state.isSetupNeeded, state.scriptUrl]);

          // ================== Render Logic ==================
          if (state.isLoading && !state.isSetupNeeded) { return <div className="fixed inset-0 bg-background/90 flex items-center justify-center z-[300]"><Spinner /> <span className="ml-4 text-xl">Cargando Datos...</span></div>; }
          if (state.isSetupNeeded || state.isReconfiguring) { return <SetupModal onSave={handleSetScriptUrl} onClose={handleCloseSetupModal} initialUrl={state.scriptUrl || ''} />; }

          return ( /* ... App JSX ... */
             <div className="p-3 sm:p-6 bg-background min-h-screen text-sm">
                {state.notification && <Notification message={state.notification.message} type={state.notification.type} onClose={hideNotification} />}
                {!state.onlineStatus && <div className="bg-yellow-500 text-black text-center p-2 fixed top-0 left-0 w-full z-[100] shadow font-semibold">⚠ Desconectado. Guardado deshabilitado.</div>}
                <main className={`max-w-screen-2xl mx-auto bg-surface p-4 sm:p-5 rounded-xl border border-border-color space-y-6 ${!state.onlineStatus ? 'pt-12 sm:pt-14' : ''}`}>
                    <Header onSave={handleSave} onManageTemplates={() => setState(p => ({ ...p, isTemplateManagerOpen: true }))} onReconfigure={() => setState(p => ({ ...p, isReconfiguring: true }))} />
                    <Dashboard reviewCount={state.finalData.length} trackingCount={state.trackingData.length} archivedCount={state.archivedData.length} editsCount={state.editsCount} />
                    <div className="text-right"><button onClick={() => exportDetailedReport(state.finalData, state.trackingData, state.archivedData)} className="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-3 rounded-lg transition-colors text-xs sm:text-sm">Descargar Reporte</button></div>
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <DataInputArea id="portal-area" title="Área 1: Cargar Excel Portal" headers={PORTAL_HEADERS} data={state.portalData} onDataChange={d=>setState(p=>({...p,portalData:d}))} onProcess={processPortalData} processButtonText="Procesar y Añadir" inputType="file" />
                        <DataInputArea id="pdf-area" title="Área 2: Pegar Datos PDF" headers={PDF_HEADERS} data={state.pdfData} onDataChange={d=>setState(p=>({...p,pdfData:d}))} onProcess={mergePdfData} processButtonText="Combinar con Revisión" inputType="paste" />
                    </div>
                    <ReviewArea data={sortedFinalData} templates={state.templates} updateRow={updateFinalDataRow} incrementEdits={incrementEdits} onSendToTracking={handleSendToTracking} onPreview={row=>setState(p=>({...p,previewData:row}))} onExportForMailMerge={exportForMailMerge} onClearReviewData={handleClearReviewData} sortConfig={sortConfig} setSortConfig={setSortConfig} />
                    <TrackingArea trackingData={state.trackingData} archivedData={state.archivedData} updateTrackingData={updateTrackingData} archiveItems={archiveItems} />
                    {state.isSaving && <div className="fixed inset-0 bg-background/80 flex items-center justify-center z-[300]"><Spinner /> <span className="ml-4 text-lg">Guardando...</span></div>}
                </main>
                {state.isTemplateManagerOpen && <TemplateManagerModal templates={state.templates} onClose={()=>setState(p=>({...p,isTemplateManagerOpen:false}))} onSave={handleSaveTemplates} onReset={handleResetTemplates} />}
                {state.previewData && <PreviewModal data={state.previewData} template={Array.isArray(state.templates)?state.templates.find(t=>t.id===state.previewData?.Tipo_Carta):null} onClose={()=>setState(p=>({...p,previewData:null}))} />}
             </div>
           );
        }; // End of App Component

        // =================================================================================
        // INLINED: index.tsx (Render the application) - No changes needed
        // =================================================================================
        const rootElement = document.getElementById('root');
        if (!rootElement) {
          console.error("Fatal Error: #root not found.");
          document.body.innerHTML = '<div style="color: red; padding: 20px; font-family: sans-serif; background-color: #333; text-align: center;"><h1>Error Crítico</h1><p>#root no encontrado. Verifica HTML.</p></div>';
        } else {
            try {
               const root = ReactDOM.createRoot(rootElement);
               root.render(<App />);
            } catch(error) {
                console.error("React render error:", error);
                 rootElement.innerHTML = `<div style="color: orange; padding: 20px; font-family: sans-serif; background-color: #333;"><h1>Error Crítico React</h1><pre style="white-space: pre-wrap; word-wrap: break-word;">${error.stack || error.message}</pre></div>`;
            }
        }

    </script>
</body>
</html>
